msgid ""
msgstr "Project-Id-Version: Game v4.23.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-18\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#. ยง0: `x : U`
#. ยง1: `A : Set U`
#. ยง2: `B : Set U`
#. ยง3: `mem_union x A B`
#. ยง4: `x โ A โช B โ x โ A โจ x โ B`
#. ยง5: `Set.mem_union`
#: Game.Levels.Union.L02subunion
msgid "If you have ยง0, ยง1, and ยง2, then ยง3 is a proof of the statement ยง4.  In Mathlib, the name of this theorem is ยง5."
msgstr ""

#. ยง0: `F`
#. ยง1: `U`
#. ยง2: `F`
#. ยง3: `U`
#. ยง4: `F`
#: Game.Levels.FamUnion
msgid "If ยง0 is a family of sets from ยง1, then the *union* of ยง2 is the set of all objects from ยง3 that belong to at least one element of ยง4.  We'll investigate unions of families in this world."
msgstr ""

#: Game.Levels.FamInter.L03interpair
msgid "Intersection of a pair"
msgstr ""

#: Game.Levels.Combo.L03inter_distrib_union
msgid "This proof is longer than previous ones, but it doesn't require any new tactics or theorems. Just stick with it and keep applying the ideas from previous levels!"
msgstr ""

#. ยง0: `x โ A โ x โ C`
#. ยง1: `x โ A`
#. ยง2: `h3`
#. ยง3: `intro h3`
#: Game.Levels.Subset.L04imp
msgid "Since our goal in this level is the statement ยง0, our first step for this proof is to assume ยง1.  To introduce that assumption, assigning it the identifier ยง2, type ยง3."
msgstr ""

#: Game.Levels.Union.L05union_comm
msgid "Union is commutative"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ๐"
msgstr ""

#. ยง0: `compl_subset_compl_of_subset ยซ{h1}ยป`
#: Game.Levels.Comp.L05compsubiff
msgid "ยง0 will prove the goal."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "Union is associative"
msgstr ""

#. ยง0: `ยซ{h1}ยป`
#. ยง1: `ยซ{x}ยป โ Aแถ`
#. ยง2: `ยฌยซ{x}ยป โ Aแถ`
#: Game.Levels.Comp.L04compcomp
msgid "The assumption ยง0 now says ยง1, which means ยง2.  It will be helpful to write out the definition of complement again in this assumption."
msgstr ""

#. ยง0: `ยซ{x}ยป : U`
#. ยง1: `ยซ{x}ยป โ A โฉ B โฉ C โ ยซ{x}ยป โ A โฉ (B โฉ C)`
#. ยง2: `A โฉ B โฉ C`
#. ยง3: `A โฉ (B โฉ C)`
#: Game.Levels.Inter.L08inter_assoc
msgid "Notice that Lean has introduced the new object ยง0 into the proof, and your goal is now ยง1.  Proving this goal will show that ยง2 and ยง3 have exactly the same elements, and by the principle of extensionality, that will show that the sets are equal."
msgstr ""

#. ยง0: $s \\in F$
#. ยง1: $u \\in G$
#. ยง2: $s \\cap u \\in H$
#. ยง3: $(\\bigcup F) \\cap (\\bigcap G) \\subseteq \\bigcup H$
#: Game.Levels.FamCombo.L04threefam
msgid "Suppose that for every ยง0 there is some ยง1 such that ยง2. Then ยง3."
msgstr ""

#. ยง0: `push_neg`
#: Game.Levels.Comp.L04compcomp
msgid "There are two ways to complete the proof now.  Since your goal is a negative statement, one natural strategy to use would be proof by contradiction.  A second possibility is to imitate the approach in the first half: write out the meaning of complement again in the goal, and then use the ยง0 tactic to simplify the resulting double-negative goal.  Either approach will work."
msgstr ""

#. ยง0: `compl_subset_compl_of_subset ยซ{h1}ยป`
#: Game.Levels.Comp.L05compsubiff
msgid "The theorem ยง0 doesn't prove the goal, but it comes close.  Do you see what assertion it will justify?"
msgstr ""

#. ยง0: `intro`
#. ยง1: `intro`
#. ยง2: `intro`
#: Game.Levels.FamInter.L02intersubinter
msgid "You probably used ยง0 several times in this proof.  Recall that two ยง1 steps in a row can be combined into one step.  Click on ยง2 in the list of tactics on the right for further details."
msgstr ""

#. ยง0: $F$
#. ยง1: $\\bigcap F$
#. ยง2: `F`
#. ยง3: `โโ F`
#. ยง4: `โโ`
#. ยง5: `\\I0`
#. ยง6: `F : Set (Set U)`
#. ยง7: `x : U`
#. ยง8: `x โ โโ F`
#. ยง9: `t`
#. ยง10: `t`
#. ยง11: `F`
#. ยง12: `x โ t`
#. ยง13: `โ t, t โ F โ x โ t`
#. ยง14: `โ t โ F, x โ t`
#. ยง15: `โ`
#. ยง16: `\\forall`
#. ยง17: `โ t, t โ F โ x โ t`
#. ยง18: `โ t, (t โ F โ x โ t)`
#. ยง19: `(โ t, t โ F) โ x โ t`
#. ยง20: `mem_sInter`
#. ยง21: `x โ โโ F โ โ t โ F, x โ t`
#: Game.Levels.FamInter.L01intersub
msgid "In mathematical writing, the intersection of the family ยง0 is usually denoted ยง1. In Lean, the intersection of a family ยง2 is denoted ยง3.  (You can enter the symbol ยง4 by typing ยง5.)\n"
"\n"
"Suppose we have ยง6 and ยง7.  Then ยง8 means that for every set ยง9, if ยง10 is in ยง11, then ยง12.  To write this statement in Lean, we write ยง13. Lean abbreviates this statement as ยง14. The symbol ยง15 is called the *universal quantifier*, and you can enter it in Lean by typing ยง16.  Note that ยง17 means ยง18, not ยง19.  In other words, Lean interprets the universal quantifier as applying to the entire rest of the statement.  If you want it to apply to less, you have to use parentheses to indicate that.\n"
"\n"
"As with other set theory operations, we have a theorem that expresses this definition.  Lean will recognize ยง20 as a proof of any statement of the form ยง21.\n"
"\n"
"In this level, you'll try out these ideas."
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `push_neg`
#. ยง2: `push_neg at h`
#. ยง3: `h`
#. ยง4: `apply`
#. ยง5: `push_neg`
#. ยง6: `apply`
#. ยง7: `compl_compl`
#: Game.Levels.Comp.L04compcomp
msgid "The ยง0 tactic can reexpress a number of different kinds of negative statements as equivalent positive statements; use ยง1 to reexpress a negative goal, and ยง2 to reexpress a negative assumption ยง3. We'll see many more uses of the ยง4 tactic in this game. For more details about the use of these tactics, click on ยง5 or ยง6 under the list of tactics on the right.\n"
"\n"
"We have given this theorem the name ยง7.  Both this theorem and the one in the previous level will be useful in the next level."
msgstr ""

#. ยง0: `A โ C`
#: Game.Levels.Subset.L06subtrans
msgid "To start a proof, you should look first at the goal. What needs to be done to prove the goal? In this level, the goal is ยง0.  What does that tell you about how to proceed?"
msgstr ""

#. ยง0: $A \\subseteq B$
#. ยง1: $B^c \\subseteq A^c$
#: Game.Levels.Comp.L03compsub
#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Suppose ยง0.  Then ยง1."
msgstr ""

#. ยง0: `ยฌA โ B`
#. ยง1: `h3 : A โ B`
#. ยง2: `by_contra h3`
#: Game.Levels.Comp.L01contra
msgid "For the theorem in this level, your goal is ยง0.  To use proof by contradiction in this proof, you must begin by introducing the assumption ยง1.  To do that, type ยง2"
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "Implication"
msgstr ""

#. ยง0: `{a}`
#. ยง1: `a`
#. ยง2: `mem_singleton_iff`
#. ยง3: `mem_singleton_iff`
#. ยง4: `x โ {a} โ x = a`
#: Game.Levels.FamCombo.L08singleton
msgid "The notation ยง0 denotes a set whose only element is ยง1; such a set is called a *singleton* set.  The theorem ยง2 expresses the definition of singleton sets: ยง3 is a proof of any statement of the form ยง4."
msgstr ""

#: Game.Levels.FamInter.L06eltwiseunion
msgid "Notice that you have contradictory assumptions.  You can prove anything from contradictory assumptions.  Do you see how?"
msgstr ""

#. ยง0: `ยซ{h1}ยป`
#. ยง1: `have hAB : ยซ{x}ยป โ A โฉ B := ยซ{h1}ยป.left`
#: Game.Levels.Inter.L08inter_assoc
msgid "If you're stuck at this point, it may help you see how to proceed if you separate out the first half of ยง0 as a separate assumption. You can do this with ยง1."
msgstr ""

#: Game.Levels.FamUnion.L04unionpair
msgid "Union of a pair"
msgstr ""

#. ยง0: `by_cases h : P`
#. ยง1: `h : P`
#. ยง2: `h : ยฌP`
#: Game.Levels.FamInter.L06eltwiseunion
msgid "The tactic ยง0 breaks the proof into two cases.  In the first case, the assumption ยง1 is added to the list of assumptions, and in the second case, the assumption ยง2 is added."
msgstr ""

#: Game.Levels.Combo.L02compint
msgid "Do you see how you can now use the theorem from the previous level?"
msgstr ""

#. ยง0: `t`
#. ยง1: `P โ Q`
#. ยง2: `rewrite [t]`
#. ยง3: `P`
#. ยง4: `Q`
#. ยง5: `Q`
#. ยง6: `P`
#. ยง7: `rewrite [โ t]`
#. ยง8: `\\l`
#. ยง9: `โ`
#. ยง10: `h`
#. ยง11: `rewrite [t] at h`
#. ยง12: `rewrite`
#. ยง13: `t`
#. ยง14: `p = q`
#. ยง15: `rewrite [t]`
#. ยง16: `p`
#. ยง17: `q`
#. ยง18: `rewrite [โ t]`
#. ยง19: `q`
#. ยง20: `p`
#. ยง21: `rewrite [t1, t2]`
#: Game.Levels.Comp.L03compsub
msgid "If the expression ยง0 is a proof of a statement of the form ยง1, then the tactic ยง2 will replace ยง3 anywhere that it occurs in the goal with ยง4.  If you want to replace ยง5 with ยง6, use ยง7.  (Type ยง8 to enter the symbol ยง9.)  To do the replacement in an assumption ยง10, use ยง11.\n"
"\n"
"The ยง12 tactic can also be used with equations.  If ยง13 is a proof of an equation ยง14, then ยง15 will replace ยง16 with ยง17 wherever it appears, and ยง18 will replace ยง19 with ยง20.\n"
"\n"
"To do multiple replacements, one after another, put a list of proofs inside the brackets, like this:  ยง21."
msgstr ""

#. ยง0: `Aแถแถ โ A`
#. ยง1: `A โ Aแถแถ`
#: Game.Levels.Comp.L04compcomp
#: Game.Levels.Inter.L05subint
msgid "Your immediate goal now is to prove that ยง0.  Once you close that goal, you'll be asked to prove the second goal, ยง1."
msgstr ""

#. ยง0: `rewrite [mem_setOf]`
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "You can use ยง0 to write out the meaning of the goal."
msgstr ""

#. ยง0: `P`
#. ยง1: `by_cases h : P`
#. ยง2: `h : P`
#. ยง3: `h : ยฌP`
#. ยง4: `P`
#: Game.Levels.FamInter.L06eltwiseunion
msgid "In this level you'll need a new kind of proof by cases.  For any statement ยง0, the tactic ยง1 will break the proof into two cases.  In the first case, the new assumption ยง2 is added to the list of assumptions, and in second, the new assumption ยง3 is added.  Since ยง4 must be either true or false, these two cases cover all possibilities."
msgstr ""

#: Game.Levels.FamCombo.L04threefam
msgid "A theorem about three families"
msgstr ""

#. ยง0: `by_contra`
#. ยง1: `ยฌ`
#. ยง2: `by_contra`
#. ยง3: `False`
#. ยง4: `False`
#. ยง5: `h1 : P`
#. ยง6: `h2 : ยฌP`
#. ยง7: `P`
#. ยง8: `exact h2 h1`
#. ยง9: `exact h1 h2`
#: Game.Levels.Comp.L01contra
msgid "You can use the ยง0 tactic in any proof to assume the opposite of your goal.  But it is most useful when the goal starts with the symbol ยง1.  After using the ยง2 tactic, your goal will be ยง3.\n"
"\n"
"To complete a proof by contradiction, you must prove contradictory statements. If your goal is ยง4 and you have assumptions ยง5 and ยง6, for some statement ยง7, then ยง8 will close the goal.  Note that ยง9 won't work; you must list the negative statement first to establish a contradiction."
msgstr ""

#: Game.Levels.FamCombo.L08singleton
msgid "A set that must be a singleton"
msgstr ""

#. ยง0: `x`
#. ยง1: `h2`
#. ยง2: `intro x h2`
#: Game.Levels.Comp.L03compsub
msgid "As usual, to prove a subset statement you need to introduce both a new object ยง0 and a new assumption ยง1.  You can do it in one step with ยง2."
msgstr ""

#. ยง0: `inter_subset_swap`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `inter_subset_swap A B`
#. ยง4: `A โฉ B โ B โฉ A`
#: Game.Levels.Inter.L06inter_sub_swap
msgid "We have given this theorem the name ยง0.  Thus, from now on, for any sets ยง1 and ยง2, ยง3 is a proof of ยง4."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "Writing out the meaning of intersection in the goal will help you see what to do to complete this level."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "Do you know which half of the goal you're going to prove now?"
msgstr ""

#. ยง0: `ยซ{h2}ยป`
#. ยง1: `(A โช ยซ{t}ยป)`
#. ยง2: `A โช ยซ{t}ยป`
#: Game.Levels.FamInter.L06eltwiseunion
msgid "Note that you can apply ยง0 to ยง1. You'll need to include the parentheses around ยง2 when you do that."
msgstr ""

#. ยง0: `cases`
#. ยง1: `rcases`
#. ยง2: `rcases`
#: Game.Levels.Union.L03cases
msgid "Note that Lean also has a ยง0 tactic, but the syntax is a little more complicated. That's why we have chosen to use the ยง1 tactic.\n"
"\n"
"The ยง2 tactic has other uses.  However, in this game we will be using it only with assumptions that are \"or\" statements, to break the proof into cases."
msgstr ""

#: Game.Levels.Subset.L02subhyp
msgid "A subset hypothesis"
msgstr ""

#. ยง0: $F$
#. ยง1: $G$
#. ยง2: $F \\subseteq G$
#. ยง3: $\\bigcap G \\subseteq \\bigcap F$
#: Game.Levels.FamInter.L02intersubinter
#: Game.Levels.FamUnion.L03unionsubunion
msgid "Suppose ยง0 and ยง1 are families of sets and ยง2. Then ยง3."
msgstr ""

#. ยง0: `rewrite`
#. ยง1: `exact And.intro h1 h2`
#: Game.Levels.Inter.L04proveand
msgid "Once again, the use of ยง0 was not really necessary.  You could prove this theorem with the single step ยง1."
msgstr ""

#. ยง0: `push_neg`
#. ยง1: `h`
#. ยง2: `push_neg at h`
#. ยง3: `h`
#. ยง4: `push_neg`
#. ยง5: `ยฌยฌP`
#. ยง6: `P`
#. ยง7: `ยฌ(P โจ Q)`
#. ยง8: `ยฌP โง ยฌQ`
#. ยง9: `ยฌ(P โง Q)`
#. ยง10: `P โ ยฌQ`
#. ยง11: `ยฌ(P โ Q)`
#. ยง12: `P โง ยฌQ`
#. ยง13: `ยฌโ x, P x`
#. ยง14: `โ x, ยฌP x`
#. ยง15: `ยฌโ x, P x`
#. ยง16: `โ x, ยฌP x`
#: Game.Levels.Comp.L04compcomp
msgid "If your goal is a negative statement, then the tactic ยง0 will try to reexpress it as an equivalent positive statement.  Similarly, if an assumption ยง1 is a negative statement, then ยง2 will try to reexpress ยง3.  Here are some examples of reexpressions performed by the ยง4 tactic: * ยง5 is converted to ยง6. * ยง7 is converted to ยง8. * ยง9 is converted to ยง10. * ยง11 is converted to ยง12. * ยง13 is converted to ยง14. * ยง15 is converted to ยง16."
msgstr ""

#. ยง0: `h1 : A โ B`
#. ยง1: `h2 : B โ C`
#. ยง2: `Subset.trans h1 h2`
#. ยง3: `A โ C`
#. ยง4: `Set.Subset.trans`
#: Game.Levels.Subset.L06subtrans
#: Game.Levels.Comp.L04compcomp
msgid "If you have ยง0 and ยง1, then ยง2 is a proof of ยง3. In Mathlib, the name of this theorem is ยง4."
msgstr ""

#: Game
msgid "In this game you will learn the basics of theorem proving in Lean by proving theorems about unions, intersections, and complements of sets."
msgstr ""

#: Game.Levels.Inter.L07inter_comm
msgid "We'll prove one more property of intersections in the next level."
msgstr ""

#. ยง0: `hFG : ยซ{t}ยป โ F โช G`
#. ยง1: `ยซ{h1}ยป ยซ{t}ยป hFG`
#. ยง2: `apply ยซ{h1}ยป ยซ{t}ยป`
#. ยง3: `ยซ{h1}ยป ยซ{t}ยป`
#. ยง4: `ยซ{t}ยป โ F โช G`
#. ยง5: `ยซ{t}ยป โ F โช G`
#: Game.Levels.FamInter.L04interunion
msgid "Here's an approach you might try:  If only you had ยง0, then ยง1 would prove the goal.  So if you use the tactic ยง2, Lean will figure out that ยง3 could be applied to a proof of ยง4 to prove the goal, and it will therefore set ยง5 as your goal."
msgstr ""

#. ยง0: $F$
#. ยง1: $G$
#. ยง2: $\\bigcap (F \\cup G) = (\\bigcap F) \\cap (\\bigcap G)$
#: Game.Levels.FamInter.L04interunion
#: Game.Levels.FamUnion.L05unionunion
#: Game.Levels.FamCombo.L05unionintcompunion
#: Game.Levels.FamCombo.L07unionintcompint
msgid "Suppose ยง0 and ยง1 are families of sets.  Then ยง2."
msgstr ""

#. ยง0: `apply Or.inl`
#. ยง1: `apply Or.inr`
#. ยง2: `left`
#. ยง3: `apply Or.inl`
#. ยง4: `right`
#. ยง5: `apply Or.inr`
#. ยง6: `ext x`
#. ยง7: `apply Subset.antisymm`
#: Game.Levels.Union.L06union_assoc
msgid "Here's an idea that you may find helpful for this proof: If you're proving an \"or\" statement and you think you'll be able to prove either the left or right side of the statement, then ยง0 or ยง1 will set the goal to be the left or right side.  Alternatively, the tactic ยง2 has the same effect as ยง3, and ยง4 has the same effect as ยง5.\n"
"\n"
"You can start this proof with either ยง6 or ยง7."
msgstr ""

#. ยง0: `x`
#. ยง1: `x โ A โฉ B`
#: Game.Levels.Inter.L03inter_sub_left
msgid "Since the goal is a subset statement, you should start by introducing an object ยง0 and the assumption that ยง1."
msgstr ""

#. ยง0: `A โ B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `โ`
#. ยง4: `\\sub`
#: Game.Levels.Subset.L02subhyp
msgid "ยง0 means that ยง1 is a subset of ยง2.  To enter the symbol ยง3, type ยง4."
msgstr ""

#. ยง0: `And.intro ยซ{h}ยป.right ยซ{h}ยป.left`
#: Game.Levels.Inter.L06inter_sub_swap
msgid "Now ยง0 proves the goal."
msgstr ""

#: Game.Levels.Union.L01or
msgid "Now we're ready to start proving theorems about unions."
msgstr ""

#. ยง0: `exact`
#. ยง1: `t`
#. ยง2: `exact t`
#: Game.Levels.Subset.L01exact
msgid "Use ยง0 to close a goal.  If some expression ยง1 is a proof of the goal, then ยง2 will close the goal.\n"
"\n"
"Think of \"exact\" as meaning \"this is exactly what is needed to prove the goal.\""
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Intersection is associative"
msgstr ""

#. ยง0: `โโ F`
#. ยง1: `(โโ G)แถ`
#. ยง2: `F`
#. ยง3: `G`
#: Game.Levels.FamCombo.L05unionintcompunion
msgid "What happens if you intersect ยง0 with ยง1, for two families ยง2 and ยง3?"
msgstr ""

#: Game.Levels.Combo.L03inter_distrib_union
msgid "Intersection distributes over union"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `rfl`
#. ยง4: `X = Y`
#. ยง5: `X`
#. ยง6: `Y`
#: Game.Levels.Comp.L02compdef
msgid "If your goal is a statement of the form ยง0, and ยง1 and ยง2 are definitionally equivalent (that is, equivalent by virtue of the definitions of the symbols occurring in them), then the ยง3 tactic will close the goal.  It will also close a goal of the form ยง4, if ยง5 and ยง6 are definitionally equal (that is, equal by virtue of definitions)."
msgstr ""

#. ยง0: `h1`
#. ยง1: `A`
#. ยง2: `A`
#. ยง3: `A`
#: Game.Levels.FamCombo.L08singleton
msgid "You need to apply ยง0 to a family of sets with two properties: the union of the family must be ยง1, and knowing that ยง2 belongs to the family must help you prove that ยง3 is a singleton."
msgstr ""

#. ยง0: `compl_subset_compl_of_subset`
#. ยง1: `compl_subset_compl_of_subset`
#: Game.Levels.Comp.L05compsubiff
msgid "Fortunately, the theorem ยง0 can now be used to prove the goal. (Click on ยง1 in the list of theorems on the right if you don't remember what the theorem says.)"
msgstr ""

#: Game.Levels.Union.L03cases
msgid "Proof by cases"
msgstr ""

#. ยง0: `ยซ{x}ยป โ B โช C`
#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "Now that you know ยง0, you can use that statement as the basis for breaking your proof into cases."
msgstr ""

#. ยง0: `intro h1`
#: Game.Levels.Inter.L08inter_assoc
msgid "Since your goal is an \"if-then\" statement, a good next step is ยง0."
msgstr ""

#. ยง0: `rewrite [compl_compl A] at ยซ{h2}ยป`
#. ยง1: `Aแถแถ`
#. ยง2: `A`
#. ยง3: `rewrite [compl_compl B] at ยซ{h2}ยป`
#. ยง4: `Bแถแถ`
#. ยง5: `B`
#. ยง6: `rewrite [compl_compl A, compl_compl B] at ยซ{h2}ยป`
#: Game.Levels.Comp.L05compsubiff
msgid "ยง0 will change ยง1 to ยง2, and ยง3 will change ยง4 to ยง5.  In fact, you can do both rewrites in one step:  ยง6."
msgstr ""

#. ยง0: `ยซ{h1}ยป`
#. ยง1: `ยซ{x}ยป โ โโ F`
#. ยง2: `apply ยซ{h1}ยป`
#. ยง3: `ยซ{x}ยป โ โโ F`
#: Game.Levels.FamUnion.L06unionsub
msgid "Notice that ยง0 could be applied to a proof of ยง1 to prove the goal.  That means that ยง2 will set ยง3 as the goal."
msgstr ""

#. ยง0: $A$
#. ยง1: $(A^c)^c = A$
#: Game.Levels.Comp.L04compcomp
msgid "Suppose ยง0 is a set.  Then ยง1."
msgstr ""

#. ยง0: `apply Iff.intro`
#. ยง1: `A โ B โ Bแถ โ Aแถ`
#. ยง2: `Bแถ โ Aแถ โ A โ B`
#: Game.Levels.Comp.L05compsubiff
msgid "For the proof in this level, ยง0 will create the goals ยง1 and ยง2."
msgstr ""

#: Game
msgid "A game about set theory."
msgstr ""

#. ยง0: `ยซ{h3}ยป h1`
#. ยง1: `x โ B`
#: Game.Levels.Comp.L01contra
msgid "ยง0 is a proof of ยง1."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `Subset.antisymm`
#. ยง3: `h1 : A โ B`
#. ยง4: `h2 : B โ A`
#. ยง5: `Subset.antisymm h1 h2`
#. ยง6: `A = B`
#. ยง7: `Subset.antisymm`
#. ยง8: `A โ B`
#. ยง9: `B โ A`
#. ยง10: `apply`
#. ยง11: `A = B`
#. ยง12: `apply Subset.antisymm`
#. ยง13: `Subset.antisymm`
#. ยง14: `A โ B`
#. ยง15: `B โ A`
#. ยง16: `apply Subset.antisymm`
#. ยง17: `push_neg`
#: Game.Levels.Comp.L04compcomp
msgid "How do we prove that two sets ยง0 and ยง1 are equal?  One way to do it is to use the theorem ยง2.  This theorem is pre-defined in this game; you don't need to prove it. If you have ยง3 and ยง4, then ยง5 is a proof of ยง6.  The theorem ยง7 says that the subset relation has a property called *antisymmetry*.\n"
"\n"
"But what if you don't already know ยง8 and ยง9?  In that case, you can use a new tactic, ยง10.  If your goal is ยง11 and you write ยง12, then Lean will figure out that the theorem ยง13 could be applied to prove the goal, if only you had proofs of ยง14 and ยง15.  So it will set those *two* statements as goals.\n"
"\n"
"If your goal says that two sets are equal, a good way to begin is with ยง16.  (Later we'll see a second approach to proving sets are equal.)\n"
"\n"
"This level also introduces another new tactic, ยง17."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "As usual, if you're not sure how to proceed then writing out definitions can help."
msgstr ""

#. ยง0: `โโ F`
#. ยง1: `F`
#. ยง2: `โโ`
#. ยง3: `\\I0`
#: Game.Levels.FamInter.L01intersub
msgid "ยง0 is the intersection of the family of sets ยง1.  To enter the symbol ยง2, type ยง3."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "The second goal is similar, but a little trickier."
msgstr ""

#. ยง0: `F`
#. ยง1: `G`
#. ยง2: `โโ (F โช G)`
#: Game.Levels.FamInter.L04interunion
msgid "If ยง0 and ยง1 are families of sets, what is ยง2?  In this level, you'll find out!"
msgstr ""

#. ยง0: `h1 h2`
#. ยง1: `x โ B`
#. ยง2: `exact h1 h2`
#: Game.Levels.Subset.L02subhyp
msgid "Since ยง0 is a proof of ยง1, you can close the goal with ยง2."
msgstr ""

#. ยง0: `F`
#. ยง1: `G`
#. ยง2: `โโ (F โช G)`
#. ยง3: `โโ F`
#. ยง4: `โโ G`
#: Game.Levels.FamUnion.L05unionunion
msgid "In this level, ยง0 and ยง1 are families of sets, and you'll work out how ยง2 is related to ยง3 and ยง4."
msgstr ""

#. ยง0: `h2`
#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "Notice that you haven't used ยง0 yet..."
msgstr ""

#. ยง0: `rfl`
#. ยง1: `=`
#. ยง2: `โ`
#. ยง3: `mem_compl_iff`
#: Game.Levels.Comp.L02compdef
msgid "The name of the tactic ยง0 is short for \"reflexivity\", which is the property of both ยง1 and ยง2 that is the basis for the tactic.\n"
"\n"
"We have given the theorem proven in this level the name ยง3.  In the next level, we will see how we can use it to prove theorems about complements."
msgstr ""

#. ยง0: `A`
#. ยง1: `U`
#. ยง2: `Aแถ`
#. ยง3: `A`
#. ยง4: `Aแถ`
#. ยง5: `U`
#. ยง6: `A`
#. ยง7: `แถ`
#. ยง8: `\\compl`
#. ยง9: `\\^c`
#: Game.Levels.Comp.L02compdef
msgid "If ยง0 is a of objects from the universe ยง1, then ยง2 is the complement of ยง3; that is, ยง4 is the set of objects from ยง5 that are not elements of ยง6.  You can enter the symbol ยง7 by typing ยง8 or ยง9."
msgstr ""

#. ยง0: `compl_union`
#. ยง1: `compl_union`
#. ยง2: `push_neg`
#: Game.Levels.FamCombo.L01compunion
msgid "In this level you'll prove a generalization of the theorem ยง0 that you proved in Combination World.  That theorem was about the complement of a union of two sets; the theorem in this level is about the complement of a union of a family of sets.\n"
"\n"
"As in the case of ยง1, you have a choice about how to deal with the negations that arise when you write out the meaning of complement.  You can use the ยง2 tactic to reexpress negative statements, or you can use proof by contradiction."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#. ยง1: `have ยซ{h}ยปBC : ยซ{x}ยป โ B โช C := ยซ{h}ยป.right`
#: Game.Levels.Combo.L03inter_distrib_union
msgid "It may help you see how to proceed if you separate out the second half of ยง0 as a separate assumption. You can do this with ยง1."
msgstr ""

#. ยง0: $A \\subseteq B$
#. ยง1: $B \\subseteq C$
#. ยง2: $A \\subseteq C$
#: Game.Levels.Subset.L06subtrans
#: Game.Levels.Comp.L01contra
#: Game.Levels.Inter.L01and
#: Game.Levels.Inter.L04proveand
#: Game.Levels.Inter.L05subint
#: Game.Levels.Union.L03cases
#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "Suppose ยง0 and ยง1.  Then ยง2."
msgstr ""

#. ยง0: `mem_compl_iff A ยซ{x}ยป`
#. ยง1: `ยซ{x}ยป โ Aแถ โ ยซ{x}ยป โ A`
#. ยง2: `ยซ{x}ยป โ Aแถ`
#. ยง3: `ยซ{x}ยป โ A`
#. ยง4: `rewrite [mem_compl_iff A ยซ{x}ยป]`
#: Game.Levels.Comp.L03compsub
msgid "Now ยง0 is a proof of the statement ยง1, which tells us that we can reexpress the goal ยง2 as ยง3.  To do this reexpression, use the tactic ยง4."
msgstr ""

#: Game.Levels.FamUnion.L06unionsub
msgid "Union subset of a set"
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `constructor`
#. ยง2: `P โ Q`
#. ยง3: `Q โ P`
#. ยง4: `P โง Q`
#. ยง5: `constructor`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `constructor`
#: Game.Levels.Comp.L05compsubiff
msgid "If your goal has the form ยง0, then the tactic ยง1 will replace this goal with the two goals ยง2 and ยง3.  If your goal has the form ยง4, then ยง5 will replace this goal with the two goals ยง6 and ยง7.  There are other situations in which the ยง8 tactic can be used, but these two are the ones that are most relevant for the set theory game."
msgstr ""

#: Game.Levels.Inter
msgid "Intersection World"
msgstr ""

#: Game.Levels.Inter.L07inter_comm
msgid "Intersection is commutative"
msgstr ""

#: Game.Levels.FamCombo.L06unionintunion
msgid "What happens if the subset statement in the last level is reversed?"
msgstr ""

#. ยง0: `x โ A`
#. ยง1: `x`
#. ยง2: `A`
#. ยง3: `โ`
#. ยง4: `\\mem`
#. ยง5: `\\in`
#: Game.Levels.Subset.L01exact
msgid "ยง0 means that ยง1 is an element of ยง2.  To enter the symbol ยง3, type ยง4 or ยง5."
msgstr ""

#: Game.Levels.FamInter.L06eltwiseunion
msgid "Intersection of a family of unions"
msgstr ""

#. ยง0: $x$
#. ยง1: $U$
#. ยง2: $A$
#. ยง3: $U$
#. ยง4: $x \\in A^c \\leftrightarrow x \\notin A$
#: Game.Levels.Comp.L02compdef
msgid "Let ยง0 be an object in the universe ยง1, and let ยง2 be a set whose elements come from ยง3.  Then ยง4."
msgstr ""

#. ยง0: `A : Set U`
#. ยง1: `Aแถ`
#. ยง2: `U`
#. ยง3: `A`
#. ยง4: `x : U`
#. ยง5: `x โ Aแถ`
#. ยง6: `x โ A`
#. ยง7: `x โ Aแถ โ x โ A`
#. ยง8: `โ`
#. ยง9: `\\iff`
#. ยง10: `c`
#. ยง11: `\\compl`
#. ยง12: `\\^c`
#. ยง13: `x โ Aแถ โ x โ A`
#. ยง14: `rfl`
#. ยง15: `rfl`
#. ยง16: `P โ Q`
#. ยง17: `P`
#. ยง18: `Q`
#. ยง19: `P`
#. ยง20: `Q`
#. ยง21: `rfl`
#. ยง22: `X = Y`
#. ยง23: `X`
#. ยง24: `Y`
#: Game.Levels.Comp.L02compdef
msgid "If you have ยง0, then ยง1 is defined to be the set of all objects in the universe ยง2 that are not elements of ยง3.  That means that if you also have ยง4, then the statements ยง5 and ยง6 are equivalent.  We express this by saying that the statement ยง7 is true.  (The symbol ยง8 means \"if and only if\", and you can enter it by typing ยง9.  You can enter the superscript ยง10 in the notation for the complement of a set by typing ยง11 or ยง12.)\n"
"\n"
"In this level, we're going to prove that the statement ยง13 is true, and to do it we'll use a new tactic: ยง14.  The ยง15 tactic can prove any statement of the form ยง16 if ยง17 and ยง18 are statements that are equivalent by virtue of the definitions of the symbols occurring in them.  (We say in this case that ยง19 and ยง20 are *definitionally equivalent*.)  The ยง21 tactic can also prove statements of the form ยง22, if ยง23 and ยง24 are definitionally equal--that is, equal by virtue of definitions."
msgstr ""

#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Union of a family of intersections"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โฉ B`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `โฉ`
#. ยง6: `\\inter`
#. ยง7: `\\cap`
#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "If ยง0 and ยง1 are sets, then ยง2 is the intersection of ยง3 and ยง4. To enter the symbol ยง5, type ยง6 or ยง7."
msgstr ""

#: Game.Levels.FamCombo.L03commonelt
msgid "Two families with an element in common"
msgstr ""

#. ยง0: `h1 : A โ B`
#: Game.Levels.Comp.L05compsubiff
msgid "Of course, you should begin by introducing the assumption ยง0."
msgstr ""

#: Game.Levels.Combo.L01compunion
msgid "Complement of a union"
msgstr ""

#. ยง0: `โ t โ F, ยซ{x}ยป โ t`
#. ยง1: `โ t, t โ F โง ยซ{x}ยป โ t`
#. ยง2: `t`
#. ยง3: `t โ F โง ยซ{x}ยป โ t`
#. ยง4: `h1`
#. ยง5: `ยซ{h2}ยป`
#. ยง6: `t = A`
#. ยง7: `Exists.intro A hA`
#. ยง8: `hA`
#. ยง9: `A โ F โง ยซ{x}ยป โ A`
#. ยง10: `Exists.intro A`
#. ยง11: `A โ F โง ยซ{x}ยป โ A`
#. ยง12: `apply Exists.intro A`
#. ยง13: `A โ F โง ยซ{x}ยป โ A`
#: Game.Levels.FamUnion.L02subunion
msgid "Remember that the goal ยง0 is an abbreviation for ยง1.  As we saw in the last level, we can prove this by coming up with a witness--that is, a value for ยง2 that will make the statement ยง3 come out true.  Looking at ยง4 and ยง5, it looks like ยง6 would work.  That suggests a way to proceed: ยง7 would prove the goal, if ยง8 were a proof of ยง9.  In other words, if ยง10 is applied to a proof of ยง11, then it will prove the goal.  So if you use the tactic ยง12, then Lean will set ยง13 as your new goal."
msgstr ""

#. ยง0: `A โฉ B โฉ C = A โฉ (B โฉ C)`
#. ยง1: `(A โฉ B) โฉ C = A โฉ (B โฉ C)`
#. ยง2: `ext x`
#: Game.Levels.Inter.L08inter_assoc
msgid "Notice that Lean has written the goal as ยง0, with no parentheses on the left.  When an intersection of more than two sets is written without parentheses, Lean groups the intersections to the left, so this means ยง1.\n"
"\n"
"To start this proof, use the tactic ยง2."
msgstr ""

#: Game.Levels.Subset
msgid "Subset World"
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "Subset is reflexive"
msgstr ""

#. ยง0: `P x`
#. ยง1: `x`
#. ยง2: `โ x, P x`
#. ยง3: `x`
#. ยง4: `P x`
#. ยง5: `โ`
#. ยง6: `\\exists`
#. ยง7: `โ x, P x`
#. ยง8: `x`
#. ยง9: `P x`
#. ยง10: `x`
#. ยง11: `Exists.intro`
#. ยง12: `h : P a`
#. ยง13: `a`
#. ยง14: `Exists.intro a h`
#. ยง15: `โ x, P x`
#. ยง16: `a`
#: Game.Levels.FamUnion.L01proveexists
msgid "To work with unions of families, we'll need to know how to work with existential statements. If ยง0 is a statement about an unspecified object ยง1, then ยง2 means \"there is at least one ยง3 such that ยง4 is true\".  The symbol ยง5 is called the *existential quantifier*, and you can enter it in Lean by typing ยง6.\n"
"\n"
"The easiest way to prove the statement ยง7 is to specify a value of ยง8, and give a proof of ยง9 for that value of ยง10.  The theorem that allows you to do that is called ยง11.  If you have ยง12, for some object ยง13, then ยง14 is a proof of the statement ยง15.  (The object ยง16 is sometimes called a *witness* for the existential statement.)  In this level, you'll try out this theorem."
msgstr ""

#. ยง0: `mem_sInter`
#. ยง1: `x โ โโ F โ โ t โ F, x โ t`
#. ยง2: `Set.mem_sInter`
#: Game.Levels.FamInter.L01intersub
#: Game.Levels.FamUnion.L02subunion
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Lean will recognize ยง0 as a proof of any statement of the form ยง1.  In Mathlib, the name of this theorem is ยง2."
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "Subset is transitive"
msgstr ""

#. ยง0: `a`
#. ยง1: `{a}`
#. ยง2: `a`
#. ยง3: `a`
#. ยง4: `b`
#. ยง5: `{a, b}`
#. ยง6: `a`
#. ยง7: `b`
#. ยง8: `U`
#. ยง9: `Set U`
#. ยง10: `P x`
#. ยง11: `x`
#. ยง12: `{x | P x}`
#. ยง13: `x`
#. ยง14: `P x`
#: Game.Levels.FamInter.L03interpair
msgid "If ยง0 denotes some object, then ยง1 denotes the set whose only element is ยง2; such a set is called a *singleton* set.  Similarly, if ยง3 and ยง4 denote objects, then ยง5 denotes the set whose elements are ยง6 and ยง7, and nothing else.  (Similar notation can be used to denote a set containing any finite list of objects.  All of the objects in the list must have the same type; if the objects have type ยง8, then the set has type ยง9.)\n"
"\n"
"There is another way to define sets.  If ยง10 is a statement about an unspecified object ยง11, then ยง12 denotes the set of all values of ยง13 that make ยง14 come out true.  This is often called *set-builder notation*."
msgstr ""

#. ยง0: `ยซ{h4}ยป : x โ B`
#: Game.Levels.Subset.L03have
msgid "Notice that ยง0 has been added to the list of assumptions. Can you complete the proof now?"
msgstr ""

#: Game
msgid "# Welcome to the Set Theory Game #### An introduction to mathematical proof.\n"
"\n"
"In this game, you will solve a sequence of levels by proving theorems.  The game is based on an interactive theorem prover called *Lean*.\n"
"\n"
"The theorems in this game will be about sets. A *set* is a collection of objects; the objects in the collection are called *elements* of the set.  For example, the set of planets in our solar system has eight elements: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and Neptune.\n"
"\n"
"# Read this.\n"
"\n"
"Learning how to use an interactive theorem prover takes time. You will get the most out of this game if you read the help texts like this one.\n"
"\n"
"To start, click on \"Subset World\".\n"
"\n"
"## More\n"
"\n"
"Open \"Game Info\" in the \"โก\" menu on the top right for resources, links, and ways to interact with the Lean community."
msgstr ""

#. ยง0: `A`
#. ยง1: `compl_compl A`
#. ยง2: `Aแถแถ = A`
#: Game.Levels.Comp.L04compcomp
msgid "If ยง0 is a set, then ยง1 is a proof of ยง2."
msgstr ""

#: Game.Levels.Union.L05union_comm
msgid "Next we'll prove the associative law for unions."
msgstr ""

#. ยง0: `P x`
#. ยง1: `x`
#. ยง2: `โ x, P x`
#. ยง3: `x`
#. ยง4: `P x`
#. ยง5: `โ`
#. ยง6: `\\forall`
#. ยง7: `โ x, P x`
#. ยง8: `intro t`
#. ยง9: `t`
#. ยง10: `P t`
#. ยง11: `t`
#. ยง12: `h : โ x, P x`
#. ยง13: `a`
#. ยง14: `h a`
#. ยง15: `P a`
#. ยง16: `a`
#. ยง17: `x`
#. ยง18: `U`
#. ยง19: `a`
#. ยง20: `U`
#. ยง21: `x`
#. ยง22: `U`
#. ยง23: `a`
#. ยง24: `Set U`
#: Game.Levels.FamInter.L01intersub
msgid "If ยง0 represents a statement about an unspecified object ยง1, then ยง2 means \"for all ยง3, ยง4 is true\".  To enter the symbol ยง5, type ยง6.\n"
"\n"
"### If your goal is ยง7\n"
"\n"
"The tactic ยง8 will introduce a new object ยง9 into the proof, and set the goal to be ยง10. Be sure to use a variable ยง11 that is not already being used to stand for some object.\n"
"\n"
"### If you have an assumption ยง12\n"
"\n"
"If ยง13 stands for some object, then ยง14 is a proof of ยง15.  Note that ยง16 must be the right *type* of object.  For example, if ยง17 stands for an object in the universe ยง18, then ยง19 must have type ยง20; if ยง21 stands for a set of objects from the universe ยง22, then ยง23 must have type ยง24."
msgstr ""

#. ยง0: `x`
#. ยง1: `intro x`
#. ยง2: `intro`
#. ยง3: `intro`
#: Game.Levels.Subset.L05subref
msgid "Our first step is to introduce an object ยง0 into the proof.  To do this, type ยง1. We have already seen that the ยง2 tactic can be used to introduce a new *assumption* into a proof.  This step illustrates a second use of ยง3: introducing a new *object* into a proof."
msgstr ""

#. ยง0: `apply`
#. ยง1: `t`
#. ยง2: `t ?`
#. ยง3: `P`
#. ยง4: `t`
#. ยง5: `apply t`
#. ยง6: `P`
#. ยง7: `t`
#. ยง8: `apply t`
#: Game.Levels.Comp.L04compcomp
msgid "You can use the ยง0 tactic to work backwards from the goal.  Suppose you think that you will be able to use some theorem ยง1 to prove the goal.  In other words, you think there is a proof of the goal of the form ยง2, where the question mark needs to be replaced with a proof of some statement ยง3 to which the theorem ยง4 must be applied.  The tactic ยง5 will then set ยง6 as your goal.  If ยง7 must be applied to more than one proof to establish the goal, then ยง8 will set all of the needed proofs as goals."
msgstr ""

#. ยง0: `ยซ{x}ยป โ ยซ{t}ยป`
#. ยง1: `ยซ{t}ยป = A โฉ ยซ{u}ยป`
#. ยง2: `rewrite`
#. ยง3: `ยซ{x}ยป โ A โฉ ยซ{u}ยป`
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "You know ยง0 and ยง1.  So you can use ยง2 to get ยง3."
msgstr ""

#. ยง0: `have`
#. ยง1: `ยซ{x}ยป โ B`
#. ยง2: `ยซ{x}ยป โ C`
#: Game.Levels.Subset.L06subtrans
msgid "First use ยง0 to assert that ยง1, and then prove ยง2."
msgstr ""

#. ยง0: `h`
#. ยง1: `x โ A`
#. ยง2: `x โ A`
#. ยง3: `h : P`
#. ยง4: `P`
#. ยง5: `h`
#. ยง6: `P`
#. ยง7: `exact`
#. ยง8: `exact`
#. ยง9: `exact`
#. ยง10: `h`
#. ยง11: `x โ A`
#. ยง12: `h`
#. ยง13: `exact`
#: Game.Levels.Subset.L01exact
msgid "Congratulations! You have completed your first verified proof!\n"
"\n"
"Although this theorem was trivial, it illustrates an important fact: although we called ยง0 an *identifier* for the assumption ยง1, it is also recognized by Lean as a *proof* of the statement ยง2.  Any time you see ยง3 listed as an assumption, where ยง4 is some statement, that means that Lean will recognize ยง5 as a proof of the statement ยง6.\n"
"\n"
"Remember that ยง7 is a *tactic*. If you ever want information about the ยง8 tactic, you can click on ยง9 in the list of tactics on the right.\n"
"\n"
"Note that, although ยง10 was a proof of the goal ยง11, you could not have closed the goal by simply typing ยง12 in the text box.  Throughout this game, every move you make must invoke a tactic.\n"
"\n"
"Now click on \"Next\" to see a more interesting use of the ยง13 tactic."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `Iff.intro`
#. ยง2: `h1 : P โ Q`
#. ยง3: `h2 : Q โ P`
#. ยง4: `Iff.intro h1 h2`
#. ยง5: `P โ Q`
#. ยง6: `apply Iff.intro`
#. ยง7: `P โ Q`
#. ยง8: `Q โ P`
#: Game.Levels.Comp.L05compsubiff
msgid "In this last level of Complement World, you'll prove a statement of the form ยง0.  The most useful theorem for this purpose is ยง1.  If you have ยง2 and ยง3, then ยง4 is a proof of ยง5.  As we saw in the last level, that means you can start your proof with ยง6.  Lean will set ยง7 and ยง8 as the goals that are needed to complete the proof."
msgstr ""

#. ยง0: $F$
#. ยง1: $G$
#. ยง2: $s \\in F$
#. ยง3: $t \\in G$
#. ยง4: $s \\subseteq t$
#. ยง5: $s \\in F$
#. ยง6: $t \\in G$
#. ยง7: $t \\subseteq s$
#. ยง8: $F$
#. ยง9: $G$
#: Game.Levels.FamCombo.L03commonelt
msgid "Suppose ยง0 and ยง1 are families of sets such that for every ยง2 there is some ยง3 such that ยง4, and also there is some ยง5 such that for every ยง6, ยง7.  Then ยง8 and ยง9 have an element in common."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "Intersection of larger family is smaller"
msgstr ""

#. ยง0: `rewrite`
#. ยง1: `ยซ{x}ยป โ โโ F`
#. ยง2: `mem_sInter`
#: Game.Levels.FamInter.L01intersub
msgid "As usual, you may find it helpful to use the ยง0 tactic to write out the definition of ยง1, using the theorem ยง2."
msgstr ""

#. ยง0: `t`
#. ยง1: `apply t`
#. ยง2: `t`
#. ยง3: `P โง Q`
#. ยง4: `constructor`
#. ยง5: `apply And.intro`
#. ยง6: `P`
#. ยง7: `Q`
#: Game.Levels.Inter.L05subint
msgid "In general, if you think that some theorem ยง0 could be used to prove the goal, the tactic ยง1 will work backwards from the goal, setting as new goals any hypotheses that are needed for the application of the theorem ยง2.\n"
"\n"
"If your goal has the form ยง3, then the ยง4 tactic will have the same effect as ยง5; that is, it will set ยง6 and ยง7 as goals to be proven."
msgstr ""

#. ยง0: `have`
#. ยง1: `t`
#. ยง2: `P`
#. ยง3: `h`
#. ยง4: `have h : P := t`
#. ยง5: `h : P`
#. ยง6: `have`
#. ยง7: `P`
#. ยง8: `P`
#. ยง9: `have h : P`
#. ยง10: `P`
#. ยง11: `P`
#. ยง12: `P`
#. ยง13: `h : P`
#. ยง14: `have h := t`
#. ยง15: `P`
#. ยง16: `t`
#: Game.Levels.Subset.L03have
msgid "Use ยง0 to assert a statement that you can prove from your current assumptions.  You must give the new assertion an identifier; be sure to use an identifier that is different from those already in use.\n"
"\n"
"If some expression ยง1 is a proof of a statement ยง2, and ยง3 is an identifier that is not in use, then ยง4 will add ยง5 to the list of assumptions.\n"
"\n"
"There are two variations on the ยง6 tactic: * Sometimes you want to assert a statement ยง7, but the proof of ยง8 is too difficult to be given in one line.  In that situation, you can simply write ยง9.  Of course, you must still justify the assertion of ยง10, so the proof of ยง11 becomes your immediate goal. Once the goal of proving ยง12 has been closed, you will be able to return to your original goal, with ยง13 added to the assumption list. * If you write ยง14, then Lean will try to figure out what statement ยง15 is proven by the expression ยง16 and, if it can figure it out, it will fill it in for you."
msgstr ""

#. ยง0: `compl_compl`
#. ยง1: `Aแถแถ = A`
#. ยง2: `Bแถแถ = B`
#. ยง3: `ยซ{h2}ยป`
#. ยง4: `rewrite`
#. ยง5: `P โ Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `t`
#. ยง9: `p = q`
#. ยง10: `rewrite [t]`
#. ยง11: `p`
#. ยง12: `q`
#: Game.Levels.Comp.L05compsubiff
msgid "Fortunately, we can use the theorem ยง0 to prove ยง1 and ยง2, and those statements should get us from ยง3 to the goal. We have seen in previous levels that the ยง4 tactic can be applied to a proof of a statement of the form ยง5 to replace ยง6 with ยง7.  The tactic can also be applied to equations: if ยง8 is a proof of an equation ยง9, then ยง10 will replace ยง11 with ยง12."
msgstr ""

#. ยง0: `have h4 : x โ B := h1 h3`
#. ยง1: `โ`
#. ยง2: `\\mem`
#. ยง3: `\\in`
#: Game.Levels.Subset.L03have
msgid "To get started on this proof, type ยง0 in the text box and click \"Execute\" or hit \"Return\" or \"Enter\". Recall that you can enter the symbol ยง1 by typing ยง2 or ยง3."
msgstr ""

#. ยง0: `have h2 := h1 {s | ...}`
#. ยง1: `...`
#: Game.Levels.FamCombo.L08singleton
msgid "Start with ยง0.  The hard part is figuring out how to fill in the ยง1."
msgstr ""

#. ยง0: `rewrite [compl_inter]`
#. ยง1: `rewrite [compl_inter]`
#. ยง2: `compl_inter`
#. ยง3: `compl_inter B C`
#. ยง4: `(B โฉ C)แถ = Bแถ โช Cแถ`
#. ยง5: `compl_inter Aแถ (B โฉ C)แถ`
#. ยง6: `(Aแถ โฉ (B โฉ C)แถ)แถ = Aแถแถ โช (B โฉ C)แถแถ`
#. ยง7: `rewrite [compl_inter]`
#. ยง8: `compl_inter`
#: Game.Levels.Combo.L04union_distrib_inter
msgid "You might be tempted to use ยง0 as your next step.  But in this situation, ยง1 is ambiguous, because there are two ways that the theorem ยง2 could be applied to rewrite the goal: ยง3 is a proof of ยง4 and ยง5 is a proof of ยง6, and either one of those equations could be used to rewrite the goal.  If you say ยง7, then Lean will pick one of those two rewriting steps, and it might not pick the one you wanted.  So you'd better say explicitly what you want Lean to apply the theorem ยง8 to."
msgstr ""

#: Game.Levels.Inter.L01and
msgid "Now we're ready to start proving theorems about intersections."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "Notice that ยซ{h}ยป is now a proof of the goal."
msgstr ""

#: Game.Levels.Subset.L03have
msgid "The have tactic"
msgstr ""

#: Game.Levels.Inter.L01and
msgid "And"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โง Q`
#. ยง3: `โง`
#. ยง4: `\\and`
#. ยง5: `P โง Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `h : P โง Q`
#. ยง9: `h`
#. ยง10: `P โง Q`
#. ยง11: `h.left`
#. ยง12: `P`
#. ยง13: `h.right`
#. ยง14: `Q`
#: Game.Levels.Inter.L01and
msgid "To work with intersections, we'll need to understand the word \"and\".\n"
"\n"
"If ยง0 and ยง1 are statements, then ยง2 means \"P and Q\".  To enter the symbol ยง3, type ยง4.  For the statement ยง5 to be true, ยง6 and ยง7 must both be true.  If you have ยง8--that is, ยง9 is a proof of the statement ยง10--then in Lean, ยง11 is a proof of ยง12 and ยง13 is a proof of ยง14.  That should be all you need to know to solve this level."
msgstr ""

#. ยง0: `P x`
#. ยง1: `x`
#. ยง2: `{x | P x}`
#. ยง3: `x`
#. ยง4: `P x`
#. ยง5: `{x | x โ A โง x โ B}`
#. ยง6: `A โฉ B`
#. ยง7: `mem_setOf`
#. ยง8: `a โ {x | P x} โ P a`
#. ยง9: `rewrite [mem_setOf]`
#. ยง10: `a โ {x | P x}`
#. ยง11: `P a`
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "In this level, we introduce another way to define sets.  If ยง0 is a statement about an unspecified object ยง1, then ยง2 denotes the set of all values of ยง3 that make ยง4 come out true.  This is often called *set-builder notation*.  For example, ยง5 is another way to write ยง6.\n"
"\n"
"As usual, we have a theorem that states the meaning of set-builder notation.  Lean will recognize ยง7 as a proof of any statement of the form ยง8. And that means that ยง9 will rewrite ยง10 as ยง11."
msgstr ""

#: Game.Levels.FamUnion
msgid "Family Union World"
msgstr ""

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "A tricky subset proof"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `A โช B`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `A โช B`
#. ยง8: `A`
#. ยง9: `B`
#. ยง10: `A`
#. ยง11: `B`
#. ยง12: `A โช B`
#: Game.Levels.Union
msgid "If ยง0 and ยง1 are sets, then the *union* of ยง2 and ยง3, denoted ยง4, is the set you get by throwing all the elements of ยง5 and ยง6 together into one set.  In other words, for an object to be an element of ยง7, it must be an element of either ยง8 or ยง9, or both.\n"
"\n"
"For example, if ยง10 is the set of all people under 30, and ยง11 is the set of all people over 20, then ยง12 is the set of all people.\n"
"\n"
"In this world you'll prove some basic properties of unions of sets."
msgstr ""

#. ยง0: `intro`
#. ยง1: `ยซ{t}ยป โ F`
#: Game.Levels.FamInter.L02intersubinter
msgid "Now your goal is an if-then statement; that means ยง0 is appropriate again, to introduce ยง1 as a new assumption."
msgstr ""

#: Game.Levels.FamUnion.L05unionunion
msgid "Union of a union"
msgstr ""

#: Game.Levels.Combo.L04union_distrib_inter
msgid "Union distributes over intersection"
msgstr ""

#: Game.Levels.Inter.L03inter_sub_left
msgid "Intersection is a subset"
msgstr ""

#. ยง0: `rewrite`
#. ยง1: `rewrite`
#: Game.Levels.Inter.L06inter_sub_swap
msgid "It will help you see how to proceed if you write out the definition of intersection in both the assumption ยซ{h}ยป and the goal. Using the ยง0 tactic isn't necessary; you can just do the rewriting in your head rather than asking Lean to do it.  But if it helps you to figure out the proof, go ahead and use the ยง1 tactic."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "The situation now should remind you of your first proof, in level 1 of this world."
msgstr ""

#. ยง0: $F$
#. ยง1: $\\bigcup F$
#. ยง2: `F`
#. ยง3: `โโ F`
#. ยง4: `โโ`
#. ยง5: `\\U0`
#. ยง6: `F : Set (Set U)`
#. ยง7: `x : U`
#. ยง8: `x โ โโ F`
#. ยง9: `t`
#. ยง10: `t โ F`
#. ยง11: `x โ t`
#. ยง12: `โ t, t โ F โง x โ t`
#. ยง13: `โ t โ F, x โ t`
#. ยง14: `mem_sUnion`
#. ยง15: `x โ โโ F โ โ t โ F, x โ t`
#: Game.Levels.FamUnion.L02subunion
msgid "In mathematical writing, the union of the family ยง0 is usually denoted ยง1. In Lean, the union of a family ยง2 is denoted ยง3.  (You can enter the symbol ยง4 by typing ยง5.)\n"
"\n"
"Suppose we have ยง6 and ยง7.  Then ยง8 means that there is at least one set ยง9 such that ยง10 and ยง11.  To write this statement in Lean, we write ยง12.  Lean abbreviates this statement as ยง13.\n"
"\n"
"As with other set theory operations, we have a theorem that expresses this definition.  Lean will recognize ยง14 as a proof of any statement of the form ยง15.\n"
"\n"
"In this level, you'll try out these ideas."
msgstr ""

#: Game.Levels.Inter.L03inter_sub_left
msgid "You should be able to combine ideas from previous levels to solve this one."
msgstr ""

#. ยง0: `A โช B โช C`
#. ยง1: `(A โช B) โช C`
#: Game.Levels.Union.L06union_assoc
msgid "Notice that, as with intersections, Lean groups unions to the left, so ยง0 means ยง1."
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `โจ`
#. ยง2: `\\or`
#. ยง3: `P โจ Q`
#. ยง4: `hP : P`
#. ยง5: `Or.inl hP`
#. ยง6: `P โจ Q`
#. ยง7: `exact Or.inl hP`
#. ยง8: `hQ : Q`
#. ยง9: `Or.inr hQ`
#. ยง10: `P โจ Q`
#. ยง11: `P`
#. ยง12: `Q`
#. ยง13: `apply Or.inl`
#. ยง14: `P`
#. ยง15: `apply Or.inr`
#. ยง16: `Q`
#. ยง17: `left`
#. ยง18: `apply Or.inl`
#. ยง19: `right`
#. ยง20: `apply Or.inr`
#. ยง21: `h : P โจ Q`
#. ยง22: `rcases h with hP | hQ`
#. ยง23: `h`
#. ยง24: `hP : P `
#. ยง25: `hQ : Q`
#: Game.Levels.Union.L01or
msgid "ยง0 means \"P or Q or both\".  To enter the symbol ยง1, type ยง2.\n"
"\n"
"### If your goal is ยง3\n"
"\n"
"If you have ยง4, then ยง5 is a proof of ยง6, so ยง7 will close the goal.  Similarly, if you have ยง8, then ยง9 is a proof of ยง10.  If you don't have a proof of either ยง11 or ยง12, but you think you know which one is true, then you can use ยง13 to set the goal to be ยง14, or ยง15 to set the goal to be ยง16.  Alternatively, the tactic ยง17 will have the same effect as ยง18, and ยง19 will have the same effect as ยง20.\n"
"\n"
"### If you have an assumption ยง21\n"
"\n"
"A good strategy would be to use proof by cases.  The tactic ยง22 will break the proof into two cases.  In case 1, the assumption ยง23 is replaced by ยง24, and in case 2 it is replaced by ยง25.  In both cases, you must prove the goal."
msgstr ""

#. ยง0: `ยฌP`
#. ยง1: `P`
#. ยง2: `by_contra h`
#. ยง3: `h : P`
#. ยง4: `False`
#. ยง5: `P`
#. ยง6: `by_contra h`
#. ยง7: `h : ยฌP`
#. ยง8: `h1 : Q`
#. ยง9: `h2 : ยฌQ`
#. ยง10: `Q`
#. ยง11: `h2 h1`
#. ยง12: `False`
#. ยง13: `h1 h2`
#. ยง14: `False`
#: Game.Levels.Comp.L01contra
msgid "If your goal is ยง0, for some statement ยง1, then the tactic ยง2 will introduce the new assumption ยง3, and set the goal to be ยง4.  If your goal is a statement ยง5 that is not a negative statement, then ยง6 will introduce the new assumption ยง7.\n"
"\n"
"To achieve your new goal, you will need to establish ยง8 and ยง9, for some statement ยง10.  If you can do that, then ยง11 will prove the goal ยง12.  Notice that ยง13 will not be recognized as a proof of ยง14; the negative statement must come first."
msgstr ""

#. ยง0: `h`
#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "To start on this proof, try writing out the meaning of intersection in ยง0."
msgstr ""

#. ยง0: `exact And.intro h1 h2`
#: Game.Levels.Inter.L04proveand
msgid "ยง0 will close the goal."
msgstr ""

#. ยง0: `A`
#. ยง1: `F`
#. ยง2: `A โ โโ F`
#: Game.Levels.FamInter.L05subinter
msgid "If ยง0 is a set and ยง1 is a family of sets, under what circumstances is it the case that ยง2?  In this level you'll discover the answer to that question."
msgstr ""

#. ยง0: `A`
#. ยง1: `Subset.refl`
#: Game.Levels.FamUnion.L01proveexists
msgid "Your goal says that there is a set that is a subset of ยง0. The theorem ยง1 suggests such a set."
msgstr ""

#. ยง0: `h1`
#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "Use ยง0."
msgstr ""

#. ยง0: $A$
#. ยง1: $B$
#. ยง2: $A \\subseteq B$
#. ยง3: $B^c \\subseteq A^c$
#: Game.Levels.Comp.L05compsubiff
msgid "Suppose ยง0 and ยง1 are sets.  Then ยง2 if and only if ยง3."
msgstr ""

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "This proof is a bit tricky.  But you should know how to get started."
msgstr ""

#. ยง0: `apply Or.inl`
#. ยง1: `apply Or.inr`
#. ยง2: `left`
#. ยง3: `right`
#: Game.Levels.FamInter.L06eltwiseunion
msgid "For the second case, which half of the goal do you think you should try to prove? You can use ยง0 or ยง1 (or the equivalent tactics ยง2 or ยง3) to specify what goal you're going to prove."
msgstr ""

#. ยง0: `rcases`
#: Game.Levels.Union.L03cases
msgid "In this proof, we'll need a new proof technique: proof by cases.  And we'll need a new tactic to implement that technique in Lean: ยง0."
msgstr ""

#. ยง0: `ยซ{h2}ยป`
#. ยง1: `ยซ{h4}ยป`
#: Game.Levels.FamInter.L02intersubinter
msgid "You can now combine ยง0 and ยง1 to reach the goal in one step."
msgstr ""

#. ยง0: `h2 ยซ{h4}ยป`
#. ยง1: `exact h2 ยซ{h4}ยป`
#: Game.Levels.Subset.L03have
msgid "As we saw in the last level, ยง0 is now a proof of the goal, so ยง1 will close the goal."
msgstr ""

#. ยง0: $A$
#. ยง1: $F$
#. ยง2: $\\bigcup F = A$
#. ยง3: $A \\in F$
#. ยง4: $A$
#: Game.Levels.FamCombo.L08singleton
msgid "Suppose ยง0 is a set, and for every family of sets ยง1, if ยง2 then ยง3. Then ยง4 must be a singleton set."
msgstr ""

#: Game.Levels.FamCombo.L07unionintcompint
msgid "A union intersected with the complement of an intersection"
msgstr ""

#. ยง0: `Aแถแถ = A`
#. ยง1: `Aแถ`
#. ยง2: `A`
#. ยง3: `apply Subset.antisymm`
#: Game.Levels.Comp.L04compcomp
msgid "In this level, your goal is ยง0--that is, the complement of ยง1 is equal to ยง2. So ยง3 is a good way to start."
msgstr ""

#. ยง0: $A$
#. ยง1: $A \\subseteq A$
#: Game.Levels.Subset.L05subref
msgid "Let ยง0 be any set.  Then ยง1."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Your goal is a subset statement. That should tell you how to get started."
msgstr ""

#. ยง0: `h : P`
#. ยง1: `Or.inl h`
#. ยง2: `P โจ Q`
#. ยง3: `Q`
#: Game.Levels.Union.L01or
#: Game.Levels.Union.L01or
msgid "If you have ยง0, then ยง1 can be used as a proof of ยง2, for any statement ยง3."
msgstr ""

#: Game.Levels.FamInter
msgid "Family Intersection World"
msgstr ""

#. ยง0: `ยซ{s}ยป`
#. ยง1: `ยซ{t}ยป`
#: Game.Levels.FamCombo.L03commonelt
msgid "Look at what you know about ยง0 and ยง1."
msgstr ""

#. ยง0: `apply Subset.antisymm`
#. ยง1: `union_subset_swap`
#: Game.Levels.Union.L05union_comm
msgid "If you start your proof with ยง0, then you'll be able to use the theorem ยง1 that you proved in the last level."
msgstr ""

#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Your goal is an existential statement.  Do you see what value to use as a witness?"
msgstr ""

#: Game.Levels.FamInter.L06eltwiseunion
msgid "The first case is the easy one."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "Definition of complement"
msgstr ""

#. ยง0: `intro`
#. ยง1: `ยซ{x}ยป โ A`
#: Game.Levels.Subset.L05subref
msgid "Use ยง0 again to introduce the assumption ยง1."
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "Subset of family union"
msgstr ""

#: Game.Levels.Union.L04union_sub_swap
msgid "Union subset of swap"
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "Complement subsets equivalence"
msgstr ""

#: Game.Levels.Inter.L06inter_sub_swap
msgid "Intersection subset of swap"
msgstr ""

#. ยง0: `A = B`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `ext x`
#. ยง4: `x`
#. ยง5: `x โ A โ x โ B`
#: Game.Levels.Inter.L08inter_assoc
msgid "If your goal is ยง0, where ยง1 and ยง2 are sets, then the tactic ยง3 will introduce a new arbitrary object ยง4 into the proof and set the goal to be ยง5."
msgstr ""

#: Game
msgid "Set Theory Game"
msgstr ""

#. ยง0: `A`
#. ยง1: `U`
#. ยง2: `A`
#. ยง3: `Aแถ`
#. ยง4: `U`
#. ยง5: `A`
#. ยง6: `U`
#. ยง7: `A`
#. ยง8: `Aแถ`
#: Game.Levels.Comp
msgid "If ยง0 is a set of objects from the universe ยง1, then the *complement* of ยง2, denoted ยง3, is the set of all objects in the universe ยง4 that are *not* elements of ยง5.\n"
"\n"
"For example, if ยง6 consists of all people and ยง7 is the set of people who are more than 6 feet tall, then ยง8 is the set of all people who are at most 6 feet tall.\n"
"\n"
"In this world, we'll see how to prove theorems about complements."
msgstr ""

#. ยง0: `ยซ{h2}ยป`
#. ยง1: `obtain โจs, hsโฉ := ยซ{h2}ยป`
#. ยง2: `s`
#. ยง3: `hs : s โ F โง ยซ{x}ยป โ s`
#. ยง4: `s`
#. ยง5: `ยซ{h2}ยป`
#: Game.Levels.FamUnion.L03unionsubunion
msgid "The assumption ยง0 is now an existential statement.  Thus, ยง1 will introduce a new object ยง2 and a new assumption ยง3 into the proof. Once the witness ยง4 has been introduced, the assumption ยง5 becomes redundant, so it is deleted."
msgstr ""

#. ยง0: $A$
#. ยง1: $B$
#. ยง2: $A \\subseteq B$
#. ยง3: $x \\in A$
#. ยง4: $x \\in B$
#: Game.Levels.Subset.L02subhyp
msgid "Suppose ยง0 and ยง1 are sets, ยง2, and ยง3. Then ยง4."
msgstr ""

#: Game.Levels.FamUnion.L03unionsubunion
msgid "Union of larger family is larger"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `A โฉ B`
#. ยง5: `A โฉ B`
#. ยง6: `A`
#. ยง7: `B`
#. ยง8: `A`
#. ยง9: `B`
#. ยง10: `A โฉ B`
#: Game.Levels.Inter
msgid "If ยง0 and ยง1 are sets, then the *intersection* of ยง2 and ยง3, denoted ยง4, is the set of elements that the two sets have in common.  In other words, for an object to be an element of ยง5, it must be an element of both ยง6 and ยง7.\n"
"\n"
"For example, if ยง8 is the set of all round things, and ยง9 is the set of all red things, then ยง10 is the set of all round red things.\n"
"\n"
"In this world you'll prove some basic properties of intersections of sets."
msgstr ""

#. ยง0: $A$
#. ยง1: $F$
#. ยง2: $G$
#. ยง3: $s$
#. ยง4: $F$
#. ยง5: $A \\cup s \\in G$
#. ยง6: $\\bigcap G \\subseteq A \\cup (\\bigcap F)$
#: Game.Levels.FamInter.L06eltwiseunion
msgid "Suppose ยง0 is a set, ยง1 and ยง2 are families of sets, and for every set ยง3 in ยง4, ยง5.  Then ยง6."
msgstr ""

#. ยง0: `ยซ{h2}ยป : ยซ{x}ยป โ B`
#: Game.Levels.Comp.L03compsub
msgid "This should remind you of the first level of this world.  To get a contradiction, try to contradict ยง0."
msgstr ""

#. ยง0: $x$
#. ยง1: $U$
#. ยง2: $A$
#. ยง3: $U$
#. ยง4: $x โ A$
#. ยง5: $x \\in A$
#: Game.Levels.Subset.L01exact
msgid "Let ยง0 be an object in the universe ยง1, and let ยง2 be a set whose elements come from ยง3.  Suppose that ยง4.  Then ยง5."
msgstr ""

#. ยง0: `h1`
#. ยง1: `ยซ{h3}ยป`
#. ยง2: `h2`
#. ยง3: `ยซ{h4}ยป`
#: Game.Levels.Subset.L04imp
msgid "Just as you were able to apply ยง0 to ยง1 in the last step, you can now apply ยง2 to ยง3 to prove the goal."
msgstr ""

#. ยง0: `apply Subset.antisymm`
#. ยง1: `A โฉ B โ B โฉ A`
#. ยง2: `B โฉ A โ A โฉ B`
#. ยง3: `inter_subset_swap`
#: Game.Levels.Inter.L07inter_comm
msgid "As we saw in Complement World, a good first step when your goal is an equation between sets is ยง0.  For the theorem in this level, that will leave you with two goals: ยง1 and ยง2.  Fortunately, you can prove *both* of these goals by using the theorem ยง3 from the last level."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `And.intro`
#. ยง2: `h1 : P`
#. ยง3: `h2 : Q`
#. ยง4: `And.intro h1 h2`
#. ยง5: `P โง Q`
#: Game.Levels.Inter.L04proveand
msgid "In this level we'll prove a statement of the form ยง0.  To do this, we'll need another theorem: ยง1.  If you have ยง2 and ยง3, then ยง4 is a proof of ยง5."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.Union.L04union_sub_swap
msgid "It will help you see how to proceed if you write out the definition of union in both the assumption ยง0 and the goal."
msgstr ""

#. ยง0: `mem_inter_iff`
#. ยง1: `x : U`
#. ยง2: `A : Set U`
#. ยง3: `B : Set U`
#. ยง4: `mem_inter_iff x A B`
#. ยง5: `x โ A โฉ B โ x โ A โง x โ B`
#. ยง6: `rewrite [mem_inter_iff x A B]`
#. ยง7: `x โ A โฉ B`
#. ยง8: `x โ A โง x โ B`
#. ยง9: `x`
#. ยง10: `A`
#. ยง11: `B`
#. ยง12: `rewrite [mem_inter_iff]`
#. ยง13: `rewrite [mem_inter_iff] at h`
#. ยง14: `h`
#. ยง15: `mem_compl_iff`
#. ยง16: `mem_inter_iff`
#. ยง17: `rfl`
#. ยง18: `โฉ`
#. ยง19: `\\inter`
#. ยง20: `\\cap`
#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "In this level, we'll need to use the definition of \"intersection\".  The theorem that expresses that definition is called ยง0.  If you have ยง1, ยง2, and ยง3, then ยง4 is a proof of the statement ยง5. As we saw in Complement World, that means that the tactic ยง6 can be used to replace ยง7 in the goal with ยง8.  Usually Lean can figure out ยง9, ยง10, and ยง11 on its own, so you can just write ยง12, and you can use ยง13 to do the replacement in an assumption ยง14 rather than the goal.\n"
"\n"
"Like ยง15, ยง16 can be proven by using the ยง17 tactic.  But we won't ask you to prove it; it is pre-defined in this game.  To enter the symbol ยง18, you can type ยง19 or ยง20."
msgstr ""

#: Game.Levels.FamCombo.L02compinter
msgid "Perhaps you have already guessed that there is a theorem about the complement of an intersection of a family that is similar to the theorem in the last level."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "You've mastered reasoning about complements, intersections, and unions.  In the next world, we'll start mixing them up!"
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "Complement subsets from subsets"
msgstr ""

#. ยง0: `ยซ{h3}ยป : x โ A`
#. ยง1: `x โ C`
#: Game.Levels.Subset.L04imp
msgid "Notice that ยง0 is now listed under *Assumptions*, and your new goal is ยง1."
msgstr ""

#. ยง0: $A$
#. ยง1: $B$
#. ยง2: $A \\cap B \\subseteq A$
#: Game.Levels.Inter.L03inter_sub_left
#: Game.Levels.Inter.L06inter_sub_swap
#: Game.Levels.Inter.L07inter_comm
#: Game.Levels.Union.L04union_sub_swap
#: Game.Levels.Union.L05union_comm
#: Game.Levels.Combo.L01compunion
#: Game.Levels.Combo.L02compint
msgid "For any sets ยง0 and ยง1, ยง2."
msgstr ""

#. ยง0: $A$
#. ยง1: $F$
#. ยง2: $\\bigcup F$
#. ยง3: $A$
#. ยง4: $F$
#. ยง5: $A$
#: Game.Levels.FamUnion.L06unionsub
msgid "Suppose ยง0 is a set and ยง1 is a family of sets.  Then ยง2 is a subset of ยง3 if and only if every element of ยง4 is a subset of ยง5."
msgstr ""

#. ยง0: $A$
#. ยง1: $B$
#. ยง2: $C$
#. ยง3: $(A \\cap B) \\cap C = A \\cap (B \\cap C)$
#: Game.Levels.Inter.L08inter_assoc
#: Game.Levels.Union.L06union_assoc
#: Game.Levels.Combo.L03inter_distrib_union
#: Game.Levels.Combo.L04union_distrib_inter
msgid "For any sets ยง0, ยง1, and ยง2, ยง3."
msgstr ""

#. ยง0: `h1 : A โ F`
#. ยง1: `ยซ{h2A}ยป`
#. ยง2: `h1`
#. ยง3: `ยซ{x}ยป โ A`
#. ยง4: `ยซ{h2A}ยป h1`
#: Game.Levels.FamInter.L01intersub
msgid "Since we also have ยง0, you can apply ยง1 to ยง2 to prove that ยง3. This means that ยง4 is a proof of the goal."
msgstr ""

#. ยง0: `ยซ{h2}ยป`
#. ยง1: `ยซ{t}ยป โ G`
#: Game.Levels.FamInter.L02intersubinter
msgid "It looks like ยง0 could get you to the goal, if only you knew that ยง1.  Can you prove that?"
msgstr ""

#. ยง0: `A โช B = B โช A`
#. ยง1: `A โช B โ B โช A`
#: Game.Levels.Union.L04union_sub_swap
msgid "In the next level we're going to prove that union is commutative; that is, ยง0.  We're going to imitate the approach we used in Intersection World to prove that intersection is commutative.  We begin by proving ยง1."
msgstr ""

#: Game.Levels.FamCombo.L06unionintunion
msgid "A subset of a union intersected with the complement of another"
msgstr ""

#: Game.Levels.FamUnion.L04unionpair
msgid "In this level, you'll show that, as with intersections, family unions generalize the unions we studied in Union World."
msgstr ""

#: Game.Levels.Comp
msgid "Complement World"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `inter_subset_swap A B`
#. ยง3: `A โฉ B โ B โฉ A`
#: Game.Levels.Inter.L06inter_sub_swap
#: Game.Levels.Union.L04union_sub_swap
msgid "For any sets ยง0 and ยง1, ยง2 is a proof of ยง3."
msgstr ""

#: Game.Levels.FamCombo.L04threefam
msgid "Here's a theorem about three related families of sets."
msgstr ""

#: Game.Levels.FamCombo.L01compunion
msgid "Complement of a family union"
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "Does your situation now remind you of a previous level?"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warningsโฆ ๐ญ"
msgstr ""

#. ยง0: `A`
#. ยง1: `F`
#. ยง2: `โโ F`
#. ยง3: `A`
#: Game.Levels.FamUnion.L06unionsub
msgid "Suppose ยง0 is a set and ยง1 is a family of sets.  In this level you'll determine the conditions under which ยง2 is a subset of ยง3."
msgstr ""

#. ยง0: `h : โ x, P x`
#. ยง1: `obtain โจw, hwโฉ := h`
#. ยง2: `w`
#. ยง3: `hw : P w`
#. ยง4: `โจ โฉ`
#. ยง5: `\\<`
#. ยง6: `\\>`
#. ยง7: `\\langle`
#. ยง8: `\\rangle`
#: Game.Levels.FamUnion.L03unionsubunion
msgid "If you have an assumption ยง0, then the tactic ยง1 will introduce a new object ยง2 and a new assumption ยง3 into the proof.  To enter the angle brackets ยง4, type either ยง5 and ยง6 or ยง7 and ยง8."
msgstr ""

#. ยง0: `rewrite`
#. ยง1: `rewrite [mem_compl_iff]`
#. ยง2: `mem_compl_iff`
#. ยง3: `mem_compl_iff`
#. ยง4: `A`
#. ยง5: `ยซ{x}ยป`
#. ยง6: `rewrite [mem_compl_iff] at ยซ{h2}ยป`
#. ยง7: `ยซ{h2}ยป`
#. ยง8: `mem_compl_iff`
#. ยง9: `B`
#. ยง10: `ยซ{x}ยป`
#: Game.Levels.Comp.L03compsub
msgid "The ยง0 tactic is smart enough to figure out some things on its own.  If you had just written ยง1, then Lean would have figured out how to apply the theorem ยง2 to get an equivalence that could be used to make a replacement in the goal. In other words, it would have figured out that the theorem ยง3 had to be applied to ยง4 and ยง5.\n"
"\n"
"Similarly, you can write ยง6 to write out the meaning of ยง7.  Lean will figure out that in this case, ยง8 has to be applied to ยง9 and ยง10."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Writing out the definition of union in the goal should help you see how to proceed."
msgstr ""

#. ยง0: `A โ B`
#. ยง1: `x`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `x`
#. ยง5: `x`
#. ยง6: `A`
#. ยง7: `A โ A`
#: Game.Levels.Subset.L05subref
msgid "How do you prove that one set is a subset of another?  To prove that ยง0, you have to show that if some object ยง1 is an element of ยง2, then it is also an element of ยง3.  To do that, you'll have to introduce an object called ยง4 into the proof.  The object denoted by ยง5 could be anything, so we say that it is *arbitrary*.\n"
"\n"
"In this level, we start with a simple example of this kind of proof.  We're going to show that if ยง6 is a set, then ยง7."
msgstr ""

#. ยง0: `Or.inl h`
#: Game.Levels.Union.L01or
msgid "ยง0 is a proof of the goal."
msgstr ""

#. ยง0: `apply Exists.intro A`
#. ยง1: `use A`
#. ยง2: `use`
#. ยง3: `A`
#. ยง4: `t`
#: Game.Levels.FamUnion.L02subunion
msgid "There is another tactic you could have used to complete this proof.  Instead of ยง0, you could write ยง1.  The ยง2 tactic is actually a powerful tactic.  Not only does it fill in ยง3 for ยง4 in the existential goal, it then tries to complete the proof on its own--and in this case, it would have succeeded!"
msgstr ""

#. ยง0: `t`
#. ยง1: `A`
#. ยง2: `B`
#. ยง3: `mem_pair t A B`
#. ยง4: `t โ {A, B} โ t = A โจ t = B`
#: Game.Levels.FamInter.L03interpair
msgid "For any ยง0, ยง1, and ยง2, ยง3 is a proof of the statement ยง4."
msgstr ""

#. ยง0: `x โ Aแถ`
#. ยง1: `x โ A`
#. ยง2: `rfl`
#: Game.Levels.Comp.L02compdef
msgid "The proof of the theorem in this level is very easy. Since ยง0 and ยง1 are definitionally equivalent, ยง2 will close the goal."
msgstr ""

#. ยง0: `intro`
#. ยง1: `intro`
#. ยง2: `P โ Q`
#. ยง3: `intro h`
#. ยง4: `h : P`
#. ยง5: `Q`
#. ยง6: `โ x, P x`
#. ยง7: `P x`
#. ยง8: `x`
#. ยง9: `intro x`
#. ยง10: `x`
#. ยง11: `P x`
#. ยง12: `intro x h`
#. ยง13: `intro x`
#. ยง14: `intro h`
#: Game.Levels.Subset.L04imp
msgid "Use ยง0 to introduce either a new assumption or a new object into your proof.\n"
"\n"
"There are two situations in which you can use the ยง1 tactic: * If you are proving a statement of the form ยง2, then you can use the tactic ยง3 to introduce the assumption ยง4 and set ยง5 as the goal.  Be sure to use an identifier that is not already in use. * If you are proving a statement of the form ยง6, where ยง7 is some statement about ยง8, then you can use the tactic ยง9 to introduce a new object ยง10 into the proof. Be sure to use a variable name that is not already in use.  The goal will then be ยง11.\n"
"\n"
"You can do multiple introductions in one step: for example, ยง12 has the same effect as doing ยง13 followed by ยง14."
msgstr ""

#. ยง0: `(โโ F)`
#. ยง1: `(โโ G)แถ`
#: Game.Levels.FamCombo.L07unionintcompint
msgid "This time we'll study the intersection of ยง0 and ยง1."
msgstr ""

#. ยง0: `h2 : x โ B`
#. ยง1: `h2 : ยฌx โ B`
#. ยง2: `x โ B`
#. ยง3: `x โ B โ False`
#. ยง4: `ยซ{h4}ยป : x โ B`
#. ยง5: `exact h2 ยซ{h4}ยป`
#: Game.Levels.Comp.L01contra
msgid "You can think of ยง0 (which is shorthand for ยง1) as meaning \"if ยง2 were true, then that would lead to a contradiction\"--in other words, ยง3. Applying this to your new assumption ยง4 will give the contradiction you need.  In other words, ยง5 will close the goal."
msgstr ""

#: Game.Levels.FamInter.L05subinter
msgid "Notice that the parentheses in the next goal are necessary, to indicate that the universal quantifier applies only to the subset statement.  Without the parentheses, Lean would interpret the universal quantifier as applying to the entire rest of the statement."
msgstr ""

#. ยง0: `ยซ{h3}ยป`
#. ยง1: `rcases ยซ{h3}ยป with ยซ{h3}ยปA | ยซ{h3}ยปB`
#: Game.Levels.Union.L03cases
msgid "Now the assumption ยง0 is an \"or\" statement.  The easiest way to use such an assumption is to break your proof into cases.  To do this in Lean, use the tactic ยง1."
msgstr ""

#. ยง0: `apply Exists.intro (A โฉ ยซ{t}ยป)`
#. ยง1: `use A โฉ ยซ{t}ยป`
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Try ยง0 or ยง1."
msgstr ""

#. ยง0: `U`
#. ยง1: `x`
#. ยง2: `U`
#. ยง3: `x : U`
#. ยง4: `A`
#. ยง5: `U`
#. ยง6: `A : Set U`
#. ยง7: `x`
#. ยง8: `U`
#. ยง9: `A`
#. ยง10: `Set U`
#. ยง11: `x`
#. ยง12: `A`
#. ยง13: `x โ A`
#. ยง14: `โ`
#. ยง15: `\\mem`
#. ยง16: `\\in`
#: Game.Levels.Subset
msgid "Welcome to Subset World! In this world you will learn about sets and subsets, and you will also learn the basics of proving theorems in Lean.\n"
"\n"
"The elements of the sets in this world will come from a universe called ยง0. To specify that an object ยง1 belongs to the universe ยง2, we write ยง3.  To specify that ยง4 is a set of objects from ยง5, we write ยง6.  (The terminology used in Lean is that ยง7 has *type* ยง8 and ยง9 has *type* ยง10.)  To say that ยง11 is an element of ยง12, we write ยง13.  (You can enter the symbol ยง14 by typing ยง15 or ยง16, followed by a space.)\n"
"\n"
"You will prove theorems in this game by using tools called *tactics*. The aim is to prove the theorem by applying tactics in the right order.\n"
"\n"
"Let's learn some basic tactics. Click on \"Start\" below to get started."
msgstr ""

#. ยง0: `have`
#. ยง1: `have`
#: Game.Levels.Subset.L03have
msgid "You can use the ยง0 tactic to add a new statement to your list of assumptions, as long as you can justify it with a proof.  For further information, click on ยง1 in the list of tactics on the right."
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โ Q`
#. ยง3: `โ`
#. ยง4: `\\imp`
#. ยง5: `P โ Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `intro`
#: Game.Levels.Subset.L04imp
msgid "If ยง0 and ยง1 are statements, then ยง2 means \"if P then Q\". To enter the symbol ยง3, type ยง4 (short for \"implies\").\n"
"\n"
"The most straightforward way to prove a statement of the form ยง5 is to assume that ยง6 is true and then prove ยง7.  To do that, we'll need a new tactic: ยง8."
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "Writing out the definition of intersection in the goal will help."
msgstr ""

#: Game.Levels.FamInter.L06eltwiseunion
msgid "You've finished Family Intersection World!  As you might guess, you can also take the union of a family of sets.  Can you guess how to define it?  Continue on to Family Union World to see if your guess is right."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "Proving a conjunction"
msgstr ""

#. ยง0: `U`
#. ยง1: `U`
#. ยง2: `U`
#. ยง3: `F`
#. ยง4: `U`
#. ยง5: `F : Set (Set U)`
#. ยง6: `U`
#. ยง7: `U`
#. ยง8: `F G : Set (Set U)`
#. ยง9: `S : Set U`
#. ยง10: `mem_inter_iff S F G`
#. ยง11: `S โ F โฉ G โ S โ F โง S โ G`
#. ยง12: `mem_union S F G`
#. ยง13: `S โ F โช G โ S โ F โจ S โ G`
#. ยง14: `mem_compl_iff F S`
#. ยง15: `S โ Fแถ โ S โ F`
#. ยง16: `F`
#. ยง17: `U`
#. ยง18: `F`
#. ยง19: `U`
#. ยง20: `F`
#: Game.Levels.FamInter
msgid "So far the elements of all of our sets have been objects in the universe ยง0.  But sets can contain other kinds of objects!  In the next two worlds, we will work with sets whose elements are *sets of objects from ยง1*.  We will call these *families of sets* from ยง2.  To indicate that ยง3 is a family of sets from ยง4, we write ยง5.\n"
"\n"
"For example, suppose ยง6 contains the people in a certain club, and we want to form a committee consisting of five members of the club.  The set of all possible committees is a family of sets from ยง7.  Each element of this family is a set containing five club members.\n"
"\n"
"Families of sets are sets, and everything you've learned about sets applies to families of sets. For example, if you have ยง8 and ยง9, then ยง10 is a proof of the statement ยง11.  Similarly, ยง12 is a proof of ยง13, and ยง14 is a proof of ยง15.\n"
"\n"
"In this world we extend the idea of intersections to families of sets.  If ยง16 is a family of sets from ยง17, then the *intersection* of the family ยง18 is the set of all objects from ยง19 that belong to every element of ยง20."
msgstr ""

#: Game
msgid "*Game version: 4.4*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage. If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local storage (or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Creator:** Daniel J. Velleman; based on the Natural Numbers Game, by Kevin Buzzard * **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot * **Spanish Translation:** Miguel Marco\n"
"\n"
"## Resources\n"
"\n"
"* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\n"
"\n"
"## Problems?\n"
"\n"
"Please ask any questions about this game in the [Lean Zulip chat](https://leanprover.zulipchat.com/) forum, for example in the stream \"New Members\". The community will happily help. Note that the Lean Zulip chat is a professional research forum. Please use your full real name there, stay on topic, and be nice. If you're looking for somewhere less formal (e.g. you want to post set theory game memes) then head on over to the [Lean Discord](https://discord.gg/WZ9bs9UCvx).\n"
"\n"
"Alternatively, if you experience issues / bugs you can also open github issues:\n"
"\n"
"* For issues with the game engine, please open an [issue at the lean4game repo](https://github.com/leanprover-community/lean4game/issues). * For issues about the game's content, please open an [issue at the STG repo](https://github.com/djvelleman/STG4/issues)."
msgstr ""

#. ยง0: `ยซ{hA}ยป : ยซ{t}ยป = A`
#. ยง1: `rewrite [ยซ{hA}ยป]`
#. ยง2: `ยซ{t}ยป`
#. ยง3: `A`
#: Game.Levels.FamInter.L03interpair
msgid "Now that you have ยง0, you can use ยง1 to replace ยง2 with ยง3 in the goal."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "The proof of the second goal is similar."
msgstr ""

#. ยง0: `union_subset_swap`
#: Game.Levels.Union.L04union_sub_swap
msgid "You'll be able to use the theorem ยง0 in the next level to prove that union is commutative."
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "Of course, you know by now how to start a proof that one set is a subset of another."
msgstr ""

#. ยง0: `P โง Q`
#. ยง1: `โง`
#. ยง2: `\\and`
#. ยง3: `P โง Q`
#. ยง4: `hP : P`
#. ยง5: `hQ : Q`
#. ยง6: `And.intro hP hQ`
#. ยง7: `P โง Q`
#. ยง8: `exact And.intro hP hQ`
#. ยง9: `P`
#. ยง10: `Q`
#. ยง11: `apply And.intro`
#. ยง12: `P`
#. ยง13: `Q`
#. ยง14: `constructor`
#. ยง15: `apply And.intro`
#. ยง16: `h : P โง Q`
#. ยง17: `h.left`
#. ยง18: `P`
#. ยง19: `h.right`
#. ยง20: `Q`
#: Game.Levels.Inter.L01and
msgid "ยง0 means \"P and Q\".  To enter the symbol ยง1, type ยง2.\n"
"\n"
"### If your goal is ยง3\n"
"\n"
"If you have ยง4 and ยง5, then ยง6 is a proof of ยง7, so ยง8 will close the goal. If you don't yet have proofs of ยง9 and ยง10, then ยง11 will set ยง12 and ยง13 as separate goals.  In this situation, the tactic ยง14 has the same effect as ยง15.\n"
"\n"
"### If you have an assumption ยง16\n"
"\n"
"Lean will recognize ยง17 as a proof of ยง18 and ยง19 as a proof of ยง20."
msgstr ""

#. ยง0: `ยซ{h1}ยป`
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Again, work out the consequences of ยง0 first."
msgstr ""

#. ยง0: `And.intro`
#: Game.Levels.Inter.L04proveand
msgid "Now you can use ยง0 to prove the goal."
msgstr ""

#. ยง0: `P x`
#. ยง1: `x`
#. ยง2: `h : P a`
#. ยง3: `a`
#. ยง4: `Exists.intro a h`
#. ยง5: `โ x, P x`
#: Game.Levels.FamUnion.L01proveexists
msgid "If ยง0 represents a statement about ยง1 and you have ยง2, for some object ยง3, then ยง4 is a proof of ยง5."
msgstr ""

#. ยง0: `Exists.intro A ยซ{h}ยป`
#. ยง1: `exact Exists.intro A ยซ{h}ยป`
#: Game.Levels.FamUnion.L01proveexists
msgid "ยง0 is a proof of the goal, so ยง1 will close the goal."
msgstr ""

#: Game.Levels.Combo.L03inter_distrib_union
msgid "Whew!"
msgstr ""

#. ยง0: `rewrite [mem_inter_iff] at h`
#. ยง1: `h : x โ A โฉ B`
#. ยง2: `h.left`
#. ยง3: `x โ A`
#: Game.Levels.Inter.L03inter_sub_left
msgid "You probably used a step like ยง0 in this proof.  That step is actually optional.  Writing out the definition of intersection probably helps *you* understand how to proceed with the proof, but *Lean* doesn't need to be told to write out the definition.  It will do that on its own.  In other words, if you have ยง1, Lean will accept ยง2 as a proof of ยง3."
msgstr ""

#. ยง0: `P โจ Q`
#. ยง1: `left`
#. ยง2: `P`
#. ยง3: `left`
#: Game.Levels.Union.L06union_assoc
#: Game.Levels.Union.L06union_assoc
msgid "If your goal has the form ยง0, then the tactic ยง1 will set your goal to be ยง2. There are other situations in which the ยง3 tactic can be used, but this is the one that is most relevant for the set theory game."
msgstr ""

#: Game.Levels.Subset.L01exact
msgid "The exact tactic"
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "Complement of a complement"
msgstr ""

#. ยง0: `ยซ{x}ยป : U`
#. ยง1: `ยซ{x}ยป โ A โ ยซ{x}ยป โ A`
#: Game.Levels.Subset.L05subref
msgid "Notice that ยง0 has been added to the list of objects, and the goal has changed to ยง1.  Fortunately, you already know how to prove a goal of this form."
msgstr ""

#. ยง0: `x : U`
#. ยง1: `A : Set U`
#. ยง2: `B : Set U`
#. ยง3: `mem_union x A B`
#. ยง4: `x โ A โช B โ x โ A โจ x โ B`
#. ยง5: `rewrite [mem_union]`
#. ยง6: `x โ A โช B`
#. ยง7: `mem_inter_iff`
#. ยง8: `mem_union_iff`
#: Game.Levels.Union.L02subunion
msgid "As with complements and intersections, one of the key tools for proving theorems about unions is a theorem stating the definition.  If you have ยง0, ยง1, and ยง2, then ยง3 is a proof of the statement ยง4. That means you can use ยง5 to write out the definition of ยง6 if it appears in any assumption or the goal.  (The similar theorem about intersections was called ยง7.  Why isn't this one called ยง8?  I don't know.  The naming of theorems in Lean is systematic, but there are occasional surprises.)"
msgstr ""

#: Game.Levels.FamCombo.L05unionintcompunion
msgid "A union intersected with the complement of another is a subset"
msgstr ""

#. ยง0: $A$
#. ยง1: $F$
#. ยง2: $A$
#. ยง3: $\\bigcap F$
#. ยง4: $A$
#. ยง5: $F$
#: Game.Levels.FamInter.L05subinter
msgid "Suppose ยง0 is a set and ยง1 is a family of sets.  Then ยง2 is a subset of ยง3 if and only if ยง4 is a subset of every element of ยง5."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Next, we'll see how to prove that a union is a subset of another set."
msgstr ""

#. ยง0: `F`
#. ยง1: `G`
#. ยง2: `F โ G`
#. ยง3: `โโ G`
#. ยง4: `F`
#. ยง5: `โโ G โ โโ F`
#: Game.Levels.FamInter.L02intersubinter
msgid "In this level we have two families of sets, ยง0 and ยง1, with ยง2.  That means that ยง3 is the intersection of a family of sets that includes all the sets in ยง4, plus perhaps more sets.  You're going to prove that intersecting this larger collection of sets leads to a smaller result; more precisely, you're going to prove that ยง5.\n"
"\n"
"Of course, by now you know how to start a proof that one set is a subset of another."
msgstr ""

#. ยง0: `Exists.intro`
#: Game.Levels.FamUnion.L01proveexists
msgid "Now you can use ยง0 to complete the proof."
msgstr ""

#: Game.Levels.Combo.L04union_distrib_inter
msgid "To finish off Combination World, we'll do one more tricky theorem."
msgstr ""

#: Game.Levels.Combo.L02compint
msgid "Complement of an intersection"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โช B`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `โช`
#. ยง6: `\\union`
#: Game.Levels.Union.L02subunion
msgid "If ยง0 and ยง1 are sets, then ยง2 is the union of ยง3 and ยง4. To enter the symbol ยง5, type ยง6."
msgstr ""

#. ยง0: `ยซ{h1}ยป`
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "It will help to get as much information as you can out of ยง0 before addressing the goal."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `union_assoc A B C`
#. ยง4: `(A โช B) โช C = A โช (B โช C)`
#. ยง5: `Set.union_assoc`
#: Game.Levels.Union.L06union_assoc
#: Game.Levels.Combo.L03inter_distrib_union
#: Game.Levels.Combo.L04union_distrib_inter
msgid "For any sets ยง0, ยง1, and ยง2, ยง3 is a proof of the statement ยง4.  In Mathlib, the name of this theorem is ยง5."
msgstr ""

#. ยง0: `apply Subset.antisymm`
#. ยง1: `ext`
#: Game.Levels.Inter.L08inter_assoc
msgid "Our goal in this level is again an equation between sets.  In previous proofs of this kind, we've started with the tactic ยง0, and that would work here as well. But we're going to try out an alternative: the tactic ยง1.  This tactic applies the principle of *extensionality* for sets, which says that if two sets have exactly the same elements, then they are equal."
msgstr ""

#. ยง0: `ext x`
#. ยง1: `apply Subset.antisymm`
#. ยง2: `compl_union`
#. ยง3: `Aแถ โช Bแถ`
#. ยง4: `(Aแถ โช Bแถ)แถแถ`
#. ยง5: `compl_compl (Aแถ โช Bแถ)`
#. ยง6: `(Aแถ โช Bแถ)แถแถ = Aแถ โช Bแถ`
#. ยง7: `rewrite [compl_compl (Aแถ โช Bแถ)]`
#. ยง8: `(Aแถ โช Bแถ)แถแถ`
#. ยง9: `Aแถ โช Bแถ`
#. ยง10: `Aแถ โช Bแถ`
#. ยง11: `(Aแถ โช Bแถ)แถแถ`
#. ยง12: `rewrite [โ compl_compl (Aแถ โช Bแถ)]`
#. ยง13: `\\l`
#: Game.Levels.Combo.L02compint
msgid "Of course, you could start the proof in this level with either ยง0 or ยง1. But there is a shorter solution: you can use the theorem from the previous level (ยง2) to prove the theorem in this level.\n"
"\n"
"The trick to get started on this proof is to rewrite ยง3 as ยง4.  As you know, ยง5 is a proof of the theorem ยง6, and therefore ยง7 could be used to rewrite ยง8 as ยง9; but we want to go in the opposite direction, rewriting ยง10 as ยง11. To do that, use ยง12. (To enter the left-pointing arrow, type ยง13.)"
msgstr ""

#: Game.Levels.Union.L01or
msgid "Or"
msgstr ""

#. ยง0: `ยซ{h2}ยป : โ t โ F, ยซ{x}ยป โ t`
#. ยง1: `ยซ{h2}ยป : โ t, t โ F โ ยซ{x}ยป โ t`
#. ยง2: `โ`
#. ยง3: `ยซ{h2}ยป`
#. ยง4: `t`
#. ยง5: `ยซ{h2}ยป`
#. ยง6: `A`
#. ยง7: `A โ F โ ยซ{x}ยป โ A`
#. ยง8: `ยซ{h2}ยป`
#. ยง9: `A`
#. ยง10: `ยซ{h2}ยป`
#. ยง11: `A`
#. ยง12: `have ยซ{h2}ยปA : A โ F โ ยซ{x}ยป โ A := ยซ{h2}ยป A`
#. ยง13: `have ยซ{h2}ยปA := ยซ{h2}ยป A`
#. ยง14: `ยซ{h2}ยป A`
#: Game.Levels.FamInter.L01intersub
msgid "Remember that ยง0 is an abbreviation for ยง1.  Since ยง2 means \"for all\", ยง3 can be applied to any set--that is, we can plug in any set for ยง4 in ยง5. In particular, applying it to the set ยง6, we can conclude that ยง7. To apply ยง8 to ยง9, we just write ยง10 followed by ยง11, with a space between them. Thus, your next step can be ยง12.  You can save yourself a little typing by writing ยง13; Lean will figure out what statement is proven by ยง14."
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ โ A`
#. ยง2: `Subset.refl`
#. ยง3: `A`
#: Game.Levels.FamUnion.L01proveexists
msgid "By the way, another set that would have worked as a witness for the existential goal in this theorem is the empty set, denoted ยง0.  However, to justify the use of that witness you would have had to prove ยง1.  Since we already have the theorem ยง2, it was easier to use ยง3 as the witness.\n"
"\n"
"Now that you know how to prove existential statements, you're ready to start working with unions of families."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `โ`
#. ยง2: `\\iff`
#. ยง3: `P โ Q`
#. ยง4: `P`
#. ยง5: `Q`
#. ยง6: `rfl`
#. ยง7: `h1 : P โ Q`
#. ยง8: `h2 : Q โ P`
#. ยง9: `Iff.intro h1 h2`
#. ยง10: `P โ Q`
#. ยง11: `exact Iff.intro h1 h2`
#. ยง12: `P โ Q`
#. ยง13: `Q โ P`
#. ยง14: `apply Iff.intro`
#. ยง15: `P โ Q`
#. ยง16: `Q โ P`
#. ยง17: `constructor`
#. ยง18: `apply Iff.intro`
#. ยง19: `h : P โ Q`
#. ยง20: `h.mp`
#. ยง21: `P โ Q`
#. ยง22: `h.mpr`
#. ยง23: `Q โ P`
#. ยง24: `h`
#. ยง25: `rewrite`
#: Game.Levels.Comp.L02compdef
msgid "ยง0 means \"P if and only if Q\".  You can enter the symbol ยง1 by typing ยง2.\n"
"\n"
"### If your goal is ยง3\n"
"\n"
"If ยง4 and ยง5 are definitionally equivalent, then ยง6 will close the goal. If you have ยง7 and ยง8, then ยง9 is a proof of ยง10, so ยง11 will close the goal. If you don't yet have proofs of ยง12 and ยง13, then ยง14 will set ยง15 and ยง16 as your goals.  In this situation, the tactic ยง17 has the same effect as ยง18.\n"
"\n"
"### If you have an assumption ยง19\n"
"\n"
"Lean will recognize ยง20 as a proof of ยง21 and ยง22 as a proof of ยง23.  You may also find it helpful to use ยง24 in the ยง25 tactic."
msgstr ""

#. ยง0: `exact h`
#: Game.Levels.Subset.L01exact
msgid "In order to complete this proof, type ยง0 in the text box under the goal and click on \"Execute\" or hit the \"Return\" or \"Enter\" key."
msgstr ""

#. ยง0: `A : Set U`
#. ยง1: `Subset.refl A`
#. ยง2: `A โ A`
#. ยง3: `Set.Subset.refl`
#: Game.Levels.Subset.L05subref
#: Game.Levels.Comp.L03compsub
msgid "If you have ยง0, then ยง1 is a proof of ยง2. In Mathlib, the name of this theorem is ยง3."
msgstr ""

#. ยง0: `โ`
#. ยง1: `โ`
#: Game.Levels.FamCombo.L03commonelt
msgid "This level is an exercise in handling sequences of quantifiers that alternate between ยง0 and ยง1.  A good way to start is to decide which assumption to use first."
msgstr ""

#. ยง0: $A$
#. ยง1: $B$
#. ยง2: $B \\subseteq A \\cup B$
#: Game.Levels.Union.L02subunion
#: Game.Levels.FamInter.L03interpair
#: Game.Levels.FamUnion.L04unionpair
msgid "Suppose ยง0 and ยง1 are sets.  Then ยง2."
msgstr ""

#. ยง0: `ยซ{h1}ยป`
#: Game.Levels.FamCombo.L01compunion
msgid "What set can you apply ยง0 to?"
msgstr ""

#: Game.Levels.Combo
msgid "In this world you'll prove theorems combining complements, intersections, and unions.  For the most part, we'll leave you on your own to figure out these proofs."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "Proving existential statements"
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A`
#. ยง3: `B`
#. ยง4: `A`
#. ยง5: `B`
#. ยง6: `A โ B`
#. ยง7: `A`
#. ยง8: `B`
#. ยง9: `โ`
#. ยง10: `\\sub`
#. ยง11: `h1 : A โ B`
#. ยง12: `h1`
#. ยง13: `A`
#. ยง14: `B`
#. ยง15: `h2 : x โ A`
#. ยง16: `h1`
#. ยง17: `h2`
#. ยง18: `x โ B`
#. ยง19: `h1`
#. ยง20: `h2`
#. ยง21: `h1`
#. ยง22: `h2`
#. ยง23: `h1 h2`
#. ยง24: `x โ B`
#: Game.Levels.Subset.L02subhyp
msgid "If ยง0 and ยง1 are sets, then we say that ยง2 is a *subset* of ยง3 if every element of ยง4 is also an element of ยง5.  The notation ยง6 means that ยง7 is a subset of ยง8.  (To enter the symbol ยง9, type ยง10, followed by a space.)\n"
"\n"
"If you have ยง11, then ยง12 is a proof that, if something is an element of ยง13, then it is also an element of ยง14.  Thus, if you also have ยง15, then you can apply ยง16 to ยง17 to conclude that ยง18.  To apply ยง19 to ยง20, you simply write ยง21 followed by ยง22, with a space between them.  Thus, in this situation, ยง23 is a proof of ยง24.\n"
"\n"
"See if you can use this to complete this level.  If you need a hint, click on \"Show more help!\"."
msgstr ""

#: Game.Levels.FamCombo.L02compinter
msgid "Complement of a family intersection"
msgstr ""

#. ยง0: `P`
#. ยง1: `Q`
#. ยง2: `P โจ Q`
#. ยง3: `โจ`
#. ยง4: `\\or`
#. ยง5: `P โจ Q`
#. ยง6: `P`
#. ยง7: `Q`
#. ยง8: `h : P`
#. ยง9: `Or.inl h`
#. ยง10: `P โจ Q`
#. ยง11: `h : Q`
#. ยง12: `Or.inr h`
#. ยง13: `P โจ Q`
#: Game.Levels.Union.L01or
msgid "For working with unions, the important logical word is \"or\".\n"
"\n"
"If ยง0 and ยง1 are statements, then ยง2 means \"P or Q or both\".  To enter the symbol ยง3, type ยง4.  For the statement ยง5 to be true, either ยง6 or ยง7 must be true.  This gives us two ways to prove a statement of this form.  If you have ยง8, then ยง9 can be used to prove ยง10.  If you have ยง11, then ยง12 proves ยง13."
msgstr ""

#. ยง0: `ยซ{x}ยป โ A`
#. ยง1: `ยซ{x}ยป โ A`
#. ยง2: `by_cases hA : ยซ{x}ยป โ A`
#: Game.Levels.FamInter.L06eltwiseunion
msgid "If ยง0, then the goal is easy to prove.  This suggests breaking the proof into cases depending on whether or not ยง1.  You can do this with the tactic ยง2."
msgstr ""

#. ยง0: `F`
#. ยง1: `G`
#. ยง2: `F โ G`
#. ยง3: `โโ G โ โโ F`
#. ยง4: `โโ F โ โโ G`
#. ยง5: `h : โ x, P x`
#. ยง6: `obtain`
#. ยง7: `obtain โจw, hwโฉ := h`
#. ยง8: `w`
#. ยง9: `hw : P w`
#. ยง10: `w`
#. ยง11: `h`
#. ยง12: `obtain`
#. ยง13: `w`
#. ยง14: `hw`
#. ยง15: `โจ โฉ`
#. ยง16: `\\<`
#. ยง17: `\\>`
#. ยง18: `\\langle`
#. ยง19: `\\rangle`
#: Game.Levels.FamUnion.L03unionsubunion
msgid "In this level we have two families of sets, ยง0 and ยง1, with ยง2.  In Family Intersection World, you proved that in this situation, ยง3.  In this level, you'll prove that with family unions, it works the other way: ยง4.\n"
"\n"
"We'll need a new tactic for this proof.  An assumption of the form ยง5 tells you that an object with a certain property exists.  If you have such an assumption, then it is usually helpful to introduce a name for such an object.  You can do this with the ยง6 tactic.  If you write ยง7, then Lean will introduce a new object ยง8 and a new assumption ยง9.  Thus, the object ยง10 is a witness for the existential assumption ยง11.  Note that in the ยง12 tactic, ยง13 and ยง14 must be enclosed in angle brackets: ยง15.  You can enter these by typing either ยง16 and ยง17 or ยง18 and ยง19."
msgstr ""

#. ยง0: `P x`
#. ยง1: `x`
#. ยง2: `โ x, P x`
#. ยง3: `x`
#. ยง4: `P x`
#. ยง5: `โ`
#. ยง6: `\\exists`
#. ยง7: `โ x, P x`
#. ยง8: `h : P a`
#. ยง9: `a`
#. ยง10: `Exists.intro a h`
#. ยง11: `โ x, P x`
#. ยง12: `exact Exists.intro a h`
#. ยง13: `P a`
#. ยง14: `apply Exists.intro a`
#. ยง15: `P a`
#. ยง16: `use a`
#. ยง17: `P a`
#. ยง18: `P a`
#. ยง19: `h : โ x, P x`
#. ยง20: `obtain โจw, hwโฉ := h`
#. ยง21: `w`
#. ยง22: `hw : P w`
#. ยง23: `โจ โฉ`
#. ยง24: `\\<`
#. ยง25: `\\>`
#. ยง26: `\\langle`
#. ยง27: `\\rangle`
#: Game.Levels.FamUnion.L01proveexists
msgid "If ยง0 represents a statement about ยง1, then ยง2 means \"there is at least one ยง3 such that ยง4 is true\".  To enter the symbol ยง5, type ยง6.\n"
"\n"
"### If your goal is ยง7\n"
"\n"
"If you have ยง8, for some object ยง9, then ยง10 is a proof of ยง11, so ยง12 will close the goal. If you think ยง13 is true, but you don't yet have a proof of it, then ยง14 will set ยง15 as your goal.  The tactic ยง16 does the same thing, but it also tries to prove ยง17; if it doesn't succeed, then it leaves ยง18 as a goal for you to prove.\n"
"\n"
"### If you have an assumption ยง19\n"
"\n"
"The tactic ยง20 will introduce a new object ยง21 and a new assumption ยง22 into the proof.  To enter the angle brackets ยง23, type either ยง24 and ยง25 or ยง26 and ยง27."
msgstr ""

#. ยง0: `h1`
#. ยง1: `ยซ{h3}ยป`
#. ยง2: `x โ B`
#. ยง3: `have`
#: Game.Levels.Subset.L04imp
msgid "As you saw in the previous level, you can now apply ยง0 to ยง1 to justify asserting ยง2, using the ยง3 tactic."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `C`
#. ยง3: `inter_assoc A B C`
#. ยง4: `(A โฉ B) โฉ C = A โฉ (B โฉ C)`
#. ยง5: `Set.inter_assoc`
#: Game.Levels.Inter.L08inter_assoc
msgid "For any sets ยง0, ยง1, and ยง2, ยง3 is a proof of the statement ยง4.  Im Mathlib, the name of this theorem is ยง5."
msgstr ""

#. ยง0: $x \\in A$
#. ยง1: $B$
#. ยง2: $x \\in A โจ x โ B$
#: Game.Levels.Union.L01or
msgid "Suppose ยง0, and ยง1 is any set.  Then ยง2."
msgstr ""

#. ยง0: $F$
#. ยง1: $G$
#. ยง2: $\\bigcup (F \\cap G^c) \\subseteq (\\bigcup F) \\cap (\\bigcup G)^c$
#. ยง3: $(\\bigcup F) \\cap (\\bigcup G) \\subseteq \\bigcup (F \\cap G)$
#: Game.Levels.FamCombo.L06unionintunion
msgid "Suppose ยง0 and ยง1 are families of sets and ยง2.  Then ยง3."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `constructor`
#. ยง2: `apply Iff.intro`
#. ยง3: `P โ Q`
#. ยง4: `Q โ P`
#: Game.Levels.Comp.L05compsubiff
msgid "The proof in this level illustrates how previously proven theorems can be used in proofs.\n"
"\n"
"There is another tactic you can use if your goal has the form ยง0.  In this situation, the tactic ยง1 will have the same effect as ยง2; that is, it will set ยง3 and ยง4 as goals to be proven."
msgstr ""

#: Game.Levels.Union
msgid "Union World"
msgstr ""

#. ยง0: $A$
#. ยง1: $F$
#. ยง2: $A \\cap (\\bigcup F) = \\bigcup\\{s \\mid \\exists u \\in F, s = A \\cap u\\}$
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Suppose ยง0 is a set and ยง1 is a family of sets.  Then ยง2."
msgstr ""

#. ยง0: `ยซ{h1}ยป`
#. ยง1: `ยฌยซ{x}ยป โ A`
#. ยง2: `ยฌยฌยซ{x}ยป โ A`
#. ยง3: `ยซ{x}ยป โ A`
#. ยง4: `push_neg`
#. ยง5: `ยซ{h1}ยป`
#. ยง6: `push_neg at ยซ{h1}ยป`
#: Game.Levels.Comp.L04compcomp
msgid "Now ยง0 says ยง1, which means ยง2.  Of course, this can be simplified to ยง3.  To perform this simplification, you'll need a new tactic, ยง4.  To simplify the assumption ยง5, write ยง6."
msgstr ""

#. ยง0: `A โ {A, B}`
#. ยง1: `have`
#: Game.Levels.FamInter.L03interpair
msgid "It would be helpful if you knew that ยง0. You can use ยง1 to assert it."
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Now your situation is similar to the previous level."
msgstr ""

#. ยง0: $x$
#. ยง1: $U$
#. ยง2: $A$
#. ยง3: $B$
#. ยง4: $C$
#. ยง5: $A \\subseteq B$
#. ยง6: $x \\in B \\to x \\in C$
#. ยง7: $x \\in A โ x \\in C$
#: Game.Levels.Subset.L04imp
msgid "Let ยง0 be an object from the universe ยง1, and let ยง2, ยง3, and ยง4 be sets such that ยง5 and ยง6.  Then ยง7."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `intro h`
#. ยง2: `h : P`
#. ยง3: `Q`
#. ยง4: `h1 : P โ Q`
#. ยง5: `h2 : P`
#. ยง6: `h1 h2`
#. ยง7: `Q`
#. ยง8: `P โ Q`
#. ยง9: `P`
#. ยง10: `Q`
#. ยง11: `intro`
#. ยง12: `intro`
#: Game.Levels.Subset.L04imp
msgid "In general, if your goal has the form ยง0, then the tactic ยง1 will add ยง2 to the list of assumptions and set ยง3 to be the goal.  If you have assumptions ยง4 and ยง5, then ยง6 is a proof of ยง7.  This is another example of a proof acting like a function: a proof of ยง8 can be thought of as a function which, when applied to a proof of ยง9, produces a proof of ยง10.\n"
"\n"
"As usual, for more information about the new tactic ยง11, you can click on ยง12 in the list of tactics on the right."
msgstr ""

#. ยง0: `ยซ{s}ยป`
#. ยง1: `t`
#. ยง2: `apply Exists.intro ยซ{s}ยป`
#. ยง3: `use ยซ{s}ยป`
#: Game.Levels.FamUnion.L03unionsubunion
msgid "Do you see why ยง0 is the value to use as a witness for ยง1 in the goal? Your next step can be either ยง2 or ยง3."
msgstr ""

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "You've finished Combination World!"
msgstr ""

#. ยง0: `hB : ยซ{x}ยป โ B`
#. ยง1: `hC : ยซ{x}ยป โ C`
#. ยง2: `And.intro hB hC`
#. ยง3: `have`
#. ยง4: `ยซ{x}ยป โ B`
#. ยง5: `ยซ{x}ยป โ C`
#. ยง6: `And.intro`
#. ยง7: `apply`
#. ยง8: `apply And.intro`
#. ยง9: `And.intro`
#. ยง10: `ยซ{x}ยป โ B`
#. ยง11: `ยซ{x}ยป โ C`
#: Game.Levels.Inter.L05subint
msgid "If you had ยง0 and ยง1, then ยง2 would prove the goal.  So there are two ways to proceed.  One possibility is to use ยง3 to introduce the assumptions ยง4 and ยง5--that is, if you can see how to justify those statements!  Then you can use ยง6 to prove the goal.\n"
"\n"
"The second possibility is to use the ยง7 tactic.  Recall that if you write ยง8, then Lean will figure out that the theorem ยง9 could be applied to prove the goal, if only you had proofs of ยง10 and ยง11.  So it will set those two statements as goals, to be proven one after the other."
msgstr ""

#. ยง0: `push_neg`
#: Game.Levels.Combo.L01compunion
msgid "There is more than one way to do the proof in this level.  Since the proof involves complements of sets, negative statements will arise in the course of the proof.  This suggests two possible techniques. You may be able to use the ยง0 tactic to reexpress some negative statements as equivalent positive statements.  And you may find proof by contradiction useful."
msgstr ""

#. ยง0: `have`
#. ยง1: `ยซ{x}ยป โ A โช C`
#. ยง2: `have hAC : ยซ{x}ยป โ A โช C`
#. ยง3: `ยซ{x}ยป โ A โช C`
#. ยง4: `hAC : ยซ{x}ยป โ A โช C`
#. ยง5: `have`
#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "Now use ยง0 to assert that ยง1.  If you don't see right away how to justify this assertion, you can just write ยง2 and Lean will set ยง3 as your immediate goal.  Once you achieve that goal, Lean will add ยง4 to your list of assumptions, and you can continue with the proof of your original goal.  For further details, click on ยง5 in the list of tactics on the right."
msgstr ""

#. ยง0: `โ x, P x`
#. ยง1: `P x`
#. ยง2: `x`
#. ยง3: `a`
#. ยง4: `x`
#. ยง5: `use a`
#. ยง6: `P a`
#: Game.Levels.FamUnion.L02subunion
msgid "If your goal is ยง0, where ยง1 represents some statement about ยง2, and ยง3 is a value that could be assigned to ยง4, then the tactic ยง5 will set ยง6 to be the goal.  It will then see if this new goal follows easily from your assumptions, and if so it will close the goal."
msgstr ""

#. ยง0: `ยซ{h3}ยป`
#: Game.Levels.Union.L03cases
msgid "To understand the logic of this proof, it will help to write out the definition of union in ยง0."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `inter_comm A B`
#. ยง3: `A โฉ B = B โฉ A`
#. ยง4: `Set.inter_comm`
#: Game.Levels.Inter.L07inter_comm
#: Game.Levels.Union.L05union_comm
#: Game.Levels.Combo.L01compunion
#: Game.Levels.Combo.L02compint
msgid "For any sets ยง0 and ยง1, ยง2 is a proof of the statement ยง3.  In Mathlib, the name of this theorem is ยง4."
msgstr ""

#: Game.Levels.Inter.L05subint
#: Game.Levels.FamInter.L05subinter
msgid "Subset of an intersection"
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "Proof by contradiction"
msgstr ""

#: Game.Levels.FamCombo
msgid "Family Combination World"
msgstr ""

#: Game.Levels.Combo.L04union_distrib_inter
msgid "This is different from the previous theorem--the roles of union and intersection have been swapped.\n"
"\n"
"Once again, there is a tricky shortcut: there is a way to use the theorem from the previous level to prove this theorem.\n"
"\n"
"But if you don't see the shortcut, you can use a straightforward approach. If you made it through the last one, you can do this one too!"
msgstr ""

#. ยง0: `Subset.trans`
#: Game.Levels.Subset.L06subtrans
msgid "The theorem you have proven in this level shows that the subset relation has a property called *transitivity*.  We have given the theorem the name ยง0."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Well done!  You're ready to move on to Union World."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "Family intersection is subset"
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "Now your goal is a negative statement, so try proof by contradiction."
msgstr ""

#. ยง0: `ยฌP`
#. ยง1: `ยฌ`
#. ยง2: `\\not`
#. ยง3: `ยฌ P`
#. ยง4: `push_neg`
#. ยง5: `by_contra h`
#. ยง6: `h : P`
#. ยง7: `False`
#. ยง8: `h : ยฌ P`
#. ยง9: `push_neg at h`
#. ยง10: `ยฌ P`
#. ยง11: `P โ False`
#. ยง12: `hP : P`
#. ยง13: `h hP`
#. ยง14: `False`
#. ยง15: `False`
#. ยง16: `exact h hP`
#: Game.Levels.Comp.L01contra
msgid "ยง0 means \\\\\"it is not the case that P\\\\\".  To enter the symbol ยง1, type ยง2.\n"
"\n"
"### If your goal is ยง3\n"
"\n"
"You may be able to use the ยง4 tactic to reexpress the goal as an equivalent positive statement.  If not, then a good strategy is to use proof by contradiction.  The tactic ยง5 will introduce the assumption ยง6, and set the goal to be ยง7.\n"
"\n"
"### If you have an assumption ยง8\n"
"\n"
"You may be able to use the tactic ยง9 to reexpress this assumption as an equivalent positive statement.  Lean treats ยง10 as meaning ยง11, so if you also have ยง12, then ยง13 will be a proof of ยง14.  That means that if you are doing a proof by contradiction, so your goal is ยง15, then ยง16 will close the goal."
msgstr ""

#: Game.Levels.FamInter.L06eltwiseunion
msgid "Writing out the meaning of the goal will make the proof easier to understand."
msgstr ""

#. ยง0: `โ t`
#. ยง1: `t`
#. ยง2: `intro t`
#. ยง3: `t`
#. ยง4: `t`
#. ยง5: `t`
#. ยง6: `t`
#: Game.Levels.FamInter.L02intersubinter
msgid "Now your goal starts with ยง0.  To prove it, you'll need to introduce a set ยง1 into the proof, using the tactic ยง2.  Recall that the set ยง3 is *arbitrary*--that is, ยง4 could stand for any set--so whatever we prove about ยง5 will be true for *all* sets ยง6."
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed! ๐"
msgstr ""

#. ยง0: `h`
#. ยง1: `P โจ Q`
#. ยง2: `rcases h with h1 | h2`
#. ยง3: `h1 : P`
#. ยง4: `h2 : Q`
#. ยง5: `rcases`
#. ยง6: `P โจ Q`
#. ยง7: `rcases`
#: Game.Levels.Union.L03cases
msgid "If ยง0 is a proof of a statement of the form ยง1, then the tactic ยง2 will break your proof into cases.  In case 1, you'll have the new assumption ยง3, and in case 2 you'll have ยง4.  In both cases you have to prove the original goal.\n"
"\n"
"The ยง5 tactic has other uses.  In particular, it can be applied to proofs of statements that do not have the form ยง6.  However, we will not discuss these other uses of the ยง7 tactic in this game."
msgstr ""

#. ยง0: $F$
#. ยง1: $A \\in F$
#. ยง2: $\\bigcap F \\subseteq A$
#: Game.Levels.FamInter.L01intersub
#: Game.Levels.FamUnion.L02subunion
msgid "Suppose ยง0 is a family of sets and ยง1.  Then ยง2."
msgstr ""

#. ยง0: `h1 : A โ F`
#. ยง1: `h2 : โ t โ F, P t`
#. ยง2: `P t`
#. ยง3: `t`
#. ยง4: `h2 A`
#. ยง5: `A โ F โ P A`
#. ยง6: `h1`
#. ยง7: `h2 A h1`
#. ยง8: `P A`
#. ยง9: `h1 : A โ F`
#. ยง10: `h2 : โ t โ F, x โ t`
#. ยง11: `h2 A h1`
#. ยง12: `x โ A`
#: Game.Levels.FamInter.L01intersub
msgid "The last two steps could have been combined into one step.  In general, if you have ยง0 and ยง1, where ยง2 is some statement about ยง3, then ยง4 is a proof of ยง5, and applying that proof to ยง6 we conclude that ยง7 is a proof of ยง8.  For example, if you have ยง9 and ยง10, then ยง11 is a proof of ยง12."
msgstr ""

#. ยง0: `mem_compl_iff`
#. ยง1: `A : Set U`
#. ยง2: `x : U`
#. ยง3: `mem_compl_iff A x`
#. ยง4: `x โ Aแถ โ x โ A`
#. ยง5: `x โ Aแถ โ x โ A`
#. ยง6: `x โ Aแถ`
#. ยง7: `x โ A`
#. ยง8: `rewrite`
#. ยง9: `rewrite`
#: Game.Levels.Comp.L03compsub
msgid "In the last level, you proved the theorem ยง0.  If you have ยง1 and ยง2, then ยง3 is a proof of the statement ยง4.\n"
"\n"
"You could think of the statement ยง5 as saying that if ยง6 occurs anywhere in a proof, you can replace it with ยง7.  There is a tactic called ยง8 that can be used to perform such replacements.  You'll get to try out the ยง9 tactic in this level."
msgstr ""

#. ยง0: `exact`
#. ยง1: `exact`
#. ยง2: `h1`
#. ยง3: `x โ A`
#. ยง4: `x โ B`
#: Game.Levels.Subset.L02subhyp
msgid "This example is a better illustration of how the ยง0 tactic is usually used.  Often ยง1 is followed by an expression that combines assumptions to prove the goal.  In later levels, we will see other ways in which assumptions can be combined to prove a goal.\n"
"\n"
"Note that in this proof, ยง2 could be thought of as a function that can be applied to a proof of any statement of the form ยง3 to produce a proof of ยง4.  Many proofs in Lean behave like functions."
msgstr ""

#. ยง0: `Subset.refl A`
#. ยง1: `A โ A`
#. ยง2: `have h : A โ A := Subset.refl A`
#: Game.Levels.FamUnion.L01proveexists
msgid "Recall that ยง0 is a proof of ยง1. So start your proof with ยง2."
msgstr ""

#. ยง0: $A \\subseteq B$
#. ยง1: $B \\subseteq C$
#. ยง2: $x \\in A$
#. ยง3: $x \\in C$
#: Game.Levels.Subset.L03have
msgid "Suppose ยง0, ยง1, and ยง2.  Then ยง3."
msgstr ""

#: Game.Levels.FamInter.L04interunion
msgid "Intersection of a union of families"
msgstr ""

#. ยง0: `ยซ{h1}ยป`
#: Game.Levels.Comp.L04compcomp
msgid "Now write out the definition of complement in ยง0."
msgstr ""

#. ยง0: `mem_singleton_iff`
#. ยง1: `x โ {a} โ x = a`
#. ยง2: `Set.mem_singleton_iff`
#: Game.Levels.FamCombo.L08singleton
msgid "Lean will recognize ยง0 is a proof of any statement of the form ยง1.  In Mathlib, the name of this theorem is ยง2."
msgstr ""

#. ยง0: `ยซ{h}ยป`
#: Game.Levels.Union.L04union_sub_swap
msgid "The form of the assumption ยง0 now suggests proof by cases."
msgstr ""

#. ยง0: `h1 : A โ B`
#. ยง1: `h2 : B โ C`
#. ยง2: `h3 : x โ A`
#. ยง3: `h1 h3`
#. ยง4: `x โ B`
#. ยง5: `exact h1 h3`
#. ยง6: `h1 h3`
#. ยง7: `h4 : x โ B`
#. ยง8: `have`
#: Game.Levels.Subset.L03have
msgid "In this level, we have assumptions ยง0, ยง1, and ยง2. As we saw in the last level, ยง3 is a proof that ยง4.  Unfortunately, that is not the goal, so we can't use ยง5 to close the goal. However, we can use the proof ยง6 to justify adding ยง7 to our list of assumptions.  To do that, we'll use a new tactic: ยง8."
msgstr ""

#. ยง0: $F$
#. ยง1: $(\\bigcup F)^c = \\bigcap \\{s \\mid s^c \\in F\\}$
#: Game.Levels.FamCombo.L01compunion
#: Game.Levels.FamCombo.L02compinter
msgid "For any family of sets ยง0, ยง1."
msgstr ""

#. ยง0: `x : U`
#. ยง1: `A : Set U`
#. ยง2: `B : Set U`
#. ยง3: `mem_inter_iff x A B`
#. ยง4: `x โ A โฉ B โ x โ A โง x โ B`
#. ยง5: `Set.mem_inter_iff`
#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "If you have ยง0, ยง1, and ยง2, then ยง3 is a proof of the statement ยง4. In Mathlib, the name of this theorem is ยง5."
msgstr ""

#. ยง0: $A$
#. ยง1: $S$
#. ยง2: $S \\subseteq A$
#: Game.Levels.FamUnion.L01proveexists
msgid "Suppose ยง0 is a set.  Then there is some set ยง1 such that ยง2."
msgstr ""

#. ยง0: `h1`
#: Game.Levels.FamInter.L06eltwiseunion
msgid "Now use ยง0."
msgstr ""

#. ยง0: `x`
#. ยง1: `x โ A`
#: Game.Levels.Subset.L06subtrans
msgid "To get started, you'll need to introduce first an object ยง0 and then the assumption that ยง1."
msgstr ""

#. ยง0: `ยซ{h2}ยป`
#: Game.Levels.FamInter.L06eltwiseunion
msgid "You haven't used ยง0 yet.  If you don't see how to use it, write out its definition."
msgstr ""

#. ยง0: `obtain`
#. ยง1: `ยซ{h1}ยป`
#: Game.Levels.FamUnion.L04unionpair
msgid "Remember, you can use ยง0 to introduce a name for the set that is asserted to exist in ยง1."
msgstr ""

#: Game.Levels.Combo
msgid "Combination World"
msgstr ""

#. ยง0: `ยซ{h2}ยป ยซ{t}ยป ยซ{h4}ยป`
#: Game.Levels.FamInter.L02intersubinter
msgid "ยง0 is now a proof of the goal."
msgstr ""

#. ยง0: `rewrite`
#. ยง1: `rewrite`
#. ยง2: `rw`
#. ยง3: `rewrite`
#. ยง4: `rw`
#. ยง5: `rewrite`
#. ยง6: `compl_subset_compl_of_subset`
#: Game.Levels.Comp.L03compsub
msgid "The ยง0 tactic is often useful for writing out definitions.  For more information about how it works, click on ยง1 in the list of tactics on the right.  You can also use ยง2 instead of ยง3.  (There is actually a small difference between the tactics ยง4 and ยง5, but the difference won't concern us in this game.)\n"
"\n"
"You'll find the theorem you proved in this level listed as ยง6 in the list of theorems on the right.  This theorem will be useful in the last level of this world."
msgstr ""

#. ยง0: `A : Set U`
#. ยง1: `x : U`
#. ยง2: `mem_compl_iff A x`
#. ยง3: `x โ Aแถ โ x โ A`
#. ยง4: `Set.mem_compl_iff`
#: Game.Levels.Comp.L02compdef
msgid "If you have ยง0 and ยง1, then ยง2 is a proof of the statement ยง3.  In Mathlib, the name of this theorem is ยง4."
msgstr ""

#. ยง0: `x`
#. ยง1: `U`
#. ยง2: `A`
#. ยง3: `U`
#. ยง4: `x โ A`
#. ยง5: `x โ A`
#. ยง6: `U : Type`
#. ยง7: `x : U`
#. ยง8: `A : Set U`
#. ยง9: `h : x โ A`
#. ยง10: `h`
#. ยง11: `x โ A`
#. ยง12: `exact`
#. ยง13: `exact`
#: Game.Levels.Subset.L01exact
msgid "# Read this first\n"
"\n"
"Each level in this game involves proving a mathematical statement (the \"Goal\"). When you give a proof of this statement that is accepted by Lean, we say that you have *closed* the goal.\n"
"\n"
"In this first level you're going to prove that if ยง0 belongs to the universe ยง1, ยง2 is a set of objects from ยง3, and ยง4, then ยง5.  You should see ยง6, ยง7, and ยง8 under *Objects* in the pane to the right, and ยง9 under *Assumptions*.  The letter ยง10 here is called an *identifier* for the assumption ยง11.\n"
"\n"
"You will prove goals in Lean using *tactics*.  The first tactic you're going to learn is called ยง12, and it is used to close the goal. You can close the goal by typing ยง13 followed by a proof of the goal."
msgstr ""

#. ยง0: `ยซ{h3}ยป`
#. ยง1: `ยซ{t}ยปแถ โ {s | sแถ โ F}`
#. ยง2: `have ยซ{h3}ยปa : ยซ{t}ยปแถ โ {s | sแถ โ F}`
#. ยง3: `ยซ{t}ยปแถ โ {s | sแถ โ F}`
#. ยง4: `ยซ{h3}ยปa : ยซ{t}ยปแถ โ {s | sแถ โ F}`
#. ยง5: `have`
#: Game.Levels.FamCombo.L01compunion
msgid "To make use of ยง0, you'll need to assert ยง1.  If you don't see right away how to justify this assertion, you can just write ยง2 and Lean will set ยง3 as your immediate goal.  Once you achieve that goal, Lean will add ยง4 to your list of assumptions, and you can continue with the proof of your original goal.  For further details, click on ยง5 in the list of tactics on the right."
msgstr ""

#. ยง0: `P โ Q`
#. ยง1: `P`
#. ยง2: `Q`
#. ยง3: `โ`
#. ยง4: `\\imp`
#. ยง5: `P โ Q`
#. ยง6: `intro h`
#. ยง7: `h : P`
#. ยง8: `Q`
#. ยง9: `h`
#. ยง10: `h : P โ Q`
#. ยง11: `hP : P`
#. ยง12: `h hP`
#. ยง13: `Q`
#: Game.Levels.Subset.L04imp
msgid "ยง0 means \"if ยง1 then ยง2\".  You can enter the symbol ยง3 by typing ยง4.\n"
"\n"
"### If your goal is ยง5\n"
"\n"
"The tactic ยง6 will introduce the new assumption ยง7 into the proof, and set the goal to be ยง8.  Be sure to use an identifier ยง9 that is not already being used to stand for some assumption.\n"
"\n"
"### If you have an assumption ยง10\n"
"\n"
"If you also have ยง11, then ยง12 is a proof of ยง13."
msgstr ""

#: Game.Levels.FamCombo
msgid "In this world we combine family unions and intersections with each other, and with complements. This level contains some of the hardest proofs in the game!"
msgstr ""

#. ยง0: `apply Iff.intro`
#: Game.Levels.Inter.L08inter_assoc
msgid "Since your goal is an \"if and only if\" statement, a good next step is ยง0."
msgstr ""

#. ยง0: `โโ F`
#. ยง1: `F`
#. ยง2: `โโ`
#. ยง3: `\\U0`
#: Game.Levels.FamUnion.L02subunion
msgid "ยง0 is the union of the family of sets ยง1.  To enter the symbol ยง2, type ยง3."
msgstr ""

#. ยง0: `compl_subset_compl_of_subset ยซ{h1}ยป`
#. ยง1: `Aแถแถ โ Bแถแถ`
#: Game.Levels.Comp.L05compsubiff
msgid "You can use ยง0 to justify the assertion ยง1."
msgstr ""

#. ยง0: `False`
#. ยง1: `have`
#. ยง2: `x โ B`
#. ยง3: `h2 : x โ B`
#: Game.Levels.Comp.L01contra
msgid "Notice that the goal is now ยง0.  To achieve that goal, you must prove contradictory statements.  You can do that by using ยง1 to assert ยง2, which will contradict ยง3."
msgstr ""

#. ยง0: `A โฉ B โช A โฉ C`
#. ยง1: `(A โฉ B) โช (A โฉ C)`
#: Game.Levels.Combo.L03inter_distrib_union
msgid "Once again, Lean has left out some parentheses that it regards as unnecessary. Lean gives intersection higher precedence than union, so it interprets ยง0 as ยง1."
msgstr ""

#: Game.Levels.FamCombo.L08singleton
msgid "Congratulations!  You have completed the Set Theory Game!\n"
"\n"
"If you want to learn more about Lean, check out the [Lean Community](https://leanprover-community.github.io)."
msgstr ""

#. ยง0: `h1 : P โ Q`
#. ยง1: `h2 : Q โ P`
#. ยง2: `Iff.intro h1 h2`
#. ยง3: `P โ Q`
#: Game.Levels.Comp.L05compsubiff
#: Game.Levels.Inter.L04proveand
msgid "If you have ยง0 and ยง1, then ยง2 is a proof of ยง3."
msgstr ""

#. ยง0: `x`
#. ยง1: `h3`
#: Game.Levels.Union.L03cases
msgid "Of course, to start a subset proof you need to introduce an object ยง0 and an assumption ยง1."
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Element of an intersection"
msgstr ""

#. ยง0: `A โฉ B = B โฉ A`
#. ยง1: `A โฉ B โ B โฉ A`
#: Game.Levels.Inter.L06inter_sub_swap
msgid "In the next level we're going to prove that intersection is commutative; that is, ยง0.  As a warm-up, in this level we prove ยง1."
msgstr ""

#. ยง0: `P`
#. ยง1: `ยฌP`
#. ยง2: `ยฌ`
#. ยง3: `\\not`
#. ยง4: `ยฌP`
#. ยง5: `P`
#. ยง6: `by_contra`
#: Game.Levels.Comp.L01contra
msgid "To work with complements, we'll need to understand negative statements--that is, statements that say that something is *not* the case.\n"
"\n"
"If ยง0 is a statement, then ยง1 means \"it is not the case that P\".  To enter the symbol ยง2, type ยง3.\n"
"\n"
"A common method of proving a negative statement is *proof by contradiction*: to prove a statement of the form ยง4, you can assume that ยง5 is true and then show that this assumption leads to a contradiction.  The tactic to use for this kind of proof is ยง6."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Subset of a union"
msgstr ""

#. ยง0: `Subset.refl`
#. ยง1: `Set.Subset.refl`
#. ยง2: `Set.`
#: Game.Levels.Subset.L05subref
msgid "The theorem you have proven in this level shows that the subset relation has a property called *reflexivity*.  We have given the theorem the name ยง0.  You will see it in the list of theorems on the right.  (This theorem is included in Lean's mathematical library, Mathlib.  In Mathlib, the name of the theorem is ยง1. Many other set-theoretic theorems in this game have ยง2 at the beginnings of their names in Mathlib.)"
msgstr ""

#. ยง0: `ยซ{ht}ยป`
#. ยง1: `have ยซ{ht}ยปl := ยซ{ht}ยป.left`
#: Game.Levels.FamUnion.L07eltwiseinter
msgid "You can separate out the first half of ยง0 with ยง1."
msgstr ""

#. ยง0: `A`
#. ยง1: `B`
#. ยง2: `A โฉ B`
#. ยง3: `A`
#. ยง4: `B`
#. ยง5: `A`
#. ยง6: `B`
#. ยง7: `{A, B}`
#. ยง8: `t`
#. ยง9: `A`
#. ยง10: `B`
#. ยง11: `mem_pair t A B`
#. ยง12: `t โ {A, B} โ t = A โจ t = B`
#: Game.Levels.FamInter.L03interpair
msgid "This level shows that family intersections are a generalization of the intersections we studied in Intersection World.  You'll prove that if ยง0 and ยง1 are sets, then ยง2 is equal to the intersection of the family of sets that contains just ยง3 and ยง4 and nothing else.\n"
"\n"
"We'll need notation for the family of sets consisting of just ยง5 and ยง6; we'll denote this family by ยง7.  And, as usual, we'll need a theorem stating the definition of this notation.  For any ยง8, ยง9, and ยง10, ยง11 is a proof of the statement ยง12."
msgstr ""

#. ยง0: `ยซ{x}ยป โ A โจ ยซ{x}ยป โ B`
#. ยง1: `ยซ{x}ยป โ A`
#. ยง2: `ยซ{x}ยป โ B`
#. ยง3: `ยซ{x}ยป โ C`
#. ยง4: `with`
#. ยง5: `rcases`
#: Game.Levels.Union.L03cases
msgid "Now you have *two* goals.  For the first, the assumption ยง0 has been replaced with ยง1, and for the second it has been replaced with ยง2.  In both cases, you must prove ยง3.  The two identifiers after ยง4 in the ยง5 tactic are used as the identifiers of the new assumptions in the two cases."
msgstr ""
