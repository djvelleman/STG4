{"level completed! ğŸ‰": "Â¡Nivel completado!",
 "level completed with warningsâ€¦ ğŸ­": "Nivel completado con advertencias... ğŸ­",
 "intermediate goal solved! ğŸ‰": "Â¡objetivo intermedio resuelto! ğŸ‰",
 "`â‹ƒâ‚€ F` is the union of the family of sets `F`.  To enter the symbol `â‹ƒâ‚€`, type `\\U0`.":
 " La expresiÃ³n `â‹ƒâ‚€ F` representa la uniÃ³n de la familia de conjuntos `F`. Para ingresar el sÃ­mbolo `â‹ƒâ‚€`, escribe `\\U0`.",
 "`â‹‚â‚€ F` is the intersection of the family of sets `F`.  To enter the symbol `â‹‚â‚€`, type `\\I0`.":
 " `â‹‚â‚€ F` es la intersecciÃ³n de la familia de conjuntos `F`. Para ingresar el sÃ­mbolo `â‹‚â‚€`, escribe `\\I0`.",
 "`Â¬P` means \\\"it is not the case that P\\\".  To enter the symbol `Â¬`,\ntype `\\not`.":
 "`Â¬P` significa \\\"no es cierto que se cumpla P\\\".  Para obtener el sÃ­mbolo `Â¬`,\nteclea `\\not`.",
 "`Â«{h3}Â» h1` is a proof of `x âˆˆ B`.": "`Â«{h3}Â» h1` es una prueba de `x âˆˆ B`.",
 "`Â«{h2}Â» Â«{t}Â» Â«{h4}Â»` is now a proof of the goal.":
 "`Â«{h2}Â» Â«{t}Â» Â«{h4}Â»` es ahora una prueba del objetivo.",
 "`x âˆˆ A` means that `x` is an element of `A`.  To enter the symbol `âˆˆ`, type\n`\\mem` or `\\in`.":
 "`x âˆˆ A` significa que `x` es un elemento de `A`.  Para introducir el sÃ­mbolo `âˆˆ`, teclea\n`\\mem` or `\\in` seguido de un espacio.",
 "`rewrite [compl_compl A] at Â«{h2}Â»` will change `Aá¶œá¶œ` to\n`A`, and `rewrite [compl_compl B] at Â«{h2}Â»` will change `Bá¶œá¶œ` to `B`.  In fact, you can do both\nrewrites in one step:  `rewrite [compl_compl A, compl_compl B] at Â«{h2}Â»`.":
 "La tÃ¡ctica `rewrite [compl_compl A] at Â«{h2}Â»` cambiarÃ¡ `Aá¶œá¶œ` por\n`A`, en la hipÃ³tesis `Â«{h2}Â»`, y el comando `rewrite [compl_compl B] at Â«{h2}Â»` cambiarÃ¡ `Bá¶œá¶œ` por\n`B`. De hecho, puedes realizar ambos cambios en un solo paso:\n`rewrite [compl_compl A, compl_compl B] at Â«{h2}Â»`.",
 "`exact And.intro h1 h2` will close the goal.":
 " `exact And.intro h1 h2` cerrarÃ¡ el objetivo.",
 "`compl_subset_compl_of_subset Â«{h1}Â»` will prove the goal.":
 "`compl_subset_compl_of_subset Â«{h1}Â»` probarÃ¡ el objetivo.",
 "`P âˆ¨ Q` means \"P or Q or both\".  To enter the symbol `âˆ¨`, type `\\or`.":
 "`P âˆ¨ Q` significa \"P o Q o ambos\". Para escribir el sÃ­mbolo `âˆ¨`, teclea `\\or`.",
 "`P âˆ§ Q` means \"P and Q\".  To enter the symbol `âˆ§`, type `\\and`.":
 "`P âˆ§ Q` significa \"P y Q\". Para escribir el sÃ­mbolo `âˆ§`, teclea `\\and`.",
 "`P â†” Q` means \"P if and only if Q\".  You can enter the symbol `â†”` by typing `\\iff`.":
 "`P â†” Q` significa \\\"P si y solo si Q\\\".  Puedes introducir el sÃ­mbolo `â†”` tecleando `\\iff`.",
 "`P â†’ Q` means \"if `P` then `Q`\".  You can enter the symbol `â†’` by typing `\\imp`.":
 "`P â†’ Q` significa \"si `P` entonces `Q`\".  Puedes introducir el sÃ­mbolo `â†’` tecleando `\\imp`.",
 "`Or.inl h` is a proof of the goal.": "`Or.inl h` es una prueba del objetivo.",
 "`Exists.intro A Â«{h}Â»` proves the goal.":
 "`Exists.intro A Â«{h}Â»` demuestra el objetivo",
 "`A âŠ† B` means that `A` is a subset of `B`.  To enter the symbol `âŠ†`,\ntype `\\sub`.":
 "`A âŠ† B` significa que `A` es un subconjunto de `B`.  Para introducir el sÃ­mbolo `âŠ†`,\nteclea `\\sub`.",
 "Your immediate goal now is to prove that `Â«{x}Â» âˆˆ B`.  Once you close that goal,\nyou'll be asked to prove the second goal, `Â«{x}Â» âˆˆ C`.":
 "Tu objetivo inmediato ahora es probar que `Â«{x}Â» âˆˆ B`. Una vez que cierres\nese objetivo, tendrÃ¡s que demostrar el segundo objetivo, `Â«{x}Â» âˆˆ C`.",
 "Your immediate goal now is to prove that `Aá¶œá¶œ âŠ† A`.  Once you close that goal,\nyou'll be asked to prove the second goal, `A âŠ† Aá¶œá¶œ`.":
 "Tu objetivo inmediato ahora es probar que `Aá¶œá¶œ âŠ† A`. Una vez que cierres ese objetivo, se te pedirÃ¡ probar el segundo objetivo, `A âŠ† Aá¶œá¶œ`.",
 "Your goal says that there is a set that is a subset of `A`.\nThe theorem `Subset.refl` suggests such a set.":
 " Tu objetivo indica que hay un conjunto que es un subconjunto de `A`.\nEl teorema `Subset.refl` sugiere tal conjunto.",
 "Your goal is an existential statement.  Do you see what value to use as a witness?":
 " Tu objetivo es un enunciado existencial. Â¿Ves quÃ© valor usar como testigo?",
 "Your goal is a subset statement.\nThat should tell you how to get started.":
 "Tu objetivo es ver un contenido. Eso deberÃ­a decirte cÃ³mo empezar.",
 "You've mastered reasoning about complements, intersections, and unions.  In the next world,\nwe'll start mixing them up!":
 " Dominaste el razonamiento sobre complementarios, intersecciones y uniones. Â¡En el prÃ³ximo mundo, empezaremos a combinarlos!",
 "You've finished Family Intersection World!  As you might guess, you can also take the union of\na family of sets.  Can you guess how to define it?  Continue on to Family Union World to see\nif your guess is right.":
 "Â¡Terminaste el mundo de las intersecciones de familias! Como probablemente hayas adivinado, tambiÃ©n puedes tomar la uniÃ³n de una familia de conjuntos. Â¿Puedes adivinar cÃ³mo definirla? ContinÃºa en el mundo de la uniÃ³n familiar para ver si aciertas.",
 "You've finished Combination World!": " Â¡Terminaste el mundo Combinado!",
 "You'll be able to use the theorem `union_subset_swap` in the next level to prove\nthat union is commutative.":
 "En el siguiente nivel podrÃ¡s utilizar el teorema `union_subset_swap` para probar que la uniÃ³n es conmutativa.",
 "You should be able to combine ideas from previous levels to solve this one.":
 "DeberÃ­as ser capaz de combinar ideas de niveles anteriores para resolver este.",
 "You probably used a step like `rewrite [mem_inter_iff] at h` in this proof.  That step is\nactually optional.  Writing out the definition of intersection probably helps *you*\nunderstand how to proceed with the proof, but *Lean* doesn't need to be told to\nwrite out the definition.  It will do that on its own.  In other words, if you\nhave `h : x âˆˆ A âˆ© B`, Lean will accept `h.left` as a proof of `x âˆˆ A`.":
 "Probablemente usaste un paso como `rewrite [mem_inter_iff] at h` en esta\nprueba. Ese paso es, de hecho, opcional. Escribir la definiciÃ³n de\nintersecciÃ³n probablemente te ayude a comprender cÃ³mo proceder con la\nprueba, pero *Lean* no necesita saber que escriba la definiciÃ³n. Lo harÃ¡ por\nsÃ­ mismo. En otras palabras, si tienes `h : x âˆˆ A âˆ© B`, Lean aceptarÃ¡`h.left` como una prueba de `x âˆˆ A`.",
 "You probably used `intro` several times in this proof.  Recall that two `intro` steps in a row\ncan be combined into one step.  Click on `intro` in the list of tactics on the right for\nfurther details.":
 " Probablemente usaste `intro` varias veces en esta prueba. Recuerda que dos pasos de `intro` consecutivos pueden combinarse en un solo paso. Haz clic en `intro` en la lista de tÃ¡cticas a la derecha para obtener mÃ¡s detalles.",
 "You need to apply `h1` to a family of sets with two\nproperties: the union of the family must be `A`, and knowing that `A` belongs to the\nfamily must help you prove that `A` is a singleton.":
 " Debes aplicar `h1` a una familia de conjuntos con dos\npropiedades: la uniÃ³n de la familia debe ser `A`, y saber que `A` pertenece a la familia debe ayudarte a probar que `A` es un singleton.",
 "You might be tempted to use `rewrite [compl_inter]` as your next step.  But\nin this situation, `rewrite [compl_inter]` is ambiguous, because there are\ntwo ways that the theorem `compl_inter` could be applied to rewrite the goal: `compl_inter B C`\nis a proof of `(B âˆ© C)á¶œ = Bá¶œ âˆª Cá¶œ` and `compl_inter Aá¶œ (B âˆ© C)á¶œ` is a proof of\n`(Aá¶œ âˆ© (B âˆ© C)á¶œ)á¶œ = Aá¶á¶œ âˆª (B âˆ© C)á¶œá¶œ`, and either one of those equations could be used to\nrewrite the goal.  If you say `rewrite [compl_inter]`, then Lean will pick one of those two\nrewriting steps, and it might not pick the one you wanted.  So you'd better say explicitly\nwhat you want Lean to apply the theorem `compl_inter` to.":
 " QuizÃ¡s puedas estar tentado a usar `rewrite [compl_inter]` como tu siguiente paso. Pero en esta situaciÃ³n, `rewrite [compl_inter]` es ambiguo, ya que hay dos maneras en que el teorema `compl_inter` podrÃ­a ser aplicado para reescribir el objetivo: `compl_inter B C` es una prueba de `(B âˆ© C)á¶œ = Bá¶œ âˆª Cá¶œ` y `compl_inter Aá¶œ (B âˆ© C)á¶œ` es una prueba de\n`(Aá¶œ âˆ© (B âˆ© C)á¶œ)á¶œ = Aá¶á¶œ âˆª (B âˆ© C)á¶œá¶œ`, y cualquiera de esas ecuaciones podrÃ­a ser utilizada para\nreescribir el objetivo. Si usas `rewrite [compl_inter]`, entonces Lean elegirÃ¡ uno de esos dos\npasos de reescritura, y puede que no elija el que querÃ­as. AsÃ­ que es mejor decir explÃ­citamente a que quieres que Lean aplique el teorema `compl_inter`.",
 "You may find it useful to separate out the right half of `Â«{h1}Â»`.\nYou can do that with `have Â«{h1}Â»r := Â«{h1}Â».right`.":
 " Puede que le resulte Ãºtil separar la mitad derecha de `Â«{h1}Â»`.\nPuede hacerlo con `have Â«{h1}Â»r := Â«{h1}Â».derecha`.",
 "You know `Â«{x}Â» âˆˆ Â«{t}Â»` and `Â«{t}Â» = A âˆ© Â«{u}Â»`.  So you can use `rewrite`\nto get `Â«{x}Â» âˆˆ A âˆ© Â«{u}Â»`.":
 " Sabes que `Â«{x}Â» âˆˆ Â«{t}Â»` y que `Â«{t}Â» = A âˆ© Â«{u}Â»`. AsÃ­ que puedes usar `rewrite` para obtener `Â«{x}Â» âˆˆ A âˆ© Â«{u}Â»`.",
 "You haven't used `Â«{h2}Â»` yet.  If you don't see how to use it,\nwrite out its definition.":
 " No has utilizado `Â«{h2}Â»` aÃºn. Si no ves cÃ³mo usarlo,\nescribe su definiciÃ³n.",
 "You can use the `have` tactic to add a new statement to your list of\nassumptions, as long as you can justify it with a proof.  For further\ninformation, click on `have` in the list of tactics on the right.":
 "\nPuedes usar la tÃ¡ctica `have` para aÃ±adir una afirmaciÃ³n a tu lista de suposiciones,\nsiempre que puedas justificarla con una demostraciÃ³n. Para mÃ¡s informaciÃ³n, pulsa en `have`\nen la lista de tÃ¡cticas a la derecha.\n",
 "You can use the `by_contra` tactic in any proof to assume the\nopposite of your goal.  But it is most useful when the goal\nstarts with the symbol `Â¬`.  After using the `by_contra` tactic,\nyour goal will be `False`.\n\nTo complete a proof by contradiction, you must prove contradictory statements.\nIf your goal is `False` and you have assumptions `h1 : P` and `h2 : Â¬P`, for\nsome statement `P`, then `exact h2 h1` will close the goal.  Note that `exact h1 h2` won't\nwork; you must list the negative statement first to establish a contradiction.":
 "\nPuedes usar la tÃ¡ctica `by_contra` en cualquier prueba para asumir lo contrario de tu objetivo.\nPero es mÃ¡s Ãºtil cuando el objetivo comienza con el sÃ­mbolo `Â¬`. DespuÃ©s de usar la tÃ¡ctica `by_contra`,\ntu objetivo serÃ¡ `False`.\n\nPara completar una prueba por contradicciÃ³n, debes demostrar afirmaciones contradictorias.\nSi tu objetivo es `False` y tienes las suposiciones `h1 : P` y `h2 : Â¬P`, para\nalguna afirmaciÃ³n `P`, entonces `exact h2 h1` cerrarÃ¡ el objetivo. Ten en cuenta que `exact h1 h2`\nno funcionarÃ¡; debes listar la afirmaciÃ³n negativa primero para establecer una contradicciÃ³n.\n",
 "You can use the `apply` tactic to work backwards from the goal.  Suppose you think that you\nwill be able to use some theorem `t` to prove the goal.  In other words, you think there\nis a proof of the goal of the form `t ?`, where the question mark needs to be replaced\nwith a proof of some statement `P` to which the theorem `t` must be applied.  The tactic\n`apply t` will then set `P` as your goal.  If `t` must be applied to more than one proof to\nestablish the goal, then `apply t` will set all of the needed proofs as goals.":
 "Puedes usar la tÃ¡ctica `apply` para trabajar hacia atrÃ¡s desde el objetivo.Supongamos que piensas que podrÃ¡s utilizar algÃºn teorema `t` para probar elobjetivo. En otras palabras, crees que hay una prueba del objetivo de la forma `t ?`, donde el signo de interrogaciÃ³n necesita ser reemplazado por una prueba de algÃºn enunciado `P` a la que se le debe aplicar el teorema `t`. La tÃ¡ctica `apply t` entonces establecerÃ¡ `P` como tu objetivo. Si `t` debe aplicarse a mÃ¡s de una prueba para establecer el objetivo, entonces `apply t` establecerÃ¡ todas las pruebas necesarias como objetivos.",
 "You can use `rewrite [mem_setOf]` to write out the meaning of the goal.":
 " Puedes usar `rewrite [mem_setOf]` para escribir el significado del objetivo.",
 "You can use `compl_subset_compl_of_subset Â«{h1}Â»` to\njustify the assertion `Aá¶œá¶œ âŠ† Bá¶œá¶œ`.":
 "Puedes usar `compl_subset_compl_of_subset Â«{h1}Â»` para justificar laafirmaciÃ³n `Aá¶œá¶œ âŠ† Bá¶œá¶œ`.",
 "You can think of `h2 : x âˆ‰ B` (which is shorthand for `h2 : Â¬x âˆˆ B`)\nas meaning \"if `x âˆˆ B` were true, then that would lead to a contradiction\"--in other\nwords, `x âˆˆ B â†’ False`.\nApplying this to your new assumption `Â«{h4}Â» : x âˆˆ B` will give the contradiction\nyou need.  In other words, `exact h2 Â«{h4}Â»` will close the goal.":
 "Puedes pensar en `h2 : x âˆ‰ B` (que es una forma abreviada de `h2 : Â¬x âˆˆ B`)\ncomo significando \"si `x âˆˆ B` fuera verdadero, eso conducirÃ­a a una contradicciÃ³n\"--dicho\nde otro modo, `x âˆˆ B â†’ False`.\nAplicar esto a tu nueva suposiciÃ³n `Â«{h4}Â» : x âˆˆ B` darÃ¡ la contradicciÃ³n\nque necesitas. En otras palabras, `exact h2 Â«{h4}Â»` cerrarÃ¡ el objetivo.",
 "You can separate out the first half of `Â«{ht}Â»` with `have Â«{ht}Â»l := Â«{ht}Â».left`.":
 " Puedes separar la primera mitad de `Â«{ht}Â»` con `have Â«{ht}Â»l := Â«{ht}Â».left`.",
 "You can now combine `Â«{h2}Â»` and `Â«{h4}Â»` to reach the goal in one step.":
 " Ahora puedes combinar `Â«{h2}Â»` y `Â«{h4}Â»` para alcanzar el objetivo en un solo paso.",
 "Writing out the meaning of the goal will make the proof easier to understand.":
 "Escribir el significado del objetivo facilitarÃ¡ la comprensiÃ³n de la prueba.",
 "Writing out the meaning of intersection in the goal will help you see what to do to\ncomplete this level.":
 "Escribir el significado de la intersecciÃ³n en el objetivo te ayudarÃ¡ a ver\nlo que tienes que hacer para completar este nivel.",
 "Writing out the definition of union in the goal should help you see how to proceed.":
 "Escribir la definiciÃ³n de uniÃ³n en el objetivo deberÃ­a ayudarte a ver cÃ³mo seguir.",
 "Writing out the definition of intersection in the goal will help.":
 "Escribir la definiciÃ³n de intersecciÃ³n en el objetivo ayudarÃ¡.",
 "Whew!": "Â¡Uf!",
 "What statement would you like to contradict to complete the proof?":
 " Â¿CuÃ¡l es el enunciado que deseas contradecir para completar la prueba?",
 "What set can you apply `Â«{h1}Â»` to?":
 " Â¿A quÃ© conjunto puedes aplicar Â«{h1}Â»?",
 "What happens if you intersect `â‹ƒâ‚€ F` with `(â‹ƒâ‚€ G)á¶œ`, for two families `F` and `G`?":
 " Â¿QuÃ© sucede si intersecas `â‹ƒâ‚€ F` con `(â‹ƒâ‚€ G)á¶œ`, para dos familias `F` y `G`?",
 "What happens if the subset statement in the last level is reversed?":
 " Â¿QuÃ© sucede si se invierte la relaciÃ³n de contenido en el Ãºltimo nivel?",
 "Well done!  You're ready to move on to Union World.":
 "Â¡Bien hecho! EstÃ¡s listo para pasar al mundo de la uniones.",
 "Welcome to Subset World! In this world you will learn about sets and\nsubsets, and you will also learn the basics of proving theorems in Lean.\n\nThe elements of the sets in this world will come from a universe called `U`.\nTo specify that an\nobject `x` belongs to the universe `U`, we write `x : U`.  To specify\nthat `A` is a set of objects from `U`, we write `A : Set U`.  (The terminology used\nin Lean is that `x` has *type* `U` and `A` has *type* `Set U`.)  To\nsay that `x` is an element of `A`, we write `x âˆˆ A`.  (You can enter\nthe symbol `âˆˆ` by typing `\\mem` or `\\in`, followed by a space.)\n\nYou will prove theorems in this game by using tools called *tactics*.\nThe aim is to prove the theorem by applying tactics\nin the right order.\n\nLet's learn some basic tactics. Click on \"Start\" below\nto get started.":
 "Â¡Bienvenido al mundo de los subconjuntos!En este mundo, aprenderÃ¡s sobre conjuntos y subconjuntos, y tambiÃ©n aprenderÃ¡s los conceptos bÃ¡sicos de cÃ³mo demostrar teoremas en Lean. Los elementos de los conjuntos en este mundo provendrÃ¡n de un universo llamado `U`.(Lean llama a `U` un *Tipo*.) Para especificar que un objeto `x` pertenece al universo `U`,escribimos `x : U`. Para especificar que `A` es un conjunto de objetos de `U`, escribimos`A : Set U`. Para decir que `x` es un elemento de `A`, escribimos `x âˆˆ A`.(Puedes ingresar el sÃ­mbolo `âˆˆ` escribiendo `\\mem` o `\\in`, seguido de un espacio).ProbarÃ¡s teoremas en este juego utilizando herramientas llamadas *tÃ¡cticas*.El objetivo es demostrar el teorema aplicando tÃ¡cticas en el orden correcto.Aprendamos algunas tÃ¡cticas bÃ¡sicas. Haz click en \\\"Start\\\" a continuaciÃ³n para empezar.",
 "We'll prove one more property of intersections in the next level.":
 "Probaremos una propiedad mÃ¡s de las intersecciones en el siguiente nivel.",
 "We have given this theorem the name `inter_subset_swap`.  Thus, from now on, for\nany sets `A` and `B`, `inter_subset_swap A B` is a proof of `A âˆ© B âŠ† B âˆ© A`.":
 "Le hemos dado a este teorema el nombre de `inter_subset_swap`. Por lo tanto, desde ahora en adelante, para cualesquiera conjuntos `A` y `B`, `inter_subset_swap A B` es una prueba de `A âˆ© B âŠ† B âˆ© A`.",
 "Use `intro` to introduce either a new assumption or a new object into your proof.\n\nThere are two situations in which you can use the `intro` tactic:\n* If you are proving a statement of the form `P â†’ Q`, then you can use\nthe tactic `intro h` to introduce the assumption `h : P` and set `Q` as the goal.  Be\nsure to use an identifier that is not already in use.\n* If you are proving a statement of the form `âˆ€ x, P x`, where `P x` is some statement\nabout `x`, then you can use the tactic `intro x` to introduce a new object `x` into the proof.\nBe sure to use a variable name that is not already in use.  The goal will then be `P x`.\n\nYou can do multiple introductions in one step: for example, `intro x h` has the same\neffect as doing `intro x` followed by `intro h`.":
 "\nUsa `intro` para introducir ya sea una nueva suposiciÃ³n o un nuevo objeto en tu prueba.\n\nHay dos situaciones en las que puedes usar la tÃ¡ctica `intro`:\n- Si estÃ¡s demostrando una afirmaciÃ³n de la forma `P â†’ Q`, entonces puedes usar\nla tÃ¡ctica `intro h` para introducir la suposiciÃ³n `h : P` y establecer `Q` como la meta. AsegÃºrate\nde usar un identificador que no estÃ© en uso.\n- Si estÃ¡s demostrando una afirmaciÃ³n de la forma `âˆ€ x, P x`, donde `P x` es una afirmaciÃ³n sobre\n`x`, entonces puedes usar la tÃ¡ctica `intro x` para introducir un nuevo objeto `x` en la prueba.\nAsegÃºrate de usar un nombre de variable que no estÃ© en uso. El objetivo pasarÃ¡ a ser `P x`.\n\nPuedes realizar mÃºltiples introducciones en un solo paso: por ejemplo, `intro x h` tiene el mismo\nefecto que realizar `intro x` seguido de `intro h`.\n",
 "Use `intro` again to introduce the assumption `Â«{x}Â» âˆˆ A`.":
 "Usa `intro` otra vez para introducir la suposiciÃ³n `Â«{x}Â» âˆˆ A`.",
 "Use `have` to assert a statement that you can prove from your current\nassumptions.  You must give the new assertion an identifier; be sure to\nuse an identifier that is different from those already in use.\n\nIf some expression `t` is a proof of a statement `P`, and `h` is an\nidentifier that is not in use, then `have h : P := t` will add `h : P`\nto the list of assumptions.\n\nThere are two variations on the `have` tactic:\n* Sometimes you want to assert a statement `P`, but the proof of `P` is too\ndifficult to be given in one line.  In that situation, you can simply write\n`have h : P`.  Of course, you must still justify the assertion of `P`, so\nthe proof of `P` becomes your immediate goal.\nOnce the goal of proving `P` has been closed, you will be able to return to\nyour original goal, with `h : P` added to the assumption list.\n* If you write `have h := t`, then Lean will try to figure out what statement\n`P` is proven by the expression `t` and, if it can figure it out, it will fill\nit in for you.":
 "\nUsa `have` para afirmar una declaraciÃ³n que puedes probar a partir de tus suposiciones actuales.\nDebes darle a la nueva afirmaciÃ³n un identificador; asegÃºrate de\nusar un identificador que sea diferente de los que ya se estÃ¡n utilizando.\n\nSi alguna expresiÃ³n `t` es una prueba de una afirmaciÃ³n `P`, y `h` es un\nidentificador que no estÃ¡ en uso, entonces `have h : P := t` agregarÃ¡ `h : P`\na la lista de suposiciones.\n\nHay dos posibles formas de usar la tÃ¡ctica `have`:\n* A veces quieres afirmar una declaraciÃ³n `P`, pero la prueba de `P` es demasiado\ndifÃ­cil para ser dada en una sola lÃ­nea. En esa situaciÃ³n, simplemente puedes escribir\n`have h : P`. Por supuesto, aÃºn debes justificar la afirmaciÃ³n de `P`, asÃ­ que\nla prueba de `P` se convierte en tu objetivo inmediato.\nUna vez que se haya cerrado el objetivo de demostrar `P`, podrÃ¡s volver a\ntu objetivo original, con `h : P` aÃ±adido a la lista de suposiciones.\n* Si escribes `h := t`, entonces Lean intentarÃ¡ deducir quÃ© afirmaciÃ³n `P` es probada por `t`, y\nsi puede hacerlo, directamente aÃ±adirÃ¡ una nueva hipÃ³tesis `h : P`.\n",
 "Use `h1`.": "Usa `h1`.",
 "Use `exact` to close a goal.  If some expression `t` is a proof of\nthe goal, then `exact t` will close the goal.\n\nThink of \"exact\" as meaning \"this is exactly what is needed to prove the goal.\"":
 "\nUtiliza `exact` para cerrar un objetivo. Si alguna expresiÃ³n `t` es una prueba del\nobjetivo, entonces `exact t` cerrarÃ¡ el objetivo.\n\nPuedes pensar que \"exact\" significa\n\"esto es exactamente lo que se necesita para demostrar el objetivo.\"",
 "Union subset of swap": "La uniÃ³n es un subconjunto de la uniÃ³n conmutada",
 "Union subset of a set": "La uniÃ³n como subconjunto de un conjunto",
 "Union of larger family is larger":
 "La uniÃ³n de una familia mÃ¡s grande es mÃ¡s grande.",
 "Union of a union": "UniÃ³n de una uniÃ³n",
 "Union of a pair": "UniÃ³n de un par",
 "Union of a family of intersections": "UniÃ³n de una familia de intersecciones",
 "Union is commutative": " La uniÃ³n es conmutativa.",
 "Union is associative": "La uniÃ³n es asociativa",
 "Union distributes over intersection":
 "Distributividad de la uniÃ³n sobre la intersecciÃ³n",
 "Union World": "Mundo de las uniones",
 "Two families with an element in common":
 "Dos familias con un elemento en comÃºn",
 "Try `apply Exists.intro (A âˆ© Â«{t}Â»)` or `use A âˆ© Â«{t}Â»`.":
 " Intenta `apply Exists.intro (A âˆ© Â«{t}Â»)` o `use A âˆ© Â«{t}Â»`.",
 "To work with unions of families, we'll need to know how to work with existential statements.\nIf `P x` is a statement about an unspecified object `x`, then `âˆƒ x, P x` means \"there is\nat least one `x` such that `P x` is true\".  The symbol `âˆƒ` is called the\n*existential quantifier*, and you can enter it in Lean by typing `\\exists`.\n\nThe easiest way to prove the statement `âˆƒ x, P x` is to specify a value of `x`, and give a\nproof of `P x` for that value of `x`.  The theorem that allows you to do that is called\n`Exists.intro`.  If you have `h : P a`, for some object `a`, then `Exists.intro a h` is a\nproof of the statement `âˆƒ x, P x`.  (The object `a` is sometimes called a *witness* for\nthe existential statement.)  In this level, you'll try out this theorem.":
 " Para trabajar con uniones de familias, necesitaremos saber cÃ³mo trabajar con enunciados existenciales.\nSi `P x` es un enunciado acerca de un objeto no especificado `x`, entonces `âˆƒ x, P x` significa \"existe al menos un `x` tal que `P x` es verdadero\". El sÃ­mbolo `âˆƒ` se llama el *cuantificador existencial*, y puedes ingresarlo en Lean escribiendo `\\exists`.\n\nLa forma mÃ¡s fÃ¡cil de probar el enunciado `âˆƒ x, P x` es especificar un valor para `x`, y dar una prueba de `P x` para ese valor de `x`. El teorema que permite hacer esto se llama `Exists.intro`. Si tienes `h : P a`, para algÃºn objeto `a`, entonces `Exists.intro a h` es una prueba del enunciado `âˆƒ x, P x`. (El objeto `a` a veces se llama un *testigo* para el enunciado existencial.) En este nivel, intentarÃ¡s probar este teorema.",
 "To work with intersections, we'll need to understand the word \"and\".\n\nIf `P` and `Q` are statements, then `P âˆ§ Q` means \"P and Q\".  To enter the\nsymbol `âˆ§`, type `\\and`.  For the statement `P âˆ§ Q` to be true, `P` and `Q` must\nboth be true.  If you have `h : P âˆ§ Q`--that is, `h` is a proof of\nthe statement `P âˆ§ Q`--then in Lean, `h.left` is a proof of `P` and `h.right` is\na proof of `Q`.  That should be all you need to know to solve this level.":
 " Para trabajar con intersecciones, necesitaremos entender la palabra \"y\".\n\nSi `P` y `Q` son enunciados, entonces `P âˆ§ Q` significa \"P y Q\". Para escribir el sÃ­mbolo `âˆ§`, teclea `\\and`. Para que la declaraciÃ³n `P âˆ§ Q` sea verdadera, tanto `P` como `Q` deben ser verdaderos. Si tienes `h : P âˆ§ Q`-- es decir, `h` es una prueba del enunciado `P âˆ§ Q`--entonces en Lean, `h.left` es una prueba de `P` y `h.right` es una prueba de `Q`. Eso deberÃ­a ser todo lo que necesitas saber para resolver este nivel.",
 "To work with complements, we'll need to understand negative statements--that is, statements\nthat say that something is *not* the case.\n\nIf `P` is a statement, then `Â¬P` means \"it is not the case that P\".  To enter the symbol\n`Â¬`, type `\\not`.\n\nA common method of proving a negative statement is *proof by\ncontradiction*: to prove a statement of the form `Â¬P`, you can assume that `P` is true\nand then show that this assumption leads to a contradiction.  The tactic to use for this\nkind of proof is `by_contra`.":
 "Para trabajar con complementos, necesitaremos entender declaraciones negativas, es decir, afirmaciones que indican que algo *no* es cierto.\n\nSi `P`  es una afirmaciÃ³n, entonces `Â¬P` significa \"no es cierto que P\". Para introducir el sÃ­mbolo `Â¬`, escribe `\\not`.\n\nUn mÃ©todo comÃºn para demostrar una afirmaciÃ³n negativa es la *prueba por contradicciÃ³n*: para demostrar una afirmaciÃ³n de la forma `Â¬P`, puedes asumir que `P` es verdadero y luego mostrar que esta suposiciÃ³n conduce a una contradicciÃ³n. La tÃ¡ctica a utilizar para este tipo de prueba es `by_contra`.",
 "To understand the logic of this proof, it will help to write out the definition\nof union in `Â«{h3}Â»`.":
 "Para entender la lÃ³gica de esta prueba, ayudarÃ¡ escribir la definiciÃ³n de uniÃ³n en Â«{h3}Â».",
 "To start on this proof, try writing out the meaning of intersection in `h`.":
 "Para empezar con esta prueba, intenta escribir el significado de intersecciÃ³n en `h`.",
 "To start a proof, you should look first at the goal.\nWhat needs to be done to prove the goal?\nIn this level, the goal is `A âŠ† C`.  What does that\ntell you about how to proceed?":
 "Para empezar una demostraciÃ³n, empieza mirando el objetivo.Â¿QuÃ© necesitas hacer para demostrar el objetivo?En este nivel, el objetivo es `A âŠ† C`.  Â¿QuÃ© te dice eso sobre los pasos a dar?",
 "To make use of `Â«{h3}Â»`, you'll need to assert `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`.  If you don't see\nright away how to justify this assertion, you can just write `have Â«{h3}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`\nand Lean will set `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` as your immediate goal.  Once you achieve that goal,\nLean will add `Â«{h3}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` to your list of assumptions, and you can continue\nwith the proof of your original goal.  For further details, click on `have` in the list of tactics\non the right.":
 " Para usar `Â«{h3}Â»`, necesitarÃ¡s afirmar `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`. Si no ves de inmediato cÃ³mo justificar esta afirmaciÃ³n, puedes simplemente escribir `have Â«{h3}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` y Lean establecerÃ¡ `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` como tu objetivo inmediato. Una vez que logres ese objetivo, Lean agregarÃ¡ `Â«{h3}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` a tu lista de suposiciones y podrÃ¡s continuar con la prueba de tu objetivo original. Para obtener mÃ¡s detalles, haz clic en `have` en la lista de tÃ¡cticas a la derecha.",
 "To make use of `Â«{h2}Â»`, you'll need to assert `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`.  If you don't see\nright away how to justify this assertion, you can just write `have Â«{h2}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`\nand Lean will set `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` as your immediate goal.  Once you achieve that goal,\nLean will add `Â«{h2}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` to your list of assumptions, and you can continue\nwith the proof of your original goal.  For further details, click on `have` in the list of tactics\non the right.":
 " Para usar `Â«{h2}Â»`, necesitarÃ¡s probar `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`. Si no ves de inmediato cÃ³mo justificar esta afirmaciÃ³n, puedes escribir `have Â«{h2}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`\ny Lean establecerÃ¡ `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` como tu objetivo inmediato. Una vez que hayas logrado ese objetivo,\nLean agregarÃ¡ `Â«{h2}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` a tu lista de suposiciones y podrÃ¡s continuar\ncon la prueba de tu objetivo original. Para obtener mÃ¡s detalles, haz clic en `have` en la lista de tÃ¡cticas\na la derecha.",
 "To get started, you'll need to introduce first\nan object `x` and then the assumption that `x âˆˆ A`.":
 "Para empezar, hay que introducir un objeto `x` y la hipÃ³tesis de que `x âˆˆ A`.",
 "To get started on this proof, type `have h4 : x âˆˆ B := h1 h3`\nin the text box and click \"Execute\" or hit \"Return\" or \"Enter\".\nRecall that you can enter the symbol `âˆˆ` by typing `\\mem` or `\\in`.":
 "Para iniciar esta prueba, teclea `have h4 : x âˆˆ B := h1 h3`\n  en la caja de texto y pulsa \"Execute\" o la tecla \"Return\" o \"Enter\".\n  Recuerda que puedes introducir el sÃ­mbolo `âˆˆ` tecleando `\\mem` or `\\in`.",
 "To finish off Combination World, we'll do one more tricky theorem.":
 " Para terminar el mundo combinado, haremos un Ãºltimo teorema algo mÃ¡s difÃ­cil.",
 "This time we'll study the intersection of `(â‹ƒâ‚€ F)` and `(â‹‚â‚€ G)á¶œ`.":
 " Esta vez estudiaremos la intersecciÃ³n de `(â‹ƒâ‚€ F)` y `(â‹‚â‚€ G)á¶œ`.",
 "This should remind you of the first level of this world.  To get a contradiction,\ntry to contradict `Â«{h2}Â» : Â«{x}Â» âˆ‰ B`.":
 "Esto deberÃ­a recordarte el primer nivel de este mundo. Para obtener una\n  contradicciÃ³n, intenta contradecir `Â«{h2}Â» : Â«{x}Â» âˆ‰ B`.",
 "This proof is longer than previous ones, but it doesn't require any new tactics or theorems.\nJust stick with it and keep applying the ideas from previous levels!":
 "Esta comprobaciÃ³n es mÃ¡s larga que las anteriores, pero no requiere ninguna nueva tÃ¡ctica o teorema. Solo sigue adelante y sigue aplicando las ideas de niveles anteriores.",
 "This proof is a bit tricky.  But you should know how to get started.":
 "Esta prueba es un poco difÃ­cil. Pero deberÃ­as saber como empezar.",
 "This level shows that family intersections are a generalization of the intersections\nwe studied in Intersection World.  You'll prove that if `A` and `B` are sets, then\n`A âˆ© B` is equal to the intersection of the family of sets that contains just `A` and\n`B` and nothing else.\n\nWe'll need notation for the family of sets consisting of just `A` and `B`; we'll denote\nthis family by `{A, B}`.  And, as usual, we'll need a theorem stating the definition of\nthis notation.  For any `t`, `A`, and `B`, `mem_pair t A B` is a proof of the\nstatement `t âˆˆ {A, B} â†” t = A âˆ¨ t = B`.":
 " Este nivel muestra que las intersecciones de familias son una generalizaciÃ³n de las intersecciones\nque estudiamos en el mundo de las intersecciones. Vas a probar que si `A` y `B` son conjuntos, entonces\n`A âˆ© B` es igual a la intersecciÃ³n de la familia de conjuntos que contiene solo `A` y\n`B` y nada mÃ¡s.\n\nNecesitaremos notaciÃ³n para la familia de conjuntos consistente solo en `A` y `B`; denotaremos\na esta familia por `{A, B}`. Y, como de costumbre, necesitaremos un teorema que establezca\nla definiciÃ³n de esta notaciÃ³n. Para cualquier `t`, `A`, y `B`, `mem_pair t A B` es una\ndemostraciÃ³n del enunciado `t âˆˆ {A, B} â†” t = A âˆ¨ t = B`.",
 "This level is an exercise in handling sequences of quantifiers that alternate between\n`âˆ€` and `âˆƒ`.  A good way to start is to decide which assumption to use first.":
 " Este nivel es un ejercicio para manejar secuencias de cantidades que alternan entre\n`âˆ€` y `âˆƒ`. Una buena forma de empezar es decidir quÃ© suposiciÃ³n utilizar primero.",
 "This is different from the previous theorem--the roles of union and intersection have\nbeen swapped.\n\nOnce again, there is a tricky shortcut: there is a way to use the theorem from the\nprevious level to prove this theorem.\n\nBut if you don't see the shortcut, you can use a straightforward approach.\nIf you made it through the last one, you can do this one too!":
 "Esto es diferente del teorema anterior, se han intercambiado los papeles de la uniÃ³n y la intersecciÃ³n.\n\nDe nuevo, hay un truco: hay una manera de usar el teorema del nivel anterior para probar este teorema.\n\nPero si no ves el atajo, puedes usar un enfoque directo. Si lograste hacerlo con el Ãºltimo, tambiÃ©n puedes hacerlo con este.",
 "This example is a better illustration of how the `exact` tactic is usually\nused.  Often `exact` is followed by an expression that combines assumptions\nto prove the goal.  In later levels, we will see other ways in which\nassumptions can be combined to prove a goal.\n\nNote that in this proof, `h1` could be thought of as a function that can be\napplied to a proof of any statement of the form `x âˆˆ A` to produce a proof\nof `x âˆˆ B`.  Many proofs in Lean behave like functions.":
 "\nEste ejemplo ilustra mejor cÃ³mo se usa normalmente la tÃ¡ctica `exact`.\nA menudo, `exact` va seguido de una expresiÃ³n que combina hipÃ³tesis para demostrar el objetivo.\nEn niveles posteriores, veremos otras formas en las que las hipÃ³tesis se pueden combinar para\ndemostrar un objetivo.\n\nObserva que en esta prueba, `h1` podrÃ­a pensarse como una funciÃ³n que se puede\naplicar a una prueba de cualquier afirmaciÃ³n de la forma `x âˆˆ A` para producir una prueba\nde `x âˆˆ B`. Muchas pruebas en Lean se comportan como funciones.\n",
 "There is more than one way to do the proof in this level.  Since the proof involves complements of\nsets, negative statements will arise in the course of the proof.  This suggests two possible techniques.\nYou may be able to use the `push_neg` tactic to reexpress some negative statements as equivalent\npositive statements.  And you may find proof by contradiction useful.":
 " Existe mÃ¡s de una forma de realizar la prueba en este nivel. Dado que la prueba implica\ncomplementarios de conjuntos, aparecerÃ¡n enunciados negativos durante el curso de la prueba.\nEsto sugiere dos posibles tÃ©cnicas.\nSe puede usar la tÃ¡ctica `push_neg` para reexpresar algunos enunciados negativos como equivalentes positivos.\nO se puede usar encontrar la prueba por contradicciÃ³n.",
 "There is another tactic you could have used to complete this proof.  Instead of\n`apply Exists.intro A`, you could write `use A`.  The `use` tactic is actually a powerful\ntactic.  Not only does it fill in `A` for `t` in the existential goal, it then tries to\ncomplete the proof on its own--and in this case, it would have succeeded!":
 " Hay otra tÃ¡ctica que podrÃ­as haber utilizado para completar esta prueba. En lugar de\n`apply Exists.intro A`, podrÃ­as escribir `use A`. La tÃ¡ctica `use` es una tÃ¡ctica muy potente. No solo sustituye `A` como `t` en el objetivo existencial, sino que luego intenta completar la prueba por su cuenta y, en este caso, habrÃ­a tenido Ã©xito!",
 "There are two ways to complete the proof now.  Since your goal is a negative statement,\none natural strategy to use would be proof by contradiction.  A second possibility is to\nimitate the approach in the first half: write out the meaning of complement again in the goal,\nand then use the `push_neg` tactic to simplify the resulting double-negative goal.  Either\napproach will work.":
 "Hay dos formas de completar la prueba ahora. Dado que tu objetivo es un enunciado negativo, una estrategia natural que puedes usar serÃ­a la prueba por contradicciÃ³n. Una segunda posibilidad es imitar el enfoque en la primera mitad: escribe de nuevo el significado del complementario en el objetivo y luego utiliza la tÃ¡ctica `push_neg` para simplificar la doble negaciÃ³n resultante. Cualquiera de los dos enfoques funcionarÃ¡.",
 "The theorem you have proven in this level shows that the subset relation has\na property called *transitivity*.  We have given the theorem the name `Subset.trans`.":
 "El teorema que has demostrado en este nivel dice que la relaciÃ³n de contenido tiene una propiedad llamada *transitividad*. Hemos llamado a este teorema `Subset.trans`.",
 "The theorem you have proven in this level shows that the subset relation has\na property called *reflexivity*.  We have given the theorem the name `Subset.refl`.  You\nwill see it in the list of theorems on the right.  (This theorem is included in Lean's\nmathematical library, Mathlib.  In Mathlib, the name of the theorem is `Set.Subset.refl`.\nMany other set-theoretic theorems in this game have `Set.` at the beginnings of their names\nin Mathlib.)":
 "\nEl teorema que has demostrado en este nivel muestra que la relaciÃ³n de ser subconjunto tiene\nuna propiedad llamada *reflexividad*. Hemos dado al teorema el nombre `sub_ref`.\nLo verÃ¡s en la lista de teoremas a la derecha. \n (Este teorema estÃ¡ incluido en la biblioteca matemÃ¡tica de Lean, *Mathlib*. \nEn Mathlib, el nombre de este teorema es  `Set.Subset.refl`.Otros muchos teoremas sobre teorÃ­a de conjuntos de este juego estÃ¡n en Mathlib con nombres que empiezan por `Set.`).",
 "The theorem `compl_subset_compl_of_subset Â«{h1}Â»` doesn't prove the goal,\nbut it comes close.  Do you see what assertion it will justify?":
 "El enunciado `compl_subset_compl_of_subset Â«{h1}Â»` no demuestra el\nobjetivo, pero se acerca mucho. Â¿Ves quÃ© afirmaciÃ³n justificarÃ¡?",
 "The tactic `by_cases h : P` breaks the proof into two cases.  In the first case, the\nassumption `h : P` is added to the list of assumptions, and in the second case, the\nassumption `h : Â¬P` is added.":
 "La tÃ¡ctica `by_cases h : P` divide la prueba en dos casos. En el primer caso, se aÃ±ade la suposiciÃ³n `h : P` a la lista de suposiciones y en el segundo caso, se aÃ±ade la suposiciÃ³n `h : Â¬P`.",
 "The situation now should remind you of your first proof, in level 1 of this world.":
 "La situaciÃ³n ahora deberÃ­a recordarte a tu primera demostraciÃ³n, en el nivel 1 de este mundo.",
 "The second goal is similar, but a little trickier.":
 "El segundo objetivo es similar, pero un poquito mÃ¡s difÃ­cil.",
 "The proof of the theorem in this level is very easy.\nSince `x âˆˆ Aá¶œ` and `x âˆ‰ A` are definitionally equivalent, `rfl` will close the goal.":
 "La demostraciÃ³n en este nivel es muy fÃ¡cil.\n  Como `x âˆˆ Aá¶œ` y `x âˆ‰ A` son iguales por definiciÃ³n, `rfl` cerrarÃ¡ el objetivo.",
 "The proof of the second goal is similar.":
 "La prueba del segundo objetivo es similar.",
 "The proof in this level illustrates how previously proven theorems can be used in proofs.\n\nThere is another tactic you can use if your goal has the form `P â†” Q`.  In this situation,\nthe tactic `constructor` will have the same effect as `apply Iff.intro`; that is, it will\nset `P â†’ Q` and `Q â†’ P` as goals to be proven.":
 "La prueba en este nivel ilustra cÃ³mo se pueden utilizar en una prueba teoremas previamente demostrados.\n\nExiste otra tÃ¡ctica que puedes usar si tu objetivo tiene la forma `P â†” Q`. En esta situaciÃ³n,\nla tÃ¡ctica `constructor` tendrÃ¡ el mismo efecto que `apply Iff.intro`; es decir, establecerÃ¡ `P â†’ Q` y `Q â†’ P` como objetivos a ser probados.",
 "The notation `{a}` denotes a set whose only element is `a`; such a set is called a *singleton*\nset.  The theorem `mem_singleton_iff` expresses the definition of singleton sets: `mem_singleton_iff` is\na proof of any statement of the form `x âˆˆ {a} â†” x = a`.":
 " La notaciÃ³n `{a}` denota un conjunto cuyo Ãºnico elemento es `a`; un conjunto de este tipo se llama *singleton*. El teorema `mem_singleton_iff` expresa la definiciÃ³n de conjuntos singleton: `mem_singleton_iff` es\nuna prueba de cualquier enunciado de la forma `x âˆˆ {a} â†” x = a`.",
 "The name of the tactic `rfl` is short for \"reflexivity\", which is the property of\nboth `=` and `â†”` that is the basis for the tactic.\n\nWe have given the theorem proven in this level the name `mem_compl_iff`.  In the next level,\nwe will see how we can use it to prove theorems about complements.":
 "Hemos llamado al teorema demostrado en este nivel `comp_def`, porque expresa la definiciÃ³n\ndel complementario. En el siguiente nivel veremos cÃ³mo usarlo para demostrar teoremas sobre\ncomplementarios.",
 "The last two steps could have been combined into one step.  In general, if you have\n`h1 : A âˆˆ F` and `h2 : âˆ€ t âˆˆ F, P t`, where `P t` is some statement about `t`, then `h2 A`\nis a proof of `A âˆˆ F â†’ P A`, and\napplying that proof to `h1` we conclude that `h2 A h1` is a proof of `P A`.  For example,\nif you have `h1 : A âˆˆ F` and `h2 : âˆ€ t âˆˆ F, x âˆˆ t`, then `h2 A h1` is a proof of `x âˆˆ A`.":
 " Los Ãºltimos dos pasos podrÃ­an haberse combinado en un solo paso. En general, si tienes\n`h1 : A âˆˆ F` y `h2 : âˆ€ t âˆˆ F, P t`, donde `P t` es algÃºn enunciado sobre `t`, entonces `h2 A`\nes una prueba de `A âˆˆ F â†’ P A`, y\naplicando esa prueba a `h1` concluimos que `h2 A h1` es una prueba de `P A`. Por ejemplo,\nsi tienes `h1 : A âˆˆ F` y `h2 : âˆ€ t âˆˆ F, x âˆˆ t`, entonces `h2 A h1` es una prueba de `x âˆˆ A`.",
 "The have tactic": "La tÃ¡ctica have",
 "The form of the assumption `Â«{h}Â»` now suggests proof by cases.":
 "El aspecto de la hipÃ³tesis `Â«{h}Â»` ahora sugiere prueba por casos.",
 "The first case is the easy one.": " El primer caso es el fÃ¡cil.",
 "The exact tactic": "La tÃ¡ctica exact",
 "The assumption `Â«{h2}Â»` is now an existential statement.  Thus, `obtain âŸ¨s, hsâŸ© := Â«{h2}Â»`\nwill introduce a new object `s` and a new assumption `hs : s âˆˆ F âˆ§ Â«{x}Â» âˆˆ s` into the proof.\nOnce the witness `s` has been introduced, the assumption `Â«{h2}Â»` becomes redundant, so it is\ndeleted.":
 " La suposiciÃ³n Â«{h2}Â» ahora es un enunciado existencial. Por lo tanto, `obtain âŸ¨s, hsâŸ© := Â«{h2}Â»`\nintroducirÃ¡ un nuevo objeto `s` y una nueva hipÃ³tesis `hs : s âˆˆ F âˆ§ Â«{x}Â» âˆˆ s` en la prueba.\nUna vez que se ha introducido el testigo `s`, la suposiciÃ³n Â«{h2}Â» se vuelve redundante, por lo que se elimina.",
 "The assumption `Â«{h1}Â»` now says `Â«{x}Â» âˆ‰ Aá¶œ`, which means `Â¬Â«{x}Â» âˆˆ Aá¶œ`.  It will be helpful to\nwrite out the definition of complement again in this assumption.":
 "La suposiciÃ³n `Â«{h1}Â»` ahora dice `Â«{x}Â» âˆ‰ Aá¶œ`, lo que significa `Â¬Â«{x}Â» âˆˆ Aá¶œ`. SerÃ­a Ãºtil escribir de nuevo la definiciÃ³n del complemento en esta suposiciÃ³n.",
 "The `rewrite` tactic is smart enough to figure out some things on its own.  If you\nhad just written `rewrite [mem_compl_iff]`, then Lean would have figured out how to apply the\ntheorem `mem_compl_iff` to get an equivalence that could be used to make a replacement in the goal.\nIn other words, it would have figured out that the theorem `mem_compl_iff` had to be applied to\n`A` and `Â«{x}Â»`.\n\nSimilarly, you can write `rewrite [mem_compl_iff] at Â«{h2}Â»` to write out the meaning of `Â«{h2}Â»`.  Lean\nwill figure out that in this case, `mem_compl_iff` has to be applied to `B` and `Â«{x}Â»`.":
 "La tÃ¡ctica `rewrite` es suficientemente inteligente para deducir algunas cosas por sÃ­ misma.\n  Si hubieras escrito solamente `rewrite [mem_compl_iff]`, Lean habrÃ­a deducido como aplicar el teorema\n  `mem_compl_iff` para obtener una equivalencia que pueda usarse para hacer una reescritura en el objetivo.\n  En otras palabras, habrÃ­a deducido que el teorema `mem_compl_iff` tenÃ­a que aplicarse a `A` y `Â«{x}Â»`.\n\n  AnÃ¡logamente, puedes escribir  `rewrite [mem_compl_iff] at Â«{h2}Â»` para reescribir el significado deÂ«{h2}Â»`.\n  Lean deducirÃ¡ que, en ese caso,  `mem_compl_iff`  se tiene que aplicar a `B` y `Â«{x}Â»`.",
 "The `rewrite` tactic is often useful for writing out definitions.  For more information about\nhow it works, click on `rewrite` in the list of tactics on the right.  You can also use `rw`\ninstead of `rewrite`.  (There is actually a small difference between the tactics `rw` and\n`rewrite`, but the difference won't concern us in this game.)\n\nYou'll find the theorem you proved in this level listed as `compl_subset_compl_of_subset` in the list of\ntheorems on the right.  This theorem will be useful in the last level of this world.":
 "\nLa tÃ¡ctica `rewrite` es Ãºtil a menudo para reescribir definiciones. Para obtener mÃ¡s informaciÃ³n\nsobre cÃ³mo funciona, pulsa en `rewrite` en la lista de tÃ¡cticas a la derecha. TambiÃ©n puedes usar\n`rw` en lugar de `rewrite`. (De hecho, hay una pequeÃ±a diferencia entre las tÃ¡cticas `rw` y `rewrite`,\npero esa diferencia no nos preocuparÃ¡ en este juego).\n\nEncontrarÃ¡s el teorema que demostraste en este nivel listado como  `compl_subset_compl_of_subset` en la lista de\nteoremas a la derecha. Este teorema serÃ¡ Ãºtil en el Ãºltimo nivel de este mundo.\n",
 "The `push_neg` tactic can reexpress a number of different kinds of negative statements as\nequivalent positive statements; use\n`push_neg` to reexpress a negative goal, and `push_neg at h` to reexpress a negative assumption `h`.\nWe'll see many more uses of the `apply` tactic in this game.\nFor more details about the use of these tactics,\nclick on `push_neg` or `apply` under the list of tactics on the right.\n\nWe have given this theorem the name `compl_compl`.  Both this theorem and the one in the previous\nlevel will be useful in the next level.":
 "La tÃ¡ctica `push_neg` puede reexpresar distintas declaraciones negativas como positivas; usa\n`push_neg` para reexpresar un objetivo negativo, y `push_neg at h` para reexpresar una suposiciÃ³n negativa `h`.\nVeremos muchos mÃ¡s usos de la tÃ¡ctica `apply` en este juego.\nPara obtener mÃ¡s detalles sobre el uso de estas tÃ¡cticas,\nhaz click en `push_neg` o `apply` bajo la lista de tÃ¡cticas a la derecha.\n\nHemos dado a este teorema el nombre `compl_compl`. Tanto este teorema como el del nivel anterior serÃ¡n Ãºtiles en el siguiente nivel.",
 "Suppose that for every $s \\in F$ there is some $u \\in G$ such that $s \\cap u \\in H$.\nThen $(\\bigcup F) \\cap (\\bigcap G) \\subseteq \\bigcup H$.":
 " Supongamos que para cada $s \\in F$ hay algÃºn $u \\in G$ tal que $s \\cap u \\in H$.\nEntonces $(\\bigcup F) \\cap (\\bigcap G) \\subseteq \\bigcup H$.",
 "Suppose `A` is a set and `F` is a family of sets.  In this level you'll determine the conditions\nunder which `â‹ƒâ‚€ F` is a subset of `A`.":
 " Supongamos que `A` es un conjunto y que `F` es una familia de conjuntos. En este nivel, determinarÃ¡s las condiciones bajo las cuales `â‹ƒâ‚€ F` es un subconjunto de `A`.",
 "Suppose $x \\in A$, and $B$ is any set.  Then $x \\in A âˆ¨ x âˆˆ B$.":
 "Supongamos que $x \\in A$, y $B$ es cualquier conjunto. Entonces, $x \\in A âˆ¨ x \\in B$.",
 "Suppose $x \\in A$ and $x \\notin B$.  Then $\\neg A \\subseteq B$.":
 "Supongamos que $x \\in A$ y $x \\notin B$.  Entonces $\\neg A \\subseteq B$.",
 "Suppose $x \\in A$ and $x \\in B$.  Then $x \\in A$.":
 "Supongamos que $x \\in A$ y $x \\in B$. Entonces $x \\in A$.",
 "Suppose $x \\in A$ and $x \\in B$.  Then $x \\in A \\cap B$.":
 "SupÃ³n que $x \\in A$ y $x \\in B$.  Entonces $x \\in A \\cap B$.",
 "Suppose $x \\in A âˆ© B$.  Then $x \\in B$.":
 "Supongamos que $x \\in A \\cap B$. Entonces $x \\in B$.",
 "Suppose $F$ is a family of sets and $A \\in F$.  Then $\\bigcap F \\subseteq A$.":
 "Supongamos que $F$ es una familia de conjuntos y $A \\in F$. Entonces $\\bigcap F \\subseteq A$.",
 "Suppose $F$ is a family of sets and $A \\in F$.  Then $A \\subseteq \\bigcup F$.":
 " Supongamos que $F$ es una familia de conjuntos y $A \\in F$. Entonces, $A \\subseteq \\bigcup F$.",
 "Suppose $F$ and $G$ are families of sets.  Then $\\bigcup (F \\cup G) =\n(\\bigcup F) \\cup (\\bigcup G)$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos. Entonces, $ \\bigcup (F \\cup G) = (\\bigcup F) \\cup (\\bigcup G)$.",
 "Suppose $F$ and $G$ are families of sets.  Then $(\\bigcup F) \\cap (\\bigcup G)^c \\subseteq\n\\bigcup (F \\cap G^c)$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos. Entonces $(\\bigcup F) \\cap (\\bigcup G)^c \\subseteq\n\\bigcup (F \\cap G^c)$.",
 "Suppose $F$ and $G$ are families of sets.  Then $(\\bigcup F) \\cap (\\bigcap G)^c \\subseteq\n\\bigcup \\{s \\mid \\exists u \\in F, \\exists v \\in G, s = u \\cap v^c\\}$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos. Entonces $(\\bigcup F ) \\cap ( \\bigcap G )^c \\subseteq \\bigcup \\{s \\mid \\exists u \\in F, \\exists v \\in G, s = u \\cap v^c\\}$.",
 "Suppose $F$ and $G$ are families of sets.  Then\n$\\bigcap (F \\cup G) = (\\bigcap F) \\cap (\\bigcap G)$.":
 "Supongamos que $F$ y $G$ son familias de conjuntos. Entonces\n$\\bigcap (F \\cup G) = (\\bigcap F) \\cap (\\bigcap G)$.",
 "Suppose $F$ and $G$ are families of sets such that for every $s \\in F$ there is some $t \\in G$\nsuch that $s \\subseteq t$, and also there is some $s \\in F$ such that for every $t \\in G$,\n$t \\subseteq s$.  Then $F$ and $G$ have an element in common.":
 " Supongamos que $F$ y $G$ son familias de conjuntos tal que para cada $s \\in F$ hay algÃºn $t \\in G$\ntal que $s \\subseteq t$, y tambiÃ©n hay algÃºn $s \\in F$ tal que para cada $t \\in G$,\n$t \\subseteq s$. Entonces, $F$ y $G$ tienen un elemento en comÃºn.",
 "Suppose $F$ and $G$ are families of sets and $\\bigcup (F \\cap G^c) \\subseteq (\\bigcup F)\n\\cap (\\bigcup G)^c$.  Then $(\\bigcup F) \\cap (\\bigcup G) \\subseteq \\bigcup (F \\cap G)$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos y $\\bigcup (F \\cap G^c) \\subseteq (\\bigcup F) \\cap (\\bigcup G)^c$. Entonces $(\\bigcup F) \\cap (\\bigcup G) \\subseteq \\bigcup (F \\cap G)$.",
 "Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\nThen $\\bigcup F \\subseteq \\bigcup G$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos y $F \\subseteq G$.\nEntonces $\\bigcup F \\subseteq \\bigcup G$.",
 "Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\nThen $\\bigcap G \\subseteq \\bigcap F$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos y $F \\subseteq G$.\nEntonces $\\bigcap G \\subseteq \\bigcap F $.",
 "Suppose $A$ is a set.  Then there is some set $S$ such that $S \\subseteq A$.":
 " Supongamos que $A$ es un conjunto. Entonces hay algÃºn conjunto $S$ tal que $S \\subseteq A$.",
 "Suppose $A$ is a set.  Then $(A^c)^c = A$.":
 "Supongamos que $A$ es un conjunto. Entonces $(A^c)^c = A$.",
 "Suppose $A$ is a set, and for every family of sets $F$, if $\\bigcup F = A$ then $A \\in F$.\nThen $A$ must be a singleton set.":
 " Supongamos que $A$ es un conjunto y para cada familia de conjuntos $F$, si $\\bigcup F = A$ entonces $A \\in F$.\nEntonces, $A$ debe ser un conjunto de un solo elemento.",
 "Suppose $A$ is a set, $F$ and $G$ are families of sets, and for every set $s$ in $F$,\n$A \\cup s \\in G$.  Then $\\bigcap G \\subseteq A \\cup (\\bigcap F)$.":
 " Supongamos que $A$ es un conjunto, y $F$ y $G$ son familias de conjuntos, y para cada conjunto $s$ en $F$,\n$A \\cup s \\in G$.  Entonces $\\bigcap G \\subseteq A \\cup (\\bigcap F)$.",
 "Suppose $A$ is a set and $F$ is a family of sets.  Then $\\bigcup F$ is a subset of $A$\nif and only if every element of $F$ is a subset of $A$.":
 " Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos. Entonces $bigcup F$ es un subconjunto de $A$\nsi y solo si cada elemento de $F$ es un subconjunto de $A$.",
 "Suppose $A$ is a set and $F$ is a family of sets.  Then $A$ is a subset of $\\bigcap F$ if\nand only if $A$ is a subset of every element of $F$.":
 " Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos. Entonces, $A$ es un subconjunto de $\\bigcap F$ si y solo si $A$ es un subconjunto de cada elemento de $F$.",
 "Suppose $A$ is a set and $F$ is a family of sets.  Then $A \\cap (\\bigcup F) =\n\\bigcup\\{s \\mid \\exists u \\in F, s = A \\cap u\\}$.":
 " Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos. Entonces $A \\cap (\\bigcup F) =\n\\bigcup\\{s \\mid \\exists u \\in F, s = A \\cap u\\}$.",
 "Suppose $A$ and $B$ are sets.  Then $B \\subseteq A \\cup B$.":
 "Supongamos que $A$ y $B$ son conjuntos. Entonces $B \\subseteq A \\cup B$.",
 "Suppose $A$ and $B$ are sets.  Then $A \\subseteq B$ if and only if $B^c \\subseteq A^c$.":
 "SupÃ³n que `A` y `B` son conjuntos. Entonces `A` âŠ† `B` si y solo si $B^c \\subseteq A^c$.",
 "Suppose $A$ and $B$ are sets.  Then $A \\cup B = \\bigcup \\{A, B\\}$.":
 " Supongamos que $A$ y $B$ son conjuntos. Entonces $A \\cup B = \\bigcup \\{A, B\\}$.",
 "Suppose $A$ and $B$ are sets.  Then $A \\cap B = \\bigcap \\{A, B\\}$.":
 " Supongamos que $A$ y $B$ son conjuntos. Entonces $A \\cap B = \\bigcap \\{A, B\\}$.",
 "Suppose $A$ and $B$ are sets, $A \\subseteq B$, and $x \\in A$.\nThen $x \\in B$.":
 "SupÃ³n que $A$ y $B$ son conjuntos, $A \\subseteq B$, y $x \\in A$.\nEntonces $x \\in B$.",
 "Suppose $A \\subseteq C$ and $B \\subseteq C$.  Then $A \\cup B \\subseteq C$.":
 " Supongamos que $A \\subseteq C$ y $B \\subseteq C$.  Entonces $A \\cup B \\subseteq C$.",
 "Suppose $A \\subseteq B$.  Then $B^c \\subseteq A^c$.":
 "Supongamos $A \\subseteq B$.  Entonces $B^c \\subseteq A^c$.",
 "Suppose $A \\subseteq B$, $B \\subseteq C$, and $x \\in A$.  Then $x \\in C$.":
 "SupÃ³n que $A \\subseteq B$, $B \\subseteq C$, y $x \\in A$.  Entonces $x \\in C$.",
 "Suppose $A \\subseteq B$ and $B \\subseteq C$.  Then $A \\subseteq C$.":
 "Sea $A \\subseteq B$ y $B \\subseteq C$.  Entonces $A \\subseteq C$.",
 "Suppose $A \\subseteq B$ and $A \\subseteq C$.  Then $A \\subseteq B \\cap C$.":
 "SupÃ³n que $A \\subseteq B$ y $A \\subseteq C$. Entonces $A \\subseteq B\\cap C$.",
 "Suppose $A \\cup C \\subseteq B \\cup C$ and $A \\cap C \\subseteq B \\cap C$.  Then $A \\subseteq B$.":
 "Suponga que `A âˆª C âŠ† B âˆª C` y `A âˆ© C âŠ† B âˆ© C`. Entonces `A âŠ† B`.",
 "Subset of family union": "Subconjuntos de la intersecciÃ³n de una familia",
 "Subset of an intersection": "Subconjuntos de una intersecciÃ³n",
 "Subset of a union": "Subconjunto de una uniÃ³n",
 "Subset is transitive": "La relaciÃ³n de contenido es transitiva.",
 "Subset is reflexive": "La relaciÃ³n de contenido es reflexiva",
 "Subset World": "Mundo de los subconjuntos",
 "Start with `have h2 := h1 {s | ...}`.  The hard part is figuring out\nhow to fill in the `...`.":
 " Comienza con `h2 := h1 {s | ...}`. La parte difÃ­cil es descubrir cÃ³mo llenar el `...`.",
 "So far the elements of all of our sets have been objects in the universe `U`.  But\nsets can contain other kinds of objects!  In the next two worlds, we will work with sets whose\nelements are *sets of objects from `U`*.  We will call these *families of sets* from `U`.  To\nindicate that `F` is a family of sets from `U`, we write `F : Set (Set U)`.\n\nFor example, suppose `U` contains the people in a certain club, and we want to form a committee\nconsisting of five members of the club.  The set of all possible committees is a family\nof sets from `U`.  Each element of this family is a set containing five club members.\n\nFamilies of sets are sets, and everything you've learned about sets applies to families of sets.\nFor example, if you have `F G : Set (Set U)` and `S : Set U`, then `mem_inter_iff S F G` is a proof\nof the statement `S âˆˆ F âˆ© G â†” S âˆˆ F âˆ§ S âˆˆ G`.  Similarly, `mem_union S F G` is a proof of\n`S âˆˆ F âˆª G â†” S âˆˆ F âˆ¨ S âˆˆ G`, and `mem_compl_iff F S` is a proof of `S âˆˆ Fá¶œ â†” S âˆ‰ F`.\n\nIn this world we extend the idea of intersections to families of sets.  If `F` is a family of\nsets from `U`, then the *intersection* of the family `F` is the set of all objects from `U`\nthat belong to every element of `F`.":
 " Hasta ahora, los elementos de todos nuestros conjuntos han sido objetos del universo `U`.  Pero\nlos conjuntos pueden contener otros tipos de objetos.  En los dos mundos siguientes, trabajaremos con conjuntos cuyos\nelementos son *conjuntos de objetos de `U`*.  Llamaremos a estos *familias de conjuntos* de `U`.  Para\nindicar que `F` es una familia de conjuntos de `U`, escribimos `F : Set (Set U)`.\n\nPor ejemplo, supongamos que `U` contiene las personas de un cierto club, y queremos formar un comitÃ©\nde cinco miembros del club.  El conjunto de todos los posibles comitÃ©s es una familia\nde conjuntos de `U`.  Cada elemento de esta familia es un conjunto que contiene cinco miembros del club.\n\nLas familias de conjuntos son conjuntos, y todo lo que has aprendido sobre conjuntos se aplica a las familias de conjuntos.\nPor ejemplo, si tienes `F G : Set (Set U)` y `S : Set U`, entonces `mem_inter_iff S F G` es una prueba\ndel enunciado `S âˆˆ F âˆ© G â†” S âˆˆ F âˆ§ S âˆˆ G`.  Similarmente, `mem_union S F G` es una prueba de\n`S âˆˆ F âˆª G â†” S âˆˆ F âˆ¨ S âˆˆ G`, y `mem_compl_iff F S` es una prueba de `S âˆˆ Fá¶œ â†” S âˆ‰ F`.\n\nEn este mundo extendemos la idea de intersecciones a familias de conjuntos.  Si `F` es una familia de\nconjuntos de `U`, entonces la *intersecciÃ³n* de la familia `F` es el conjunto de todos los objetos de `U`\nque pertenecen a cada elemento de `F`.",
 "Since your goal is an \"if-then\" statement, a good next step\nis `intro h1`.":
 " Como tu objetivo es un enunciado  de tipo \"si-entonces\", un buen siguiente paso es `intro h1`.",
 "Since your goal is an \"if and only if\" statement, a good next step\nis `apply Iff.intro`.":
 "Dado que tu objetivo es un enunciado \"si y solo si\", un buen siguientepaso es `apply Iff.intro`.",
 "Since we also have `h1 : A âˆˆ F`, you can apply `Â«{h2A}Â»` to `h1` to prove that `Â«{x}Â» âˆˆ A`.\nThis means that `Â«{h2A}Â» h1` is a proof of the goal.":
 "Como tambiÃ©n tenemos `h1 : A âˆˆ F`, puedes aplicar `Â«{h2A}Â»` a `h1` para probar que `Â«{x}Â» âˆˆ A`. Esto significa que `Â«{h2A}Â» h1` es una prueba del objetivo.",
 "Since the goal is a subset statement, you should start by\nintroducing an object `x` and the assumption that `x âˆˆ A âˆ© B`.":
 "Como el objetivo es un enunciado de contenido, debes empezar introduciendoun objeto `x` y la hipÃ³tesis de que `x âˆˆ A âˆ© B`.",
 "Since our goal in this level is the statement `x âˆˆ A â†’ x âˆˆ C`, our first step for\nthis proof is to assume `x âˆˆ A`.  To introduce that assumption,\nassigning it the identifier `h3`, type `intro h3`.":
 "Como nuestro objetivo es `x âˆˆ A â†’ x âˆˆ C`, el primer paso es asumir `x âˆˆ A`. Para introducir\n  esta hipÃ³tesis asignÃ¡ndole el identificador `h3`, teclea `intro h3`.",
 "Since `Â«{h1}Â»` is a negative statement, a good way to reach a contradiction\nwould be to contradict it.  In other words, `Â«{h1}Â» _` would prove the goal `False` if you can\nfill in the blank with a proof of `Â«{x}Â» âˆˆ â‹ƒâ‚€ F`.  That means the tactic `apply Â«{h1}Â»` will\nset your goal to be `Â«{x}Â» âˆˆ â‹ƒâ‚€ F`.":
 " Como `Â«{h1}Â»` es una declaraciÃ³n negativa, una buena manera de llegar a una contradicciÃ³n\nserÃ­a contradecirla. En otras palabras, `Â«{h1}Â» _` probarÃ­a el objetivo `False` si puedes\nrellenar el espacio en blanco con una prueba de `Â«{x}Â» âˆˆ â‹ƒâ‚€ F`. Eso significa que la tÃ¡ctica\n`apply Â«{h1}Â»` establecerÃ¡ tu objetivo como `Â«{x}Â» âˆˆ â‹ƒâ‚€ F`.",
 "Since `h1 h2` is a proof of `x âˆˆ B`, you can\nclose the goal with `exact h1 h2`.":
 "Como `h1 h2` es una prueba de `x âˆˆ B`, puedes cerrar el objetivo con\n  `exact h1 h2`.",
 "Set Theory Game": "Juego de TeorÃ­a de Conjuntos\n\n",
 "Remember, you can use `obtain` to introduce a name for the set that is asserted to\nexist in `Â«{h1}Â»`.":
 " Recuerda que puedes usar `obtain` para introducir un nombre para el conjunto que `Â«{h1}Â»` afirma que existe.",
 "Remember that the goal `âˆƒ t âˆˆ F, Â«{x}Â» âˆˆ t` is an abbreviation for\n`âˆƒ t, t âˆˆ F âˆ§ Â«{x}Â» âˆˆ t`.  As we saw in the last level, we can prove this by coming up with\na witness--that is, a value for `t` that will make the statement `t âˆˆ F âˆ§ Â«{x}Â» âˆˆ t` come out\ntrue.  Looking at\n`h1` and `Â«{h2}Â»`, it looks like `t = A` would work.  That suggests a way to proceed:\n`Exists.intro A hA` would prove the goal, if `hA` were a proof of `A âˆˆ F âˆ§ Â«{x}Â» âˆˆ A`.  In\nother words, if `Exists.intro A` is applied to a proof of `A âˆˆ F âˆ§ Â«{x}Â» âˆˆ A`, then it will\nprove the goal.  So if you use the tactic `apply Exists.intro A`, then Lean will\nset `A âˆˆ F âˆ§ Â«{x}Â» âˆˆ A` as your new goal.":
 " Recuerda que el objetivo `âˆƒ t âˆˆ F, Â«{x}Â» âˆˆ t` es una abreviatura para\n`âˆƒ t, t âˆˆ F âˆ§ Â«{x}Â» âˆˆ t`. Como vimos en el Ãºltimo nivel, podemos probar esto creando\nun testigo, es decir, un valor para `t` que haga verdadera la declaraciÃ³n `t âˆˆ F âˆ§ Â«{x}Â» âˆˆ t`.\nSi miramos\n`h1` y `Â«{h2}Â»`, parece que `t = A` funcionarÃ­a. Esto sugiere una forma de proceder:\n`Exists.intro A hA` probarÃ­a el objetivo, si `hA` fuera una prueba de `A âˆˆ F âˆ§ Â«{x}Â» âˆˆ A`. En\notros tÃ©rminos, si se aplica `Exists.intro A` a una prueba de `A âˆˆ F âˆ§ Â«{x}Â» âˆˆ A`, entonces probarÃ¡\nel objetivo. Por lo tanto, si utilizas la tÃ¡ctica `apply Exists.intro A`, entonces Lean establecerÃ¡\n`A âˆˆ F âˆ§ Â«{x}Â» âˆˆ A` como tu nuevo objetivo.",
 "Remember that `Â«{h2}Â» : âˆ€ t âˆˆ F, Â«{x}Â» âˆˆ t` is an abbreviation for\n`Â«{h2}Â» : âˆ€ t, t âˆˆ F â†’ Â«{x}Â» âˆˆ t`.  Since `âˆ€` means \"for all\", `Â«{h2}Â»` can be applied to any\nset--that is, we can plug in any set for `t` in `Â«{h2}Â»`.\nIn particular, applying it to the set `A`, we can conclude that `A âˆˆ F â†’ Â«{x}Â» âˆˆ A`.\nTo apply `Â«{h2}Â»` to `A`, we just write `Â«{h2}Â»` followed by `A`, with a space between them.\nThus, your next step can be `have Â«{h2}Â»A : A âˆˆ F â†’ Â«{x}Â» âˆˆ A := Â«{h2}Â» A`.  You can save yourself\na little typing by writing `have Â«{h2}Â»A := Â«{h2}Â» A`; Lean will figure out what statement is\nproven by `Â«{h2}Â» A`.":
 " Recuerda que `Â«{h2}Â» : âˆ€ t âˆˆ F, Â«{x}Â» âˆˆ t` es una abreviatura de\n`Â«{h2}Â» : âˆ€ t, t âˆˆ F â†’ Â«{x}Â» âˆˆ t`. Dado que `âˆ€` significa \"para todo\", `Â«{h2}Â»` puede aplicarse a cualquier\nconjunto, es decir, podemos sustituir cualquier conjunto por `t` en `Â«{h2}Â»`.\nEn particular, al aplicarlo al conjunto `A`, podemos concluir que `A âˆˆ F â†’ Â«{x}Â» âˆˆ A`.\nPara aplicar `Â«{h2}Â»` a `A`, simplemente escribimos `Â«{h2}Â»` seguido de `A`, con un espacio entre ellos.\nAsÃ­, tu siguiente paso puede ser `have Â«{h2}Â»A : A âˆˆ F â†’ Â«{x}Â» âˆˆ A := Â«{h2}Â» A`. Puedes ahorrarte\nun poco de tecleo escribiendo `have Â«{h2}Â»A := Â«{h2}Â» A`; Lean entenderÃ¡ quÃ© enunciado se prueba con `Â«{h2}Â» A`.",
 "Recall that `Subset.refl A` is a proof of `A âŠ† A`.\nSo start your proof with `have h : A âŠ† A := Subset.refl A`.":
 " Recuerda que `Subset.refl A` es una prueba de `A âŠ† A`.\nAsÃ­ que puedes empezar tu prueba con `have h : A âŠ† A := Subset.refl A`.",
 "Proving existential statements": "Probar enunciados existenciales",
 "Proving a conjunction": "Demostrar una conjunciÃ³n",
 "Proof by contradiction": "DemostraciÃ³n por contradicciÃ³n",
 "Proof by cases": "DemostraciÃ³n por casos",
 "Perhaps you have already guessed that there is a theorem about the complement\nof an intersection of a family that is similar to the theorem in the last level.":
 " QuizÃ¡s ya adivinaste que hay un teorema sobre el complemento de una intersecciÃ³n de una familia que es similar al teorema en el Ãºltimo nivel.",
 "Our goal in this level is again an equation between sets.  In previous proofs of this kind,\nwe've started with the tactic `apply Subset.antisymm`, and that would work here as well.\nBut we're going to try out an alternative: the tactic `ext`.  This tactic applies the principle\nof *extensionality* for sets, which says that if\ntwo sets have exactly the same elements, then they are equal.":
 "Nuestro objetivo en este nivel es, de nuevo, una ecuaciÃ³n entre conjuntos. En pruebas anteriores de este tipo,\nhemos empezado con la tÃ¡ctica `apply Subset.antisymm`, y eso funcionarÃ­a aquÃ­ igual.\nPero vamos a probar algo diferente: la tÃ¡ctica `ext`. Esta tÃ¡ctica aplica el principio de *extensionalidad* para conjuntos, que dice que si\ndos conjuntos tienen exactamente los mismos elementos, entonces son iguales.",
 "Our first step is to introduce an object `x` into the proof.  To do this, type `intro x`.\nWe have already seen that the `intro` tactic can be used to introduce a new *assumption* into a\nproof.  This step illustrates a second use of `intro`: introducing a new *object* into a proof.":
 "Nuestro primer paso es introducir un objeto `x` en la prueba. Para hacer esto,\n  escribe `intro x`. Ya hemos visto que la tÃ¡ctica `intro` se puede utilizar para introducir\n  una nueva *suposiciÃ³n* en una prueba. Este paso ilustra un segundo uso de `intro`:\n  introducir un nuevo *objeto* en una prueba.",
 "Or": "O",
 "Once again, the use of `rewrite` was not really necessary.  You could prove this\ntheorem with the single step `exact And.intro h1 h2`.":
 "De nuevo, el uso de `rewrite` no era realmente necesario. Puedes probar\neste teorema con un solo paso usando `exact And.intro h1 h2`.",
 "Once again, Lean has left out some parentheses that it regards as unnecessary.\nLean gives intersection higher precedence than union, so it interprets\n`A âˆ© B âˆª A âˆ© C` as `(A âˆ© B) âˆª (A âˆ© C)`.":
 "De nuevo, Lean ha omitido algunos parÃ©ntesis que considera innecesarios.\nLean da preferencia a la intersecciÃ³n sobre la uniÃ³n, asÃ­ que interpreta\n`A âˆ© B âˆª A âˆ© C` como `(A âˆ© B) âˆª (A âˆ© C)`.",
 "Of course, you should begin by introducing the assumption\n`h1 : A âŠ† B`.":
 "Por supuesto, debes comenzar introduciendo la suposiciÃ³n\n`h1 : A âŠ† B`.",
 "Of course, you know by now how to start a proof that one set is a subset of another.":
 "Por supuesto, ahora ya sabes como empezar una demostraciÃ³n de que uno estÃ¡ contenido en el otro.",
 "Of course, you could start the proof in this level with either `ext x` or `apply Subset.antisymm`.\nBut there is a shorter solution: you can use\nthe theorem from the previous level (`compl_union`) to prove the\ntheorem in this level.\n\nThe trick to get started on this proof is to rewrite `Aá¶œ âˆª Bá¶œ` as `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ`.  As you\nknow, `compl_compl (Aá¶œ âˆª Bá¶œ)` is a proof of the theorem `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ = Aá¶œ âˆª Bá¶œ`, and therefore\n`rewrite [compl_compl (Aá¶œ âˆª Bá¶œ)]` could be used to rewrite `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ` as `Aá¶œ âˆª Bá¶œ`; but we\nwant to go in the opposite direction, rewriting `Aá¶œ âˆª Bá¶œ` as `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ`. To do that, use\n`rewrite [â† compl_compl (Aá¶œ âˆª Bá¶œ)]`. (To enter the left-pointing arrow, type `\\l`.)":
 "Por supuesto, podrÃ­as empezar la prueba en este nivel con `ext x` o `apply Subset.antisymm`.\nPero hay una soluciÃ³n mÃ¡s corta: puedes utilizar el teorema del nivel anterior (`compl_union`) para probar el\nteorema en este nivel.\n\nEl truco para empezar esta prueba es reescribir `Aá¶œ âˆª Bá¶œ` como `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ`. Como sabes, `compl_compl (Aá¶œ âˆª Bá¶œ)` es una prueba del teorema `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ = Aá¶œ âˆª Bá¶œ`, y por lo tanto\n`rewrite [compl_compl (Aá¶œ âˆª Bá¶œ)]` podrÃ­a usarse para rewriting `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ` como `Aá¶œ âˆª Bá¶œ`; pero queremos ir en la direcciÃ³n opuesta: reescribir `Aá¶œ âˆª Bá¶œ` como `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ`. Para hacer eso, utiliza\n`rewrite [â† compl_compl (Aá¶œ âˆª Bá¶œ)]`. (Para introducir la flecha hacia la izquierda, escribe `\\l`).",
 "Of course, to start a subset proof you need to introduce an object `x` and an\nassumption `h3`.":
 "Por supuesto, para empezar una prueba de un contenido necesitas introducir un objeto `x` y una\nhipÃ³tesis `h3`.",
 "Now your situation is similar to the previous level.":
 "Ahora tu situaciÃ³n es similar al nivel anterior.",
 "Now your goal starts with `âˆ€ t`.  To prove it, you'll need to introduce\na set `t` into the proof, using the tactic `intro t`.  Recall that the set `t` is\n*arbitrary*--that is, `t` could stand for any set--so whatever we prove about `t` will\nbe true for *all* sets `t`.":
 " Ahora tu objetivo empieza con `âˆ€ t`.  Para probarlo, necesitarÃ¡s introducir un conjunto `t` en la prueba, utilizando la tÃ¡ctica `intro t`. Recuerda que el conjunto `t` es *arbitrario*--es decir, `t` podrÃ­a representar cualquier conjunto--asÃ­ que lo que demostremos sobre `t` serÃ¡ verdadero para *todos* los conjuntos `t`.",
 "Now your goal is an if-then statement; that means `intro` is\nappropriate again, to introduce `Â«{t}Â» âˆˆ F` as a new assumption.":
 " Ahora tu objetivo es un enunciado si-entonces; eso significa que `intro` vuelve a ser apropiado para introducir `Â«{t}Â» âˆˆ F` como una nueva hipÃ³tesis.",
 "Now your goal is a negative statement, so try proof by contradiction.":
 "Ahora tu objetivo es una negaciÃ³n, asÃ­ que intenta demostrarlo por contradicciÃ³n.",
 "Now you have *two* goals.  For the first, the assumption `Â«{x}Â» âˆˆ A âˆ¨ Â«{x}Â» âˆˆ B` has been\nreplaced with `Â«{x}Â» âˆˆ A`, and for the second it has been replaced with `Â«{x}Â» âˆˆ B`.  In both\ncases, you must prove `Â«{x}Â» âˆˆ C`.  The two identifiers after `with` in the `cases'` tactic\nare used as the identifiers of the new assumptions in the two cases.":
 " Ahora tienes *dos* objetivos. Para el primero, la hipÃ³tesis `Â«{x}Â» âˆˆ A âˆ¨ Â«{x}Â» âˆˆ B` ha sido reemplazada con `Â«{x}Â» âˆˆ A`, y para el segundo ha sido reemplazada con `Â«{x}Â» âˆˆ B`. En ambos casos, debes probar `Â«{x}Â» âˆˆ C`. Los dos identificadores despuÃ©s de `with` en la tÃ¡ctica `cases'` se usan como los identificadores de las nuevas hipÃ³tesis en los dos casos.",
 "Now you can use `Exists.intro` to complete the proof.":
 " Ahora puedes usar `Exists.intro` para completar la prueba.",
 "Now you can use `And.intro` to prove the goal.":
 "Ahora puedes usar `And.intro` para probar el objetivo.",
 "Now write out the definition of complement in `Â«{h1}Â»`.":
 "Ahora escribe la definiciÃ³n de complementario en `Â«{h1}Â»`.",
 "Now what statement would you like to contradict to complete the proof?":
 " Ahora, Â¿quÃ© enunciado te gustarÃ­a contradecir para completar la prueba?",
 "Now we're ready to start proving theorems about unions.":
 "Ahora estamos listos para empezar a probar teoremas sobre uniones.",
 "Now we're ready to start proving theorems about intersections.":
 "Ahora estamos listos para comenzar a probar teoremas sobre intersecciones.",
 "Now use `have` to assert that `Â«{x}Â» âˆˆ A âˆª C`.  If you don't see right\naway how to justify this assertion, you can just write `have hAC : Â«{x}Â» âˆˆ A âˆª C` and Lean will\nset `Â«{x}Â» âˆˆ A âˆª C` as your immediate goal.  Once you achieve that goal, Lean will add\n`hAC : Â«{x}Â» âˆˆ A âˆª C` to your list of assumptions, and you can continue with\nthe proof of your original goal.  For further details, click on `have` in the list of tactics\non the right.":
 "Ahora usa `have` para afirmar que `Â«{x}Â» âˆˆ A âˆª C`. Si no ves de inmediato cÃ³mo justificar esta afirmaciÃ³n, puedes escribir simplemente `have hAC : Â«{x}Â» âˆˆ A âˆª C` y Lean establecerÃ¡ `Â«{x}Â» âˆˆ A âˆª C` como tu objetivo inmediato. Una vez que hayas logrado ese objetivo, Lean agregarÃ¡ `hAC : Â«{x}Â» âˆˆ A âˆª C` a tu lista de hipÃ³tesis y podrÃ¡s continuar con la prueba de tu objetivo original. Para obtener mÃ¡s detalles, haz clic en `have` en la lista de tÃ¡cticas a la derecha.",
 "Now use `h1`.": " Ahora usa `h1.",
 "Now the assumption `Â«{h3}Â»` is an \"or\" statement.  The easiest way to use such an\nassumption is to break your proof into cases.  To do this in Lean, use the tactic\n`cases' Â«{h3}Â» with Â«{h3}Â»A Â«{h3}Â»B`.":
 "Ahora la hipÃ³tesis `Â«{h3}Â»` es una afirmaciÃ³n de tipo \"o\". La forma mÃ¡s fÃ¡cil de usar tal suposiciÃ³n es dividir tu prueba en casos. Para hacer esto en Lean, usa la tÃ¡ctica\n`cases' Â«{h3}Â» with Â«{h3}Â»A Â«{h3}Â»B`.",
 "Now that you know `Â«{x}Â» âˆˆ B âˆª C`, you can use that\nstatement as the basis for breaking your proof into cases.":
 "Ahora que sabes `Â«{x}Â» âˆˆ B âˆª C`, puedes usar ese\nenunciado como base para dividir tu prueba en casos.",
 "Now that you have `Â«{hA}Â» : Â«{t}Â» = A`, you can use `rewrite [Â«{hA}Â»]` to replace `Â«{t}Â»` with\n`A` in the goal.":
 " Ahora que tienes `Â«{hA}Â» : Â«{t}Â» = A`, puedes utilizar `rewrite [Â«{hA}Â»]` para reemplazar `Â«{t}Â»` con `A` en el objetivo.",
 "Now `Â«{h1}Â»` says `Â¬Â«{x}Â» âˆ‰ A`, which means `Â¬Â¬Â«{x}Â» âˆˆ A`.  Of course, this can be simplified to\n`Â«{x}Â» âˆˆ A`.  To perform this simplification, you'll need a new tactic, `push_neg`.  To simplify\nthe assumption `Â«{h1}Â»`, write `push_neg at Â«{h1}Â»`.":
 "Ahora `Â«{h1}Â»` dice `Â¬Â«{x}Â» âˆ‰ A`, lo que significa `Â¬Â¬Â«{x}Â» âˆˆ A`. Por supuesto, esto se puede simplificar a\n`Â«{x}Â» âˆˆ A`. Para realizar esta simplificaciÃ³n, necesitarÃ¡s una nueva tÃ¡ctica, `push_neg`. Para simplificar la hipÃ³tesis `Â«{h1}Â»`, escribe `push_neg at Â«{h1}Â»`.",
 "Now `mem_compl_iff A Â«{x}Â»` is a proof of the statement `Â«{x}Â» âˆˆ Aá¶œ â†” Â«{x}Â» âˆ‰ A`, which tells us\nthat we can reexpress the goal `Â«{x}Â» âˆˆ Aá¶œ` as `Â«{x}Â» âˆ‰ A`.  To do this reexpression,\nuse the tactic `rewrite [mem_compl_iff A Â«{x}Â»]`.":
 "ahora `mem_compl_iff A Â«{x}Â»` es una prueba de `Â«{x}Â» âˆˆ Aá¶œ â†” Â«{x}Â» âˆ‰ A`, lo que viene a decir\nque podemos reescribir el objetivo `Â«{x}Â» âˆˆ Aá¶œ` como `Â«{x}Â» âˆ‰ A`.  Para hacer esta reescritura,\nusa la tÃ¡ctica `rewrite [mem_compl_iff A Â«{x}Â»]`.",
 "Now `And.intro Â«{h}Â».right Â«{h}Â».left` proves the goal.":
 "Ahora `And.intro Â«{h}Â».right Â«{h}Â».left` prueba el objetivo.",
 "Notice that, as with intersections, Lean groups unions to the left, so\n`A âˆª B âˆª C` means `(A âˆª B) âˆª C`.":
 " Ten en cuenta que, al igual que con las intersecciones, Lean agrupa uniones a la izquierda, por lo que\n`A âˆª B âˆª C` significa `(A âˆª B) âˆª C`.",
 "Notice that Â«{h}Â» is now a proof of the goal.":
 "Observa que Â«{h}Â» es ahora una prueba del objetivo.",
 "Notice that you haven't used `h2` yet...":
 "FÃ­jate que aÃºn no has utilizado `h2`...",
 "Notice that you have contradictory assumptions.  You can prove anything\nfrom contradictory assumptions.  Do you see how?":
 "FÃ­jate en que tienes suposiciones contradictorias. Puedes probar cualquier cosa a partir de suposiciones contradictorias. Â¿Ves cÃ³mo?",
 "Notice that the parentheses in the next goal are necessary, to indicate that the universal\nquantifier applies only to the subset statement.  Without the parentheses, Lean would interpret\nthe universal quantifier as applying to the entire rest of the statement.":
 "FÃ­jate en que los parÃ©ntesis en el siguiente objetivo son necesarios, para indicar que el cuantificador universal aplica solo al enunciado del subconjunto. Sin los parÃ©ntesis, Lean interpretarÃ­a el cuantificador universal como aplicÃ¡ndose al resto de la declaraciÃ³n.",
 "Notice that the goal is now `False`.  To achieve that goal,\nyou must prove contradictory statements.  You can do that by\nusing `have` to assert `x âˆˆ B`, which will contradict `h2 : x âˆ‰ B`.":
 "Observa que el objetivo es ahora `False`. Para lograr ese objetivo,\n  debes demostrar afirmaciones contradictorias. Puedes hacer esto\n  usando `have` para afirmar `h4 : x âˆˆ B`, lo cual contradirÃ¡ a `h2 : x âˆ‰ B`.",
 "Notice that `Â«{x}Â» : U` has been added to the list of objects, and\nthe goal has changed to `Â«{x}Â» âˆˆ A â†’ Â«{x}Â» âˆˆ A`.  Fortunately, you already know how to prove\na goal of this form.":
 "Observa que se ha aÃ±adido  `Â«{x}Â» : U` a la lista de objetos, y\nel objetivo ha cambiado a  `Â«{x}Â» âˆˆ A â†’ Â«{x}Â» âˆˆ A`. Afortunadamente, ya sabes cÃ³mo demostrar\nun objetivo de esta forma.",
 "Notice that `Â«{h4}Â» : x âˆˆ B` has been added to the list of assumptions.\nCan you complete the proof now?":
 "Observa que  `{h4} : x âˆˆ B` se ha aÃ±adido a la lista de suposiciones.\n  Â¿Puedes completar la demostraciÃ³n ahora?",
 "Notice that `Â«{h3}Â» : x âˆˆ A` is now listed under *Assumptions*, and your new goal is\n`x âˆˆ C`.":
 "FÃ­jate en que `Â«{h3}Â» : x âˆˆ A` aparece ahora en el apartado *Assumptions*, y tu nuevo\nobjetivo es `x âˆˆ C`.",
 "Notice that `Â«{h1}Â»` could be applied to a proof of `Â«{x}Â» âˆˆ â‹ƒâ‚€ F` to\nprove the goal.  That means that `apply Â«{h1}Â»` will set `Â«{x}Â» âˆˆ â‹ƒâ‚€ F` as the goal.":
 " FÃ­jese que `Â«{h1}Â»` se puede aplicar a una prueba de `Â«{x}Â» âˆˆ â‹ƒâ‚€ F` para probar el objetivo. Eso significa que `apply Â«{h1}Â»` establecerÃ¡ `Â«{x}Â» âˆˆ â‹ƒâ‚€ F` como el objetivo.",
 "Notice that Lean has written the goal as `A âˆ© B âˆ© C = A âˆ© (B âˆ© C)`, with no\nparentheses on the left.  When an intersection of more than two sets is written\nwithout parentheses, Lean groups the intersections to the left, so this means\n`(A âˆ© B) âˆ© C = A âˆ© (B âˆ© C)`.\n\nTo start this proof, use the tactic `ext x`.":
 "FÃ­jate en que Lean ha escrito el objetivo como `A âˆ© B âˆ© C = A âˆ© (B âˆ© C)`, sin\nparÃ©ntesis a la izquierda. Cuando se escribe una intersecciÃ³n de mÃ¡s de dos conjuntos\nsin parÃ©ntesis, Lean agrupa las intersecciones hacia la izquierda, asÃ­ que esto significa\n`(A âˆ© B) âˆ© C = A âˆ© (B âˆ© C)`.\n\nPara iniciar esta prueba, use la tÃ¡ctica `ext x`.",
 "Notice that Lean has introduced the new object `Â«{x}Â» : U` into the proof, and\nyour goal is now `Â«{x}Â» âˆˆ A âˆ© B âˆ© C â†” Â«{x}Â» âˆˆ A âˆ© (B âˆ© C)`.  Proving this goal will show that\n`A âˆ© B âˆ© C` and `A âˆ© (B âˆ© C)` have exactly the same elements, and by the principle of\nextensionality, that will show that the sets are equal.":
 "Ten en cuenta que Lean ha introducido el nuevo objeto `Â«{x}Â» : U` en la prueba, y su objetivo ahora es: `Â«{x}Â» âˆˆ A âˆ© B âˆ© C â†” Â«{x}Â» âˆˆ A âˆ© (B âˆ© C)`. Probar este objetivo demostrarÃ¡ que `A âˆ© B âˆ© C` y `A âˆ© (B âˆ© C)` tienen exactamente los mismos elementos, y por el principio de extensionalidad, eso demostrarÃ¡ que los conjuntos son iguales.",
 "Note that you can apply `Â«{h2}Â»` to `(A âˆª Â«{t}Â»)`.\nYou'll need to include the parentheses around `A âˆª Â«{t}Â»` when you do that.":
 "Ten en cuenta que se puede aplicar `Â«{h2}Â»` a `(A âˆª Â«{t}Â»)`.\nPara ello, debes incluir los parÃ©ntesis alrededor de `A âˆª Â«{t}Â»` cuando lo hagas.",
 "Note that Lean also has a `cases` tactic, but the syntax is a little more complicated.\nThat's why we have chosen to use the `cases'` tactic.\n\nThe `cases'` tactic has other uses.  However, in this game we will be using it only with\nassumptions that are \"or\" statements, to break the proof into cases.":
 " Ten en cuenta que Lean tambiÃ©n tiene una tÃ¡ctica `cases`, pero la sintaxis es un poco mÃ¡s complicada. Por eso hemos decidido utilizar la tÃ¡ctica `cases'`.\nLa tÃ¡ctica `cases'` tiene otros usos, pero en este juego solo lo utilizaremos con\nhipÃ³tesis de tipo \"o\", para dividir la prueba en casos.",
 "Next, we'll see how to prove that a union is a subset of another set.":
 " A continuaciÃ³n, veremos cÃ³mo probar que una uniÃ³n es un subconjunto de otro conjunto.",
 "Next we'll prove the associative law for unions.":
 " A continuaciÃ³n probaremos la ley asociativa para las uniones.",
 "Look at what you know about `Â«{s}Â»` and `Â«{t}Â»`.":
 " Mira lo que sabes sobre `Â«{s}Â»` y `Â«{t}Â»`.",
 "Let $x$ be an object in the universe $U$, and let $A$ be a set whose elements\ncome from $U$.  Then $x \\in A^c \\leftrightarrow x \\notin A$.":
 "Sea $x$ un objeto en el universo $U$, y sea $A$ un conjunto cuyos elementos\nproceden de $U$.  Entonces $x \\in A^c \\leftrightarrow x \\notin A$.",
 "Let $x$ be an object in the universe $U$, and let $A$ be a set whose elements\ncome from $U$.  Suppose that $x âˆˆ A$.  Then $x \\in A$.":
 "Sea $x$ un objeto en el universo $U$, y sea $A$ un conjunto cuyos elementos proceden de\n$U$.  SupÃ³n que $x âˆˆ A$.  Entonces $x \\in A$.",
 "Let $x$ be an object from the universe $U$, and let $A$, $B$, and $C$ be sets\nsuch that $A \\subseteq B$ and $x \\in B \\to x \\in C$.  Then $x \\in A â†’ x \\in C$.":
 " Deje que $x$ sea un objeto del universo $U$, y dejemos que $A$, $B$ y $C$ sean conjuntos such that $A \\subseteq B$ and $x \\in B \\to x \\in C$.  Entonces $x \\in A â†’ x \\in C$.",
 "Let $A$ be any set.  Then $A \\subseteq A$.":
 "Sea $A$ un conjunto cualquiera.  Entonces $A \\subseteq A$.",
 "Lean will recognize `mem_singleton_iff` is a proof of any statement of the form\n`x âˆˆ {a} â†” x = a`.  In Mathlib, the name of this theorem is `Set.mem_singleton_iff`.":
 " Lean reconocerÃ¡ que `mem_singleton_iff` es una prueba de cualquier enunciado de la forma\n`x âˆˆ {a} â†” x = a`. En Mathlib, el nombre de este teorema es `Set.mem_singleton_iff`.",
 "Lean will recognize `mem_setOf` as a proof of any statement of the form\n`a âˆˆ {x | P x} â†” P a`.  In Mathlib, the name of this theorem is `Set.mem_setOf`.":
 " Lean reconocerÃ¡ `mem_setOf` como una prueba de cualquier enunciado de la forma\n`a âˆˆ {x | P x} â†” P a`. En Mathlib, el nombre de este teorema es `Set.mem_setOf`.",
 "Lean will recognize `mem_sUnion` as a proof of any statement of the form\n`x âˆˆ â‹ƒâ‚€ F â†” âˆƒ t âˆˆ F, x âˆˆ t`.  In Mathlib, the name of this theorem is `Set.mem_sUnion`.":
 " Lean reconocerÃ¡ `mem_sUnion` como una prueba de cualquier enunciado de la forma `x âˆˆ â‹ƒâ‚€ F â†” âˆƒ t âˆˆ F, x âˆˆ t`. En Mathlib, el nombre de este teorema es `Set.mem_sUnion`.",
 "Lean will recognize `mem_sInter` as a proof of any statement of the form\n`x âˆˆ â‹‚â‚€ F â†” âˆ€ t âˆˆ F, x âˆˆ t`.  In Mathlib, the name of this theorem is `Set.mem_sInter`.":
 " Lean reconocerÃ¡ `mem_sInter` como una prueba de cualquier enunciado de la forma\n`x âˆˆ â‹‚â‚€ F â†” âˆ€ t âˆˆ F, x âˆˆ t`. En Mathlib, el nombre de este teorema es `Set.mem_sInter`.",
 "Just as you were able to apply `h1` to `Â«{h3}Â»` in the last step,\nyou can now apply `h2` to `Â«{h4}Â»` to prove the goal.":
 "Igual que pudiste aplicar `h1` a `{h3}` en el paso anterior,\n  ahora puedes aplicar `h2` a `Â«{h4}Â»` para probar el objetivo.",
 "It would be helpful if you knew that `A âˆˆ {A, B}`.\nYou can use `have` to assert it.":
 " SerÃ­a Ãºtil tener que `A âˆˆ {A, B}`.\nPuedes utilizar `have` para afirmarlo.",
 "It will help you see how to proceed if you\nwrite out the definition of union in both the assumption `Â«{h}Â»` and the goal.":
 "Te puede ser Ãºtil escribir la definiciÃ³n de uniÃ³n tanto en la hipÃ³tesis `Â«{h}Â»` como en el objetivo.",
 "It will help you see how to proceed if you\nwrite out the definition of intersection in both the assumption Â«{h}Â» and the goal.\nUsing the `rewrite` tactic isn't necessary; you can just do the rewriting in\nyour head rather than asking Lean to do it.  But if it helps you to figure out the\nproof, go ahead and use the `rewrite` tactic.":
 "Te ayudarÃ¡ a ver cÃ³mo proceder si escribes la definiciÃ³n de intersecciÃ³n\ntanto en la hipÃ³tesis Â«{h}Â» como en el objetivo. Usar la tÃ¡ctica `rewrite`\nno es necesario; puedes hacer las sustituciones en tu cabeza en lugar de\npedirle a Lean que lo haga. Pero si te ayuda a entender la prueba, adelante\ny usa la tÃ¡ctica `rewrite`.",
 "It will help to get as much information as you can out of `Â«{h1}Â»`\nbefore addressing the goal.":
 "Te serÃ¡ Ãºtil obtener tanta informaciÃ³n como puedas de `Â«{h1}Â»` antes de abordar el objetivo.",
 "It may help you see how to proceed if you separate\nout the second half of `Â«{h}Â»` as a separate assumption.\nYou can do this with `have Â«{h}Â»BC : Â«{x}Â» âˆˆ B âˆª C := Â«{h}Â».right`.":
 "Para ver cÃ³mo proceder, puede ser Ãºtil tener la segunda mitad de `Â«{h}Â»` como una suposiciÃ³n separada.\nPuedes hacer esto con `have Â«{h}Â»BC : Â«{x}Â» âˆˆ B âˆª C := Â«{h}Â».right`.",
 "It looks like `Â«{h2}Â»` could get you to the goal, if only\nyou knew that `Â«{t}Â» âˆˆ G`.  Can you prove that?":
 "Parece que `Â«{h2}Â»` podrÃ­a llevarte al objetivo si supieras que `Â«{t}Â» âˆˆ G`. Â¿Puedes probarlo?",
 "Intersection subset of swap":
 "La intersecciÃ³n es subconjunto de la intersecciÃ³n permutada",
 "Intersection of larger family is smaller":
 "La intersecciÃ³n de una familia mÃ¡s grande, es mÃ¡s pequeÃ±a",
 "Intersection of a union of families": "IntersecciÃ³n de una uniÃ³n de familias",
 "Intersection of a pair": "IntersecciÃ³n de un par",
 "Intersection of a family of unions":
 "IntersecciÃ³n de una familia de uniones.",
 "Intersection is commutative": " La intersecciÃ³n es conmutativa.",
 "Intersection is associative": "La intersecciÃ³n es asociativa",
 "Intersection is a subset":
 "La intersecciÃ³n estÃ¡ contenida en los conjuntos intersecados.",
 "Intersection distributes over union":
 "Distributividad de la intersecciÃ³n sobre la uniÃ³n",
 "Intersection World": "Mundo de las intersecciones",
 "In this world you'll prove theorems combining complements, intersections, and unions.  For\nthe most part, we'll leave you on your own to figure out these proofs.":
 "En este mundo tendrÃ¡s que demostrar teoremas combinando complementarios, intersecciones y uniones. Por lo general, te dejaremos solo para que descubras estas pruebas por ti mismo.",
 "In this world we combine family unions and intersections with each other, and with complements.\nThis level contains some of the hardest proofs in the game!":
 " En este mundo combinamos uniones e intersecciones de familias entre sÃ­ y con complementos.\nEste nivel contiene algunas de las pruebas mÃ¡s difÃ­ciles del juego!",
 "In this proof, we'll need a new proof technique: proof by cases.  And we'll need a new\ntactic to implement that technique in Lean: `cases'`.":
 " En esta prueba, necesitaremos una nueva tÃ©cnica de demostraciÃ³n: demostraciÃ³n por casos. Y necesitaremos una nueva tÃ¡ctica para implementar esa tÃ©cnica en Lean: `cases'`.",
 "In this level, your goal is `Aá¶œá¶œ = A`--that is, the complement of `Aá¶œ` is equal to `A`.\nSo `apply Subset.antisymm` is a good way to start.":
 "En este nivel, tu objetivo es `Aá¶œá¶œ = A`--eso significa que el complementario de `Aá¶œ` es igual a `A`--.\nAsÃ­ que `apply Subset.antisymm` es una buena manera de empezar.",
 "In this level, you'll show that, as with intersections, family unions generalize the\nunions we studied in Union World.":
 " En este nivel, demostrarÃ¡s que, al igual que con las intersecciones, las uniones de familias generalizan las uniones que estudiamos en el mundo de las uniones.",
 "In this level, we'll need to use the definition of \"intersection\".  The theorem that\nexpresses that definition is called `mem_inter_iff`.  If you have `x : U`, `A : Set U`, and\n`B : Set U`, then `mem_inter_iff x A B` is a proof of the statement `x âˆˆ A âˆ© B â†” x âˆˆ A âˆ§ x âˆˆ B`.\nAs we saw in Complement World, that means that the tactic `rewrite [mem_inter_iff x A B]` can be\nused to replace `x âˆˆ A âˆ© B` in the goal with `x âˆˆ A âˆ§ x âˆˆ B`.  Usually Lean can figure out\n`x`, `A`, and `B` on its own, so you can just write `rewrite [mem_inter_iff]`, and you can\nuse `rewrite [mem_inter_iff] at h` to do the replacement in an assumption `h` rather than\nthe goal.\n\nLike `mem_compl_iff`, `mem_inter_iff` can be proven by using the `rfl` tactic.  But we\nwon't ask you to prove it; it is pre-defined in this game.  To enter the symbol `âˆ©`, you\ncan type `\\inter` or `\\cap`.":
 "En este nivel, necesitaremos usar la definiciÃ³n de \"intersecciÃ³n\". El teorema que expresa esa definiciÃ³n se llama `mem_inter_iff`. Si tienes `x : U`, `A : Set U` y `B : Set U`, entonces `mem_inter_iff x A B` es una prueba del enunciado `x âˆˆ A âˆ© B â†” x âˆˆ A âˆ§ x âˆˆ B`. Como vimos en el Mundo de los complementarios, eso significa que la tÃ¡ctica `rewrite [mem_inter_iff x A B]` puede utilizarse para reemplazar `x âˆˆ A âˆ© B` en el objetivo por `x âˆˆ A âˆ§ x âˆˆ B`. Por lo general, Lean puede averiguar por sÃ­ mismo `x`, `A` y `B`, asÃ­ que puedes escribir simplemente `rewrite [mem_inter_iff]`, y puedes usar `rewrite [mem_inter_iff] at h` para hacer lo mismo en una hipÃ³tesis `h` en lugar del objetivo.\n\nAl igual que `mem_compl_iff`, `mem_inter_iff` puede probarse utilizando la tÃ¡ctica `rfl`. Pero no te pediremos que lo pruebes; ya estÃ¡ predefinido en este juego. Para escribir el sÃ­mbolo `âˆ©`, puedes teclear `\\inter` o `\\cap`.",
 "In this level, we introduce another way to define sets.  If `P x` is a statement about an\nunspecified object `x`, then `{x | P x}` denotes the set of all values of `x` that make `P x`\ncome out true.  This is often called *set-builder notation*.  For example,\n`{x | x âˆˆ A âˆ§ x âˆˆ B}` is another way to write `A âˆ© B`.\n\nAs usual, we have a theorem that states the meaning of set-builder notation.  Lean will\nrecognize `mem_setOf` as a proof of any statement of the form `a âˆˆ {x | P x} â†” P a`.\nAnd that means that `rewrite [mem_setOf]` will rewrite `a âˆˆ {x | P x}` as `P a`.":
 " En este nivel, introducimos otra forma de definir conjuntos. Si `P x` es un enunciado sobre un objeto no especificado `x`, entonces `{x | P x}` denota el conjunto de todos los valores de `x` que hacen que `P x` sea verdadero. Esto a menudo se llama *notaciÃ³n constructora de conjuntos*. Por ejemplo,\n`{x | x âˆˆ A âˆ§ x âˆˆ B}` es otra forma de escribir `A âˆ© B`.\n\nComo de costumbre, tenemos un teorema que establece el significado de la notaciÃ³n constructora de conjuntos. Lean reconocerÃ¡ `mem_setOf` como una prueba de cualquier enunciado de la forma `a âˆˆ {x | P x} â†” P a`. Y eso significa que `rewrite [mem_setOf]` reescribirÃ¡ `a âˆˆ {x | P x}` como `P a`.",
 "In this level, we have assumptions `h1 : A âŠ† B`, `h2 : B âŠ† C`, and `h3 : x âˆˆ A`.\nAs we saw in the last level, `h1 h3` is a proof that `x âˆˆ B`.  Unfortunately,\nthat is not the goal, so we can't use `exact h1 h3` to close the goal.\nHowever, we can use the proof `h1 h3` to justify adding `h4 : x âˆˆ B` to our\nlist of assumptions.  To do that, we'll use a new tactic: `have`.":
 "\nEn este nivel, tenemos las hipÃ³tesis `h1 : A âŠ† B`, `h2 : B âŠ† C`, y `h3 : x âˆˆ A`.\nComo vimos en el nivel anterior, `h1 h3` es una prueba de que `x âˆˆ B`. Lamentablemente,\nese no es el objetivo, asÃ­ que no podemos usar `exact h1 h3` para cerrar el objetivo.\nSin embargo, podemos usar la prueba `h1 h3` para justificar agregar `h4 : x âˆˆ B` a nuestra\nlista de suposiciones. Para hacer eso, usaremos una nueva tÃ¡ctica: `have`.\n",
 "In this level, `F` and `G` are families of sets, and you'll work out how `â‹ƒâ‚€ (F âˆª G)` is related\nto `â‹ƒâ‚€ F` and `â‹ƒâ‚€ G`.":
 " En este nivel, `F` y `G` son familias de conjuntos, y tendrÃ¡s que averiguar cÃ³mo se relaciona `â‹ƒâ‚€ (F âˆª G)` con `â‹ƒâ‚€ F` y `â‹ƒâ‚€ G`.",
 "In this level you'll prove a generalization of the theorem `compl_union` that you proved\nin Combination World.  That theorem was about the complement of a union of two sets; the\ntheorem in this level is about the complement of a union of a family of sets.\n\nAs in the case of `compl_union`, you have a choice about how to deal with the negations that\narise when you write out the meaning of complement.  You can use the `push_neg` tactic to\nreexpress negative statements, or you can use proof by contradiction.":
 " En este nivel, demostrarÃ¡s una generalizaciÃ³n del teorema `compl_union` que probaste en el mundo combinado. Ese teorema trataba sobre el complemento de la uniÃ³n de dos conjuntos; el teorema en este nivel trata sobre el complemento de la uniÃ³n de una familia de conjuntos.\n\nComo en el caso de `compl_union`, puedes elegir cÃ³mo lidiar con las negaciones que surgen cuando escribes el significado del complemento. Puedes usar la tÃ¡ctica `push_neg` para re-expresar declaraciones negativas, o puedes hacer una prueba por contradicciÃ³n.",
 "In this level you'll need a new kind of proof by cases.  For any statement `P`, the\ntactic `by_cases h : P` will break the proof into two cases.  In the first case, the new\nassumption `h : P` is added to the list of assumptions, and in second, the new\nassumption `h : Â¬P` is added.  Since `P` must be either true or false, these two cases cover\nall possibilities.":
 "En este nivel necesitarÃ¡s un nuevo tipo de prueba por casos. Para cualquier enunciado `P`, la tÃ¡ctica `by_cases h : P` dividirÃ¡ la prueba en dos casos.En el primer caso, se aÃ±ade la nueva suposiciÃ³n `h : P` a la lista de suposiciones y en segundo lugar, se aÃ±ade la nueva suposiciÃ³n `h : Â¬P`. Dado que `P` debe ser verdadero o falso, estos dos casos cubren todas las posibilidades.",
 "In this level we'll prove a statement of the form `P âˆ§ Q`.  To do this, we'll need\nanother theorem: `And.intro`.  If you have `h1 : P` and `h2 : Q`, then\n`And.intro h1 h2` is a proof of `P âˆ§ Q`.":
 "En este nivel demostraremos un enunciado de la forma `P âˆ§ Q`. Para hacer\nesto, necesitaremos otro teorema: `And.intro`. Si tienes `h1 : P` y `h2 :Q`,\nentonces `And.intro h1 h2` es una prueba de `P âˆ§ Q`.",
 "In this level we have two families of sets, `F` and `G`, with `F âŠ† G`.  That means that\n`â‹‚â‚€ G` is the intersection of a family of sets that includes all the sets in `F`, plus\nperhaps more sets.  You're going to prove that intersecting this larger collection of sets\nleads to a smaller result; more precisely, you're going to prove that `â‹‚â‚€ G âŠ† â‹‚â‚€ F`.\n\nOf course, by now you know how to start a proof that one set is a subset of another.":
 " En este nivel tenemos dos familias de conjuntos, `F` y `G`, con `F âŠ† G`. Esto significa que\n`â‹‚â‚€ G` es la intersecciÃ³n de una familia de conjuntos que incluye todos los conjuntos en `F`, mÃ¡s\nquizÃ¡s mÃ¡s conjuntos. Vas a probar que intersecar esta colecciÃ³n mÃ¡s grande de conjuntos\nlleva a un resultado mÃ¡s pequeÃ±o; mÃ¡s precisamente, vas a probar que `â‹‚â‚€ G âŠ† â‹‚â‚€ F`.\n\nPor supuesto, ya sabes cÃ³mo empezar una prueba de que un conjunto es un subconjunto de otro.",
 "In this level we have two families of sets, `F` and `G`, with `F âŠ† G`.  In Family Intersection\nWorld, you proved that in this situation, `â‹‚â‚€ G âŠ† â‹‚â‚€ F`.  In this level, you'll prove that\nwith family unions, it works the other way: `â‹ƒâ‚€ F âŠ† â‹ƒâ‚€ G`.\n\nWe'll need a new tactic for this proof.  An assumption of the form `h : âˆƒ x, P x` tells you that\nan object with a certain property exists.  If you have such an assumption, then it is usually\nhelpful to introduce a name for such an object.  You can do this with the `obtain` tactic.  If\nyou write `obtain âŸ¨w, hwâŸ© := h`, then Lean will introduce a new object `w` and a new assumption\n`hw : P w`.  Thus, the object `w` is a witness for the existential assumption `h`.  Note that\nin the `obtain` tactic, `w` and `hw` must be enclosed in angle brackets: `âŸ¨ âŸ©`.  You can\nenter these by typing either `\\<` and `\\>` or `\\langle` and `\\rangle`.":
 " En este nivel tenemos dos familias de conjuntos, `F` y `G`, con `F âŠ† G`. En el Mundo de la intersecciÃ³n de familias, demostraste que en esta situaciÃ³n, `â‹‚â‚€ G âŠ† â‹‚â‚€ F`. En este nivel, probarÃ¡s que con uniones de familias, funciona al revÃ©s: `â‹ƒâ‚€ F âŠ† â‹ƒâ‚€ G`.\n\nNecesitaremos una nueva tÃ¡ctica para esta prueba. Una suposiciÃ³n de la forma `h : âˆƒ x, P x` te dice que existe un objeto con cierta propiedad. Si tienes una hipÃ³tesis asÃ­, entonces suele ser Ãºtil introducir un nombre para tal objeto. Lo puedes hacer con la tÃ¡ctica `obtain`. Si escribes `obtain âŸ¨w, hwâŸ© := h`, entonces Lean introducirÃ¡ un nuevo objeto `w` y una nueva suposiciÃ³n `hw : P w`. Por lo tanto, el objeto `w` es un testigo para la suposiciÃ³n existencial `h`. Ten en cuenta que en la tÃ¡ctica `obtain`, `w` y `hw` deben estar encerrados en corchetes angulares: `âŸ¨ âŸ©`. Puedes escribirlos tecleando `\\<` y `\\>` o `\\langle` y `\\rangle`.",
 "In this last level of Complement World, you'll prove a statement of the form `P â†” Q`.  The most\nuseful theorem for this purpose is `Iff.intro`.  If you have `h1 : P â†’ Q` and `h2 : Q â†’ P`, then\n`Iff.intro h1 h2` is a proof of `P â†” Q`.  As we saw in the last level, that means you can start your\nproof with `apply Iff.intro`.  Lean will set `P â†’ Q` and `Q â†’ P` as the goals that are needed\nto complete the proof.":
 "En este Ãºltimo nivel del mundo de complementarios, demostrarÃ¡s un enunciado dela forma `P â†” Q`. El teorema mÃ¡s Ãºtil para este propÃ³sito es `Iff.intro`. Si tienes `h1 : P â†’ Q` y `h2 : Q â†’ P`, entonces `Iff.intro h1 h2` es una prueba de `P â†” Q`. Como vimos en el Ãºltimo nivel, eso significa que puedes comenzar tu prueba con `apply Iff.intro`. Lean establecerÃ¡ `P â†’ Q` y `Q â†’ P` como los objetivos que deben ser probados para completar la demostraciÃ³n.",
 "In this game you will learn the basics of theorem proving in Lean by proving\ntheorems about unions, intersections, and complements of sets.":
 " En este juego aprenderÃ¡s los conceptos bÃ¡sicos de prueba de teoremas en Lean al probar teoremas sobre uniones, intersecciones y complementos de conjuntos.",
 "In the next level we're going to prove that union is commutative; that is,\n`A âˆª B = B âˆª A`.  We're going to imitate the approach we used in Intersection World\nto prove that intersection is commutative.  We begin by proving `A âˆª B âŠ† B âˆª A`.":
 " En el siguiente nivel vamos a probar que la uniÃ³n es conmutativa; es decir,\n`A âˆª B = B âˆª A`. Vamos a imitar el enfoque que utilizamos en el Mundo de las Intersecciones\npara probar que la intersecciÃ³n es conmutativa. Comenzamos demostrando `A âˆª B âŠ† B âˆª A`.",
 "In the next level we're going to prove that intersection is commutative; that is,\n`A âˆ© B = B âˆ© A`.  As a warm-up, in this level we prove `A âˆ© B âŠ† B âˆ© A`.":
 "En el siguiente nivel vamos a probar que la intersecciÃ³n es conmutativa; es decir,\n`A âˆ© B = B âˆ© A`. Como calentamiento, en este nivel probaremos `A âˆ© B âŠ† B âˆ© A`.",
 "In the last level, you proved the theorem `mem_compl_iff`.  If you have `A : Set U` and `x : U`,\nthen `mem_compl_iff A x` is a proof of the statement `x âˆˆ Aá¶œ â†” x âˆ‰ A`.\n\nYou could think of the statement `x âˆˆ Aá¶œ â†” x âˆ‰ A` as saying that if `x âˆˆ Aá¶œ` occurs anywhere\nin a proof, you can replace it with `x âˆ‰ A`.  There is a tactic called `rewrite` that can be\nused to perform such replacements.  You'll get to try out the `rewrite` tactic in this level.":
 "\nEn el Ãºltimo nivel, demostraste el teorema `comp_def`. Si tienes `x : U` y `A : Set U`,\nentonces `comp_def x A` es una prueba de la afirmaciÃ³n `x âˆˆ Aá¶œ â†” x âˆ‰ A`.\n\nPodrÃ­as pensar en la afirmaciÃ³n `x âˆˆ Aá¶œ â†” x âˆ‰ A` como decir que si `x âˆˆ Aá¶œ` ocurre en cualquier\nparte de una prueba, puedes reemplazarlo con `x âˆ‰ A`. Hay una tÃ¡ctica llamada `rewrite` que se puede\nusar para realizar tales reemplazos. TendrÃ¡s la oportunidad de probar la tÃ¡ctica `rewrite` en este nivel.\n",
 "In order to complete this proof, type `exact h` in the text box\nunder the goal and click on \"Execute\" or hit the \"Return\" or \"Enter\" key.":
 "Para completar esta prueba, teclea `exact h` en la caja de texto bajo el objetivo\n  y haz click en  \"Execute\" o pulsa le tecla \"Return\" o \"Enter\".",
 "In mathematical writing, the union of the family $F$ is usually denoted $\\bigcup F$.\nIn Lean, the union of a family `F` is denoted `â‹ƒâ‚€ F`.  (You can enter the symbol\n`â‹ƒâ‚€` by typing `\\U0`.)\n\nSuppose we have `F : Set (Set U)` and `x : U`.  Then `x âˆˆ â‹ƒâ‚€ F` means that there is at least\none set `t` such that `t âˆˆ F` and `x âˆˆ t`.  To write this statement in Lean, we write\n`âˆƒ t, t âˆˆ F âˆ§ x âˆˆ t`.  Lean abbreviates this statement as `âˆƒ t âˆˆ F, x âˆˆ t`.\n\nAs with other set theory operations, we have a theorem that expresses this definition.  Lean will\nrecognize `mem_sUnion` as a proof of any statement of the form `x âˆˆ â‹ƒâ‚€ F â†” âˆƒ t âˆˆ F, x âˆˆ t`.\n\nIn this level, you'll try out these ideas.":
 " En la notaciÃ³n matemÃ¡tica, la uniÃ³n de la familia $F$ suele denotarse como $ \\bigcup F$.\nEn Lean, la uniÃ³n de una familia `F` se denota con `â‹ƒâ‚€ F`. (Puedes ingresar el sÃ­mbolo\n`â‹ƒâ‚€` escribiendo `\\U0`.)\n\nSupongamos que tenemos `F : Set (Set U)` y `x : U`. Entonces, `x âˆˆ â‹ƒâ‚€ F` significa que hay al menos\nun conjunto `t` tal que `t âˆˆ F` y `x âˆˆ t`. Para escribir este enunciado en Lean, escribimos\n`âˆƒ t, t âˆˆ F âˆ§ x âˆˆ t`. Lean abrevia este enunciado como `âˆƒ t âˆˆ F, x âˆˆ t`.\n\nComo con otras operaciones de la teorÃ­a de conjuntos, tenemos un teorema que expresa esta definiciÃ³n. Lean reconocerÃ¡ `mem_sUnion` como una prueba de cualquier declaraciÃ³n del tipo `x âˆˆ â‹ƒâ‚€ F â†” âˆƒ t âˆˆ F, x âˆˆ t`.\n\nEn este nivel, probarÃ¡s estas ideas.",
 "In mathematical writing, the intersection of the family $F$ is usually denoted $\\bigcap F$.\nIn Lean, the intersection of a family `F` is denoted `â‹‚â‚€ F`.  (You can enter the symbol\n`â‹‚â‚€` by typing `\\I0`.)\n\nSuppose we have `F : Set (Set U)` and `x : U`.  Then `x âˆˆ â‹‚â‚€ F` means that for every set `t`, if\n`t` is in `F`, then `x âˆˆ t`.  To write this statement in Lean, we write `âˆ€ t, t âˆˆ F â†’ x âˆˆ t`.\nLean abbreviates this statement as `âˆ€ t âˆˆ F, x âˆˆ t`.\nThe symbol `âˆ€` is called the *universal quantifier*, and you can enter it in Lean by typing\n`\\forall`.  Note that `âˆ€ t, t âˆˆ F â†’ x âˆˆ t` means `âˆ€ t, (t âˆˆ F â†’ x âˆˆ t)`, not\n`(âˆ€ t, t âˆˆ F) â†’ x âˆˆ t`.  In other words, Lean interprets the universal quantifier as applying\nto the entire rest of the statement.  If you want it to apply to less, you have to\nuse parentheses to indicate that.\n\nAs with other set theory operations, we have a theorem that expresses this definition.  Lean will\nrecognize `mem_sInter` as a proof of any statement of the form `x âˆˆ â‹‚â‚€ F â†” âˆ€ t âˆˆ F, x âˆˆ t`.\n\nIn this level, you'll try out these ideas.":
 "En notaciÃ³n matemÃ¡tica, la intersecciÃ³n de la familia $F$ suele denotarse como $\\bigcap F$.\nEn Lean, la intersecciÃ³n de una familia `F` se denota `â‹‚â‚€ F`. (Puedes ingresar el sÃ­mbolo\n`â‹‚â‚€` escribiendo `\\I0`.)\n\nSupongamos que tenemos `F : Set (Set U)` y `x : U`. Entonces `x âˆˆ â‹‚â‚€ F` significa que para cada conjunto `t`, si\n`t` estÃ¡ en `F`, entonces `x âˆˆ t`. Para escribir esta declaraciÃ³n en Lean, escribimos `âˆ€ t, t âˆˆ F â†’ x âˆˆ t`.\nLean abrevia esta declaraciÃ³n como `âˆ€ t âˆˆ F, x âˆˆ t`.\nEl sÃ­mbolo `âˆ€` se llama el *cuantificador universal*, y puedes introducirlo en Lean escribiendo\n`\\forall`. Note que `âˆ€ t, t âˆˆ F â†’ x âˆˆ t` significa `âˆ€ t, (t âˆˆ F â†’ x âˆˆ t)`, no\n`(âˆ€ t, t âˆˆ F) â†’ x âˆˆ t`. En otras palabras, Lean interpreta el cuantificador universal como aplicÃ¡ndose al resto de la declaraciÃ³n. Si quieres que se aplique a menos, debes utilizar parÃ©ntesis para indicarlo.\n\nComo con otras operaciones de teorÃ­a de conjuntos, tenemos un teorema que expresa esta definiciÃ³n. Lean reconocerÃ¡ `mem_sInter` como una prueba de cualquier enunciado de la forma `x âˆˆ â‹‚â‚€ F â†” âˆ€ t âˆˆ F, x âˆˆ t`.\n\nEn este nivel, trabajaremos estas ideas.",
 "In general, if your goal has the form `P â†’ Q`, then the tactic `intro h` will add `h : P` to\nthe list of assumptions and set `Q` to be the goal.  If you have assumptions\n`h1 : P â†’ Q` and `h2 : P`, then `h1 h2` is a proof of `Q`.  This is another example of a proof\nacting like a function: a proof of `P â†’ Q` can be thought of as a function which, when\napplied to a proof of `P`, produces a proof of `Q`.\n\nAs usual, for more information about the new tactic `intro`, you can click on `intro`\nin the list of tactics on the right.":
 "\nEn general, si tu objetivo es de la forma `P â†’ Q`, la tÃ¡ctica `intro h` aÃ±adirÃ¡ `h : P` a la lista\nde hipÃ³tesis, y establecerÃ¡ `Q` como el objetivo a probar. Si tienes hipÃ³tesis\n`h1 : P â†’ Q` y `h2 : P`, `h1 h2` es una prueba de `Q`. Este es otro ejemplo de una prueba funcionando\ncomo una funciÃ³n: una prueba de `P â†’ Q` se puede ver como una funciÃ³n que, cuando se aplica a `P`\nproduce una prueba de `Q`.\n\nComo de costumbre, para mÃ¡s informaciÃ³n sobre la tÃ¡ctica `intro`, puedes pulsar en\n`intro` en la lista de tÃ¡cticas de la derecha.\n",
 "In general, if you think that some theorem `t` could be used to prove the goal, the tactic\n`apply t` will work backwards from the goal, setting as new goals any hypotheses that are\nneeded for the application of the theorem `t`.\n\nIf your goal has the form `P âˆ§ Q`, then the `constructor` tactic will have the same\neffect as `apply And.intro`; that is, it will set `P` and `Q` as goals to be proven.":
 "En general, si crees que algÃºn teorema `t` podrÃ­a usarse para probar el objetivo, la tÃ¡ctica\n`apply t` funcionarÃ¡ hacia atrÃ¡s desde el objetivo, estableciendo como nuevos objetivos las hipÃ³tesis que sean necesarias para la aplicaciÃ³n del teorema `t`.\n\nSi tu objetivo tiene la forma `P âˆ§ Q`, entonces la tÃ¡ctica `constructor` tendrÃ¡ el mismo efecto que `apply And.intro`; es decir, establecerÃ¡ `P` y `Q` como objetivos para ser probados.",
 "Implication": "Implicaciones",
 "If your goal is a statement of the form `P â†” Q`, and `P` and `Q` are definitionally\nequivalent (that is, equivalent by virtue of the definitions of the symbols occurring in\nthem), then the `rfl` tactic will close the goal.  It will also close a goal of the form\n`X = Y`, if `X` and `Y` are definitionally equal (that is, equal by virtue of definitions).":
 "Si tu objetivo es una afirmaciÃ³n de la forma `P â†” Q`, y `P` y `Q` son equivalentes por definiciÃ³n\n(es decir, equivalentes por virtud de las definiciones de los sÃ­mbolos que aparecen en ellas),\nentonces la tÃ¡ctica `rfl` cerrarÃ¡ el objetivo. TambiÃ©n cerrarÃ¡ un objetivo de la forma\n`X = Y`, si `X` e `Y` son iguales por definiciÃ³n.\n",
 "If your goal is a negative statement, then the tactic `push_neg` will try to reexpress it as\nan equivalent positive statement.  Similarly, if an assumption `h` is a negative\nstatement, then `push_neg at h` will try to reexpress `h`.  Here are some examples of\nreexpressions performed by the `push_neg` tactic:\n* `Â¬Â¬P` is converted to `P`.\n* `Â¬(P âˆ¨ Q)` is converted to `Â¬P âˆ§ Â¬Q`.\n* `Â¬(P âˆ§ Q)` is converted to `P â†’ Â¬Q`.\n* `Â¬(P â†’ Q)` is converted to `P âˆ§ Â¬Q`.\n* `Â¬âˆ€ x, P x` is converted to `âˆƒ x, Â¬P x`.\n* `Â¬âˆƒ x, P x` is converted to `âˆ€ x, Â¬P x`.":
 "Si tu objetivo es un enunciado negativo, entonces la tÃ¡ctica `push_neg` intentarÃ¡ reexpresarlo como un enunciado equivalente positivo. De manera similar, si una hipÃ³tesis `h` es un enunciado negativo, entonces `push_neg at h` intentarÃ¡ reexpresar `h`. AquÃ­ hay algunos ejemplos de reexpresiones realizadas por la tÃ¡ctica `push_neg`:\n* `Â¬Â¬P` se convierte en `P`.\n* `Â¬(P âˆ¨ Q)` se convierte en `Â¬P âˆ§ Â¬Q`.\n* `Â¬(P âˆ§ Q)` se convierte en `P â†’ Â¬Q`.\n* `Â¬(P â†’ Q)` se convierte en `P âˆ§ Â¬Q`.\n* `Â¬âˆ€ x, P x` se convierte en `âˆƒ x, Â¬P x`.\n* `Â¬âˆƒ x, P x` se convierte en `âˆ€ x, Â¬P x`.",
 "If your goal is `âˆƒ x, P x`, where `P x` represents some statement about `x`, and `a` is a\nvalue that could be assigned to `x`, then the tactic `use a` will\nset `P a` to be the goal.  It will then see if this new goal follows easily from your\nassumptions, and if so it will close the goal.":
 " Si tu objetivo es `âˆƒ x, P x`, donde `P x` representa alguna afirmaciÃ³n sobre `x`, y `a` es un\nvalor que podrÃ­a asignarse a `x`, entonces la tÃ¡ctica `use a` establecerÃ¡ `P a` como objetivo.  Luego verÃ¡ si este nuevo objetivo se sigue fÃ¡cilmente de sus suposiciones, y si es asÃ­, cerrarÃ¡ el objetivo.",
 "If your goal is `Â¬P`, for some statement `P`, then the tactic\n`by_contra h` will introduce the new assumption `h : P`, and set the\ngoal to be `False`.  If your goal is a statement `P` that is not a negative\nstatement, then `by_contra h` will introduce the new assumption\n`h : Â¬P`.\n\nTo achieve your new goal, you will need to establish\n`h1 : Q` and `h2 : Â¬Q`, for some statement `Q`.  If you can do that,\nthen `h2 h1` will prove the goal `False`.  Notice that `h1 h2` will not be\nrecognized as a proof of `False`; the negative statement must come first.":
 "Si tu objetivo es `Â¬P`, para alguna afirmaciÃ³n `P`, entonces la tÃ¡ctica`by_contra h` introducirÃ¡ la nueva suposiciÃ³n `h : P` y establecerÃ¡ el objetivo como `False`. Si tu objetivo es una afirmaciÃ³n `P` que no es negativa,entonces `by_contra h` introducirÃ¡ la nueva suposiciÃ³n`Â¬P`.Para lograr tu nuevo objetivo, deberÃ¡s establecer`h1 : Q` y `h2 : Â¬Q`, para alguna afirmaciÃ³n `Q`. Si puedes hacer eso,entonces `h2 h1` demostrarÃ¡ el objetivo `False`. Observa que `h1 h2` no serÃ¡ reconocido como una prueba de `False`; la afirmaciÃ³n negativa debe venir primero.",
 "If your goal is `A = B`, where `A` and `B` are sets, then the tactic `ext x` will introduce\na new arbitrary object `x` into the proof and set the goal to be `x âˆˆ A â†” x âˆˆ B`.":
 "Si tu objetivo es `A = B`, donde `A` y `B` son conjuntos, entonces la tÃ¡ctica `ext x` introducirÃ¡\nun nuevo objeto `x` arbitrario en la prueba y `x âˆˆ A â†” x âˆˆ B` como nuevo objetivo.",
 "If you're stuck at this point,\nit may help you see how to proceed if you separate\nout the first half of `Â«{h1}Â»` as a separate assumption.\nYou can do this with `have hAB : Â«{x}Â» âˆˆ A âˆ© B := Â«{h1}Â».left`.":
 "Si te atascas en este punto,\nte puede ser Ãºtil si separar\nla primera mitad de `Â«{h1}Â»` como una suposiciÃ³n separada.\nPuedes hacer esto con `have hAB : Â«{x}Â» âˆˆ A âˆ© B := Â«{h1}Â».left`.",
 "If you start your proof with `apply Subset.antisymm`, then you'll be able to use\nthe theorem `union_subset_swap` that you proved in the last level.":
 " Si comienzas tu prueba con `apply Subset.antisymm`, podrÃ¡s usar\nel teorema `union_subset_swap` que demostraste en el Ãºltimo nivel.",
 "If you have an assumption `h : âˆƒ x, P x`, then the tactic `obtain âŸ¨w, hwâŸ© := h` will\nintroduce a new object `w` and a new assumption `hw : P w` into the proof.  To enter the\nangle brackets `âŸ¨ âŸ©`, type either `\\<` and `\\>` or `\\langle` and `\\rangle`.":
 " Si tienes una suposiciÃ³n `h : âˆƒ x, P x`, entonces la tÃ¡ctica `obtain âŸ¨w, hwâŸ© := h` introducirÃ¡ un nuevo objeto `w` y una nueva suposiciÃ³n `hw : P w` en la prueba. Para ingresar los corchetes angulares `âŸ¨ âŸ©`, teclea  `\\<` y `\\>` o `\\langle` y `\\rangle`.",
 "If you have `x : U`, `A : Set U`, and `B : Set U`, then `mem_union x A B` is a proof of the\nstatement `x âˆˆ A âˆª B â†” x âˆˆ A âˆ¨ x âˆˆ B`.  In Mathlib, the name of this theorem is `Set.mem_union`.":
 "Si tienes `x : U`, `A : Set U`, y `B : Set U`, entonces `mem_union x A B` es una prueba del enunciado `x âˆˆ A âˆª B â†” x âˆˆ A âˆ¨ x âˆˆ B`. En Mathlib, el nombre de este teorema es `Set.mem_union`.",
 "If you have `x : U`, `A : Set U`, and `B : Set U`, then `mem_inter_iff x A B` is a proof of the\nstatement `x âˆˆ A âˆ© B â†” x âˆˆ A âˆ§ x âˆˆ B`.\nIn Mathlib, the name of this theorem is `Set.mem_inter_iff`.":
 "Si tienes `x : U`, `A : Set U`, y `B : Set U`, entonces `mem_inter_iff x A B` es una prueba del\nenunciado `x âˆˆ A âˆ© B â†” x âˆˆ A âˆ§ x âˆˆ B`.\nEn Mathlib, el nombre de este teorema es `Set.mem_inter_iff`.",
 "If you have `h1 : P` and `h2 : Q`, then `And.intro h1 h2` is a proof of `P âˆ§ Q`.":
 "Si tienes `h1 : P` y `h2 : Q`, entonces `And.intro h1 h2` es una prueba de `P âˆ§ Q`.",
 "If you have `h1 : P â†’ Q` and `h2 : Q â†’ P`, then `Iff.intro h1 h2` is a proof of `P â†” Q`.":
 "Si tienes `h1 : P â†’ Q` y `h2 : Q â†’ P`, entonces `Iff.intro h1 h2` es una prueba de `P â†” Q`.",
 "If you have `h1 : A âŠ† B` and `h2 : B âŠ† C`, then `Subset.trans h1 h2` is a proof of `A âŠ† C`.\nIn Mathlib, the name of this theorem is `Set.Subset.trans`.":
 "Si tienes `h1 : A âŠ† B` y `h2 : B âŠ† C`, `sub_trans h1 h2` es una prueba de `A âŠ† C`.\nEn Mathlib, el nombre de este teorema es `Set.Subset.trans`.",
 "If you have `h1 : A âŠ† B` and `h2 : B âŠ† A`, then `Subset.antisymm h1 h2` is a proof of `A = B`.\nIn Mathlib, the name of this theorem is `Set.Subset.antisymm`.":
 "Si tienes `h1 : A âŠ† B` y `h2 : B âŠ† A`, entonces `Subset.antisymm h1 h2` es una prueba de `A = B`.\nEn Mathlib, el nombre de este teorema es `Set.Subset.antisymm`.",
 "If you have `h : Q`, then `Or.inr h` can be used as a proof of `P âˆ¨ Q`, for\nany statement `P`.":
 "Si tienes `h : Q`, entonces `Or.inr h` puede usarse como una prueba de `P âˆ¨Q`, para cualquier enunciado `P`.",
 "If you have `h : P`, then `Or.inl h` can be used as a proof of `P âˆ¨ Q`, for\nany statement `Q`.":
 "Si tienes `h : P`, entonces `Or.inl h` se puede usar como prueba de `P âˆ¨ Q`, para cualquier enunciado `Q`.",
 "If you have `h : A âŠ† B`, then `compl_subset_compl_of_subset h` is a proof of `Bá¶œ âŠ† Aá¶œ`.\nIn Mathlib, the name of this theorem is `Set.compl_subset_compl_of_subset`.":
 "Si tienes `h : A âŠ† B`, entonces `compl_subset_compl_of_subset h` es una prueba de `Bá¶œ âŠ† Aá¶œ`.\nEn Mathlib, este teorema se llama `Set.compl_subset_compl_of_subset`.",
 "If you have `A : Set U`, then `Subset.refl A` is a proof of `A âŠ† A`.\nIn Mathlib, the name of this theorem is `Set.Subset.refl`.":
 "Si tenemos `A : Set U`, entonces `sub_ref A` es una prueba de que `A âŠ† A`.\nEn Mathlib, este teorema se llama `Set.Subset.refl`.",
 "If you have `A : Set U`, then `Aá¶œ` is defined to be the set of all objects in the universe `U`\nthat are not elements of `A`.  That means that if you also have `x : U`, then the statements\n`x âˆˆ Aá¶œ` and `x âˆ‰ A` are equivalent.  We express this by saying that the statement\n`x âˆˆ Aá¶œ â†” x âˆ‰ A` is true.  (The symbol `â†”` means \"if and only if\", and you can enter it\nby typing `\\iff`.  You can enter the superscript `c` in the notation for the complement\nof a set by typing `\\compl` or `\\^c`.)\n\nIn this level, we're going to prove that the statement `x âˆˆ Aá¶œ â†” x âˆ‰ A` is true, and to do\nit we'll use a new tactic: `rfl`.  The `rfl` tactic can prove any statement of the form\n`P â†” Q` if `P` and `Q` are statements that are equivalent by virtue of the definitions of\nthe symbols occurring in them.  (We say in this case that `P` and `Q` are *definitionally\nequivalent*.)  The `rfl` tactic can also prove statements of the form `X = Y`, if `X` and\n`Y` are definitionally equal--that is, equal by virtue of definitions.":
 "\nSi tienes `A : Set U`, entonces `Aá¶œ` se define como el conjunto de todos los objetos en el universo\n`U` que no son elementos de `A`. Esto significa que si tambiÃ©n tienes `x : U`, entonces las\nafirmaciones `x âˆˆ Aá¶œ` y `x âˆ‰ A` son equivalentes. Expresamos esto diciendo que la afirmaciÃ³n\n`x âˆˆ Aá¶œ â†” x âˆ‰ A` es verdadera. (El sÃ­mbolo `â†”` significa \\\"si y solo si\\\", y puedes introducirlo\nescribiendo `\\iff`. Puedes ingresar el superÃ­ndice `c` en la notaciÃ³n para el complemento de un\nconjunto escribiendo `\\compl` o `\\^c`.)\n\nEn este nivel, vamos a demostrar que la afirmaciÃ³n `x âˆˆ Aá¶œ â†” x âˆ‰ A` es verdadera, y para hacerlo\nusaremos una nueva tÃ¡ctica: `rfl`. La tÃ¡ctica `rfl` puede demostrar cualquier afirmaciÃ³n de la forma\n`P â†” Q` si `P` y `Q` son afirmaciones que son equivalentes por virtud de las definiciones de los\nsÃ­mbolos que aparecen en ellas. (Decimos en este caso que `P` y `Q` son *equivalentes por definiciÃ³n*.)\nLa tÃ¡ctica `rfl` tambiÃ©n puede demostrar afirmaciones de la forma `X = Y`,\nsi `X` e `Y` son iguales por definiciÃ³n.\n",
 "If you have `A : Set U` and `x : U`, then `mem_compl_iff A x` is a proof of the statement\n`x âˆˆ Aá¶œ â†” x âˆ‰ A`.  In Mathlib, the name of this theorem is `Set.mem_compl_iff`.":
 "Si tienes `x : U` y `A : Set U`, entonces `comp_def x A` es una prueba de la afirmaciÃ³n\n`x âˆˆ Aá¶œ â†” x âˆ‰ A`.",
 "If you had `hB : Â«{x}Â» âˆˆ B` and `hC : Â«{x}Â» âˆˆ C`, then `And.intro hB hC`\nwould prove the goal.  So there are two ways to proceed.  One possibility is to use\n`have` to introduce the assumptions `Â«{x}Â» âˆˆ B` and `Â«{x}Â» âˆˆ C`--that is, if you can see\nhow to justify those statements!  Then you can use `And.intro` to prove the goal.\n\nThe second possibility is to use the `apply` tactic.  Recall that if you write\n`apply And.intro`, then Lean will figure out that the\ntheorem `And.intro` could be applied to prove the goal, if only you had proofs of\n`Â«{x}Â» âˆˆ B` and `Â«{x}Â» âˆˆ C`.  So it will set those two statements as goals, to be proven\none after the other.":
 "Si tuvieras `hB : Â«{x}Â» âˆˆ B` y `hC : Â«{x}Â» âˆˆ C`, entonces `And.intro hB hC`\nprobarÃ­a el objetivo. AsÃ­ que hay dos maneras de proceder. Una posibilidad es usar\n`have` para introducir las suposiciones `Â«{x}Â» âˆˆ B` y `Â«{x}Â» âˆˆ C` -- si puedes ver\ncÃ³mo justificar esas declaraciones-- Luego puedes usar `And.intro` para probar el objetivo.\n\nLa segunda posibilidad es usar la tÃ¡ctica `apply`. Recuerda que si escribes\n`apply And.intro`, entonces Lean se darÃ¡ cuenta de que el\nteorema `And.intro` podrÃ­a aplicarse para probar el objetivo, solo necesitarÃ­as pruebas de\n`Â«{x}Â» âˆˆ B` y `Â«{x}Â» âˆˆ C`. Entonces establecerÃ­a esas dos declaraciones como objetivos, a ser probados uno tras otro.",
 "If the expression `t` is a proof of a statement of the form `P â†” Q`, then the tactic\n`rewrite [t]` will replace `P` anywhere that it occurs in the goal with `Q`.  If you want to\nreplace `Q` with `P`, use `rewrite [â† t]`.  (Type `\\l` to enter the symbol `â†`.)  To do the\nreplacement in an assumption `h`, use `rewrite [t] at h`.\n\nThe `rewrite` tactic can also be used with equations.  If `t` is a proof of an equation\n`p = q`, then `rewrite [t]` will replace `p` with `q` wherever it appears, and `rewrite [â† t]`\nwill replace `q` with `p`.\n\nTo do multiple replacements, one after another, put a list of proofs inside the brackets, like\nthis:  `rewrite [t1, t2]`.":
 "\"Si la expresiÃ³n `t` es una prueba de una afirmaciÃ³n de la forma `P â†” Q`, entonces la tÃ¡ctica\n`rewrite [t]` reemplazarÃ¡ `P` en cualquier lugar donde aparezca en la meta con `Q`. Si deseas\nreemplazar `Q` con `P`, usa `rewrite [â† t]`. (Escribe `\\l` para ingresar el sÃ­mbolo `â†`.) Para\nrealizar el reemplazo en una suposiciÃ³n `h`, usa `rewrite [t] at h`.\n\nLa tÃ¡ctica `rewrite` tambiÃ©n se puede usar con ecuaciones. Si `t` es una prueba de una ecuaciÃ³n\n`p = q`, entonces `rewrite [t]` reemplazarÃ¡ `p` con `q` dondequiera que aparezca, y `rewrite [â† t]`\nreemplazarÃ¡ `q` con `p`.\n\nPara realizar mÃºltiples reemplazos, uno despuÃ©s de otro, coloca una lista de pruebas dentro de los corchetes, asÃ­:\n`rewrite [t1, t2]`.\n",
 "If `Â«{x}Â» âˆˆ A`, then the goal is easy to prove.  This suggests breaking\nthe proof into cases depending on whether or not `Â«{x}Â» âˆˆ A`.  You can do this with the tactic\n`by_cases hA : Â«{x}Â» âˆˆ A`.":
 " Si `Â«{x}Â» âˆˆ A`, entonces es fÃ¡cil probar el objetivo. Esto sugiere dividir la prueba en casos segÃºn si `Â«{x}Â» âˆˆ A` o no. Puedes hacerlo con la tÃ¡ctica `by_cases hA : Â«{x}Â» âˆˆ A`.",
 "If `h` is a proof of a statement of the form `P âˆ¨ Q`, then the tactic\n`cases' h with h1 h2` will break your proof into cases.  In case 1, you'll have the new\nassumption `h1 : P`, and in case 2 you'll have `h2 : Q`.  In both cases you have to prove\nthe original goal.\n\nThe `cases'` tactic has other uses.  In particular, it can be applied to proofs of statements\nthat do not have the form `P âˆ¨ Q`.  However, we will not discuss these other uses of the\n`cases'` tactic in this game.":
 " Si `h` es una prueba de un enunciado de la forma `P âˆ¨ Q`, entonces la tÃ¡ctica\n`cases' h with h1 h2` dividirÃ¡ tu prueba en casos. En el caso 1, tendrÃ¡s la nueva\nsuposiciÃ³n `h1 : P`, y en el caso 2 tendrÃ¡s `h2 : Q`. En ambos casos tienes que probar\nel objetivo original.\n\nLa tÃ¡ctica `cases'` tiene otros usos. En particular, puede aplicarse a pruebas de enunciados\nque no tienen la forma `P âˆ¨ Q`. Sin embargo, no discutiremos estos otros usos de la\ntÃ¡ctica `cases'` en este juego.",
 "If `P` and `Q` are statements, then `P â†’ Q` means \"if P then Q\".\nTo enter the symbol `â†’`, type `\\imp` (short for \"implies\").\n\nThe most straightforward way to prove a statement of the form `P â†’ Q` is to assume that\n`P` is true and then prove `Q`.  To do that, we'll need a new tactic: `intro`.":
 "\nSi `P` y `Q` son afirmaciones, entonces `P â†’ Q` significa \"si P, entonces Q\".\nPara ingresar el sÃ­mbolo `â†’`, escribe `\\imp` (abreviatura de \"implica\").\n\nLa manera mÃ¡s directa de demostrar una afirmaciÃ³n de la forma `P â†’ Q` es asumir que\n`P` es verdadero y luego demostrar `Q`. Para hacer eso, necesitaremos una nueva tÃ¡ctica: `intro`.\n",
 "If `P x` represents a statement about an unspecified object `x`, then `âˆ€ x, P x` means\n\"for all `x`, `P x` is true\".  To enter the symbol `âˆ€`, type `\\forall`.":
 "Si `P x` representa un enunciado sobre un objeto no especificado `x`, entonces `âˆ€ x, P x` significa\n\"para todos los `x`, `P x` es verdadero\". Para ingresar el sÃ­mbolo `âˆ€`, teclee `\\forall`.",
 "If `P x` represents a statement about `x`, then `âˆƒ x, P x` means \"there is at least one\n`x` such that `P x` is true\".  To enter the symbol `âˆƒ`, type `\\exists`.":
 " Si `P x` representa un enunciado sobre `x`, entonces `âˆƒ x, P x` significa \"existe al menos un\n`x` tal que `P x` es verdadero\".  Para ingresar el sÃ­mbolo `âˆƒ`, escribe `\\exists`.",
 "If `P x` represents a statement about `x` and you have `h : P a`, for some object `a`, then\n`Exists.intro a h` is a proof of `âˆƒ x, P x`.":
 " Si `P x` representa un enunciado sobre `x` y tienes `h : P a`, para algÃºn objeto `a`, entonces\n`Exists.intro a h` es una prueba de `âˆƒ x, P x`.",
 "If `F` is a family of sets from `U`, then the *union* of `F` is the set of all objects from\n`U` that belong to at least one element of `F`.  We'll investigate unions of families in this\nworld.":
 " Si `F` es una familia de conjuntos de `U`, entonces la *uniÃ³n* de `F` es el conjunto de todos los objetos\nde `U` que pertenecen al menos a un elemento de `F`. Investigaremos uniones de familias en este\nmundo.",
 "If `F` and `G` are families of sets, what is `â‹‚â‚€ (F âˆª G)`?  In this level, you'll find out!":
 "Si `F` y `G` son familias de conjuntos, Â¿quÃ© es `â‹‚â‚€ (F âˆª G)`? En este nivel, lo veremos.",
 "If `A` is a set, then `compl_compl A` is a proof of `Aá¶œá¶œ = A`.":
 "Si `A` es un conjunto, entonces `compl_compl A` es una prueba de `Aá¶œá¶œ = A`.",
 "If `A` is a set of objects from the universe `U`, then the *complement* of `A`,\ndenoted `Aá¶œ`, is the set of all objects in the universe `U` that are *not*\nelements of `A`.\n\nFor example, if `U` consists of all people and `A` is the set of people who are more than\n6 feet tall, then `Aá¶œ` is the set of all people who are at most 6 feet tall.\n\nIn this world, we'll see how to prove theorems about complements.":
 "Si `A` es un conjunto de objetos del universo `U`, entonces el *complementario* de `A`,\ndenotado `Aá¶œ`, es el conjunto de todos los objetos en el universo `U` que no son\nelementos de `A`.\n\nPor ejemplo, si `U` consiste en todas las personas y `A` es el conjunto de personas que miden mÃ¡s de 2 metros, entonces `Aá¶œ` es el conjunto de todas las personas que miden a lo sumo 2 metros.\n\nEn este mundo, veremos cÃ³mo probar teoremas sobre complementarios.",
 "If `A` is a set and `F` is a family of sets, under what circumstances is it the case\nthat `A âŠ† â‹‚â‚€ F`?  In this level you'll discover the answer to that question.":
 " Si `A` es un conjunto y `F` es una familia de conjuntos, Â¿bajo quÃ© circunstancias es cierto que `A âŠ† â‹‚â‚€ F`? En este nivel descubrirÃ¡s la respuesta a esa pregunta.",
 "If `A` is a of objects from the universe `U`, then `Aá¶œ` is the complement of `A`; that is,\n`Aá¶œ` is the set of objects from `U` that are not elements of `A`.  You can enter the symbol `á¶œ`\nby typing `\\compl` or `\\^c`.":
 "Si `A` es un conjunto de objetos del universo `U`, entonces `Aá¶œ` es el complementario de `A`;\nes decir, `Aá¶œ` es el conjunto de objetos de `U` que no son elementos de `A`. Puedes ingresar el\nsÃ­mbolo `á¶œ` escribiendo `\\compl` o `\\^c`.",
 "If `A` and `B` are sets, then we say that `A` is a *subset* of `B` if\nevery element of `A` is also an element of `B`.  The notation `A âŠ† B` means\nthat `A` is a subset of `B`.  (To enter the symbol `âŠ†`, type `\\sub`,\nfollowed by a space.)\n\nIf you have `h1 : A âŠ† B`, then `h1` is a proof that, if something is an element\nof `A`, then it is also an element of `B`.  Thus, if you also have `h2 : x âˆˆ A`,\nthen you can apply `h1` to `h2` to conclude that `x âˆˆ B`.  To apply `h1` to `h2`,\nyou simply write `h1` followed by `h2`, with a space between them.  Thus, in\nthis situation, `h1 h2` is a proof of `x âˆˆ B`.\n\nSee if you can use this to complete this level.  If you need a hint, click on\n\"Show more help!\".":
 "\nSi `A` and `B` son conjuntos, decimos que `A` es un *subconjunto* de `B` si\ntodo elemento de `A` es tambiÃ©n un elemento de `B`. Esto lo denotamos como `A âŠ† B`.\n(Para introducir el sÃ­mbolo `âŠ†`, teclea `\\sub`, seguido por un espacio.)\n\nSi tienes `h1 : A âŠ† B`, entonces `h1` is una prueba de que, si algo es un elemento de `A`,\ntambiÃ©n es un elemento de `B`. AsÃ­, si tienes tambiÃ©n `h2 : x âˆˆ A`,\npuedes aplicar `h1` a `h2` para concluir que `x âˆˆ B`.  Para aplicar `h1` a `h2`,\nsimplemente escribe `h1` seguido de `h2`, con un espacio en medio. AsÃ­, en esta situaciÃ³n,\n`h1 h2` es una prueba de `x âˆˆ B`.\n\nIntenta completar este nivel. Si necesitas ayuda, pulsa en\n\"Show more help!\".\n",
 "If `A` and `B` are sets, then the *union* of `A` and `B`, denoted\n`A âˆª B`, is the set you get by throwing all the elements of `A` and `B`\ntogether into one set.  In other words, for an object to be an element of\n`A âˆª B`, it must be an element of either `A` or `B`, or both.\n\nFor example, if `A` is the set of all people under 30, and `B` is the set of\nall people over 20, then `A âˆª B` is the set of all people.\n\nIn this world you'll prove some basic properties of unions of sets.":
 " Si `A` y `B` son conjuntos, entonces la *uniÃ³n* de `A` y `B`, denotada\n`A âˆª B`, es el conjunto que se obtiene al poner todos los elementos de `A` y `B`\njuntos en un solo conjunto. En otras palabras, para que un objeto sea un elemento de\n`A âˆª B`, debe ser un elemento de `A` o de `B`, o de ambos.\n\nPor ejemplo, si `A` es el conjunto de todas las personas menores de 30, y `B` es\nel conjunto de todas las personas mayores de 20, entonces `A âˆª B` es el conjunto de\ntodas las personas.\n\nEn este mundo demostrarÃ¡s algunas propiedades bÃ¡sicas de uniones de conjuntos.",
 "If `A` and `B` are sets, then the *intersection* of `A` and `B`, denoted\n`A âˆ© B`, is the set of elements that the two sets have in common.  In other words,\nfor an object to be an element of `A âˆ© B`, it must be an element of both `A` and `B`.\n\nFor example, if `A` is the set of all round things, and `B` is the set of all red things,\nthen `A âˆ© B` is the set of all round red things.\n\nIn this world you'll prove some basic properties of intersections of sets.":
 " Si `A` y `B` son conjuntos, entonces la *intersecciÃ³n* de `A` y `B`, denotada por\n`A âˆ© B`, es el conjunto de elementos que los dos conjuntos tienen en comÃºn. En otras palabras,\npara que un objeto sea un elemento de `A âˆ© B`, debe ser un elemento tanto de `A` como de `B`.\n\nPor ejemplo, si `A` es el conjunto de todas las cosas redondas y `B` es el conjunto de todas las cosas rojas,\nentonces `A âˆ© B` es el conjunto de todas las cosas redondas rojas.\n\nEn este mundo demostrarÃ¡s algunas propiedades bÃ¡sicas de las intersecciones de conjuntos.",
 "If `A` and `B` are sets, then `A âˆª B` is the union of `A` and `B`.\nTo enter the symbol `âˆª`, type `\\union`.":
 "Si `A` y `B` son conjuntos, entonces `A âˆª B` es la uniÃ³n de `A` y `B`.\nPara escribir el sÃ­mbolo `âˆª`, teclea `\\union`.",
 "If `A` and `B` are sets, then `A âˆ© B` is the intersection of `A` and `B`.\nTo enter the symbol `âˆ©`, type `\\inter` or `\\cap`.":
 "Si `A` y `B` son conjuntos, entonces `A âˆ© B` es la intersecciÃ³n de `A` y `B`.\nPara escribir el sÃ­mbolo `âˆ©`, teclea `\\inter` o `\\cap`.",
 "How do you prove that one set is a subset of another?  To prove that `A âŠ† B`,\nyou have to show that if some object `x` is an element of `A`, then it is also\nan element of `B`.  To do that, you'll have to introduce an object called `x` into\nthe proof.  The object denoted by `x` could be anything, so we say that it is\n*arbitrary*.\n\nIn this level, we start with a simple example of this kind of proof.  We're going\nto show that if `A` is a set, then `A âŠ† A`.":
 "\nÂ¿CÃ³mo demuestras que un conjunto es un subconjunto de otro? Para demostrar que `A âŠ† B`,\ntienes que mostrar que si algÃºn objeto `x` es un elemento de `A`, entonces tambiÃ©n lo es\nun elemento de `B`. Para hacer eso, tendrÃ¡s que introducir un objeto `x` en\nla prueba. Este elemento `x` podrÃ­a ser cualquiera, asÃ­ que decimos que es *arbitrario*.\n\nEn este nivel, comenzamos con un ejemplo simple de este tipo de prueba. Vamos a mostrar\nque si `A` es un conjunto, entonces `A âŠ† A`.\n",
 "How do we prove that two sets `A` and `B` are equal?  One way to do it is to use the theorem\n`Subset.antisymm`.  This theorem is pre-defined in this game; you don't need to prove it.\nIf you have `h1 : A âŠ† B` and `h2 : B âŠ† A`, then\n`Subset.antisymm h1 h2` is a proof of `A = B`.  The theorem `Subset.antisymm` says that the\nsubset relation has a property called *antisymmetry*.\n\nBut what if you don't already know `A âŠ† B` and `B âŠ† A`?  In that case, you can use a new\ntactic, `apply`.  If your goal is `A = B` and you write `apply Subset.antisymm`, then Lean will\nfigure out that the theorem `Subset.antisymm` could be applied to prove the goal, if only you had\nproofs of `A âŠ† B` and `B âŠ† A`.  So it will set those *two* statements as goals.\n\nIf your goal says that two sets are equal, a good way to begin is with\n`apply Subset.antisymm`.  (Later we'll see a second approach to proving sets are equal.)\n\nThis level also introduces another new tactic, `push_neg`.":
 "Â¿CÃ³mo demostramos que dos conjuntos `A` y `B` son iguales? Una manera de hacerlo es utilizar el teorema\n`Subset.antisymm`. Este teorema estÃ¡ predefinido en este juego; no necesitas probarlo.\nSi tienes `h1 : A âŠ† B` y `h2 : B âŠ† A`, entonces\n`Subset.antisymm h1 h2` es una prueba de `A = B`. El teorema `Subset.antisymm` dice que la\nrelaciÃ³n de subset tiene una propiedad llamada *antisimetrÃ­a*.\n\nPero Â¿quÃ© pasa si aÃºn no sabes que `A âŠ† B` y `B âŠ† A`? En ese caso, puedes usar una nueva\ntÃ¡ctica, `apply`. Si tu objetivo es `A = B` y escribes `apply Subset.antisymm`, entonces Lean\nverÃ¡ que el teorema `Subset.antisymm` podrÃ­a aplicarse para probar el objetivo, si tuvieras\npruebas de `A âŠ† B` y `B âŠ† A`. Entonces establecerÃ¡ esos *dos* enunciados como objetivos a demostrar.\n\nSi tu objetivo dice que dos conjuntos son iguales, una buena manera de empezar es con\n`apply Subset.antisymm`. (MÃ¡s tarde veremos un segundo enfoque para probar que los conjuntos son iguales.)\n\nEste nivel tambiÃ©n introduce otra nueva tÃ¡ctica, `push_neg`.",
 "Here's an idea that you may find helpful for this proof:\nIf you're proving an \"or\" statement and you think you'll be\nable to prove either the left or right side of the statement, then `apply Or.inl` or\n`apply Or.inr` will set the goal to be the left or right side.  Alternatively, the tactic\n`left` has the same effect as `apply Or.inl`, and `right` has the same effect as\n`apply Or.inr`.\n\nYou can start this proof with either `ext x` or `apply Subset.antisymm`.":
 " AquÃ­ tienes una idea que tal vez te sea Ãºtil para esta prueba:\nSi estÃ¡s probando una declaraciÃ³n \"o\" y crees que podrÃ¡s probar\nel lado izquierdo o derecho de la declaraciÃ³n, entonces `apply Or.inl` o\n`apply Or.inr` establecerÃ¡ el lado izquierdo o derecho como objetivo. Alternativamente, la tÃ¡ctica\n`left` tiene el mismo efecto que `apply Or.inl`, y `right` tiene el mismo efecto que\n`apply Or.inr`.\n\nPuedes empezar esta prueba con  `ext x` o `apply Subset.antisymm`.",
 "Here's an approach you might try:  If only you had `hFG : Â«{t}Â» âˆˆ F âˆª G`, then\n`Â«{h1}Â» Â«{t}Â» hFG` would prove the goal.  So if you use the tactic `apply Â«{h1}Â» Â«{t}Â»`, Lean\nwill figure out that `Â«{h1}Â» Â«{t}Â»` could be applied to a proof of `Â«{t}Â» âˆˆ F âˆª G` to prove\nthe goal, and it will therefore set `Â«{t}Â» âˆˆ F âˆª G` as your goal.":
 "Este es un enfoque que podrÃ­as probar: si tuvieras `hFG : Â«{t}Â» âˆˆ F âˆª G`, entonces `Â«{h1}Â» Â«{t}Â» hFG` probarÃ­a el objetivo. Entonces, si usas la tÃ¡ctica `apply Â«{h1}Â» Â«{t}Â»`, Lean\nverÃ¡ que `Â«{h1}Â» Â«{t}Â»` podrÃ­a aplicarse a una prueba de `Â«{t}Â» âˆˆ F âˆª G` para probar el objetivo, y por lo tanto establecerÃ¡ `Â«{t}Â» âˆˆ F âˆª G` como su objetivo.",
 "Here's a theorem about three related families of sets.":
 " AquÃ­ hay un teorema sobre tres familias de conjuntos relacionadas.",
 "Fortunately, we can use the theorem `compl_compl` to prove `Aá¶œá¶œ = A` and\n`Bá¶œá¶œ = B`, and those statements should get us from `Â«{h2}Â»` to the goal.\nWe have seen in previous levels that the `rewrite` tactic can be applied to a proof of a\nstatement of the form `P â†” Q` to replace `P` with `Q`.  The tactic can also be applied to\nequations: if `t` is a proof of an equation `p = q`, then `rewrite [t]` will\nreplace `p` with `q`.":
 "Por suerte, podemos usar el teorema `compl_compl` para probar `Aá¶œá¶œ = A` y `Bá¶œá¶œ = B`, y esos enunciados deberÃ­an llevarnos desde `Â«{h2}Â»` hasta el objetivo.\nHemos visto en niveles anteriores que la `tÃ¡ctica rewrite` puede aplicarse a una prueba de un enunciado de la forma `P â†” Q` para reemplazar `P` con `Q`. La tÃ¡ctica tambiÃ©n puede aplicarse a ecuaciones: si `t` es una prueba de una ecuaciÃ³n `p = q`, entonces `rewrite [t]` reemplazarÃ¡ `p` por `q`.",
 "Fortunately, the theorem `compl_subset_compl_of_subset` can now be used to prove the goal.\n(Click on `compl_subset_compl_of_subset` in the list of theorems on the right if you don't\nremember what the theorem says.)":
 "Por suerte, el teorema `compl_subset_compl_of_subset` puede usarse ahora para probar el objetivo.\n(Haz click en `compl_subset_compl_of_subset` en la lista de teoremas a la derecha si no recuerdas\nquÃ© dice el teorema.)",
 "For working with unions, the important logical word is \"or\".\n\nIf `P` and `Q` are statements, then `P âˆ¨ Q` means \"P or Q or both\".  To enter the\nsymbol `âˆ¨`, type `\\or`.  For the statement `P âˆ¨ Q` to be true, either `P` or `Q` must\nbe true.  This gives us two ways to prove a statement of this form.  If you have\n`h : P`, then `Or.inl h` can be used to prove `P âˆ¨ Q`.  If you have `h : Q`, then\n`Or.inr h` proves `P âˆ¨ Q`.":
 " Para trabajar con uniones, la palabra lÃ³gica importante es \"o\".\n\nSi `P` y `Q` son enunciados, entonces `P âˆ¨ Q` significa \"P o Q o ambos\".  Para escribir el sÃ­mbolo `âˆ¨`, teclea `\\or`.  Para que la declaraciÃ³n `P âˆ¨ Q` sea verdadera, se debe cumplir al menos una de las siguientes condiciones: `P` o `Q`.  Esto nos da dos maneras de probar un enunciado de esta forma.  Si tienes `h : P`, entonces `Or.inl h` puede utilizarse para probar `P âˆ¨ Q`.  Si tienes `h : Q`, entonces `Or.inr h` demuestra `P âˆ¨ Q`.",
 "For the theorem in this level, your goal is `Â¬A âŠ† B`.  To use proof by contradiction\nin this proof, you must begin by introducing the assumption `h3 : A âŠ† B`.  To do that, type\n`by_contra h3`":
 "Para el teorema en este nivel, tu objetivo es `Â¬A âŠ† B`. Para utilizar la prueba por contradicciÃ³n\n  en esta demostraciÃ³n, debes comenzar introduciendo la suposiciÃ³n `h3 : A âŠ† B`. Para hacerlo, escribe\n  `by_contra h3`.",
 "For the second case, which half of the goal do you think you should try to prove?\nYou can use `apply Or.inl` or `apply Or.inr` (or the equivalent tactics `left` or `right`)\nto specify what goal you're going to prove.":
 " Para el segundo caso, Â¿quÃ© mitad del objetivo crees que deberÃ­as intentar probar?\nPuedes usar `apply Or.inl` o `apply Or.inr` (o las tÃ¡cticas equivalentes `left` o `right`)\npara especificar quÃ© objetivo vas a probar.",
 "For the proof in this level, `apply Iff.intro` will create the goals `A âŠ† B â†’ Bá¶œ âŠ† Aá¶œ`\nand `Bá¶œ âŠ† Aá¶œ â†’ A âŠ† B`.":
 "Para la prueba en este nivel, `apply Iff.intro` crearÃ¡ los objetivos `A âŠ† B â†’ Bá¶œ âŠ† Aá¶œ` y `Bá¶œ âŠ† Aá¶œ â†’ A âŠ† B`.",
 "For any sets `A`, `B`, and `C`, `union_distrib_left A B C` is a proof of the\nstatement `A âˆª (B âˆ© C) = (A âˆª B) âˆ© (A âˆª C)`.  In Mathlib, the name of this theorem\nis `Set.union_distrib_left`.":
 "Para cualesquiera conjuntos `A`, `B` y `C`, `union_distrib_left A B C` es una prueba del enunciado `A âˆª (B âˆ© C) = (A âˆª B) âˆ© (A âˆª C)`. En Mathlib, el nombre de este teorema es `Set.union_distrib_left`.",
 "For any sets `A`, `B`, and `C`, `union_assoc A B C` is a proof of the\nstatement `(A âˆª B) âˆª C = A âˆª (B âˆª C)`.  In Mathlib, the name of this theorem is `Set.union_assoc`.":
 " Para cualesquiera conjuntos `A`, `B` y `C`, `union_assoc A B C` es una prueba del enunciado `(A âˆª B) âˆª C = A âˆª (B âˆª C)`. En Mathlib, el nombre de este teorema es `Set.union_assoc`.",
 "For any sets `A`, `B`, and `C`, `inter_distrib_left A B C` is a proof of the\nstatement `A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C)`.  In Mathlib, the name of this theorem\nis `Set.inter_distrib_left`.":
 "Para cualesquiera conjuntos `A`, `B` y `C`, `inter_distrib_left A B C` es una prueba de `A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C)`. En Mathlib, el nombre de este teorema es `Set.inter_distrib_left`.",
 "For any sets `A`, `B`, and `C`, `inter_assoc A B C` is a proof of the\nstatement `(A âˆ© B) âˆ© C = A âˆ© (B âˆ© C)`.  Im Mathlib, the name of this theorem is `Set.inter_assoc`.":
 "Para cualesquiera conjuntos `A`, `B` y `C`, `inter_assoc A B C` es una prueba de `(A âˆ© B) âˆ© C = A âˆ© (B âˆ© C)`. En Mathlib, el nombre de este teorema es `Set.inter_assoc`.",
 "For any sets `A` and `B`, `union_sub_swap A B` is a proof of\n`A âˆª B âŠ† B âˆª A`.":
 " Para cualesquiera conjuntos `A` y `B`, `union_sub_swap A B` es una prueba de\n`A âˆª B âŠ† B âˆª A`.",
 "For any sets `A` and `B`, `union_comm A B` is a proof of the\nstatement `A âˆª B = B âˆª A`.  In Mathlib, the name of this theorem is `Set.union_comm`.":
 " Para cualesquiera conjuntos `A` y `B`, `union_comm A B` es una prueba de\n`A âˆª B = B âˆª A`. En Mathlib, el nombre de este teorema es `Set.union_comm`.",
 "For any sets `A` and `B`, `inter_subset_swap A B` is a proof of\n`A âˆ© B âŠ† B âˆ© A`.":
 "Para cualesquiera conjuntos `A` y `B`, `inter_subset_swap A B` es una prueba de\n`A âˆ© B âŠ† B âˆ© A`.",
 "For any sets `A` and `B`, `inter_comm A B` is a proof of the\nstatement `A âˆ© B = B âˆ© A`.  In Mathlib, the name of this theorem is `Set.inter_comm`.":
 "Para cualesquiera conjuntos `A` y `B`, `inter_comm A B` es una prueba de\n`A âˆ© B = B âˆ© A`. En Mathlib, el nombre de este teorema es  `Set.inter_comm`.",
 "For any sets `A` and `B`, `compl_union A B` is a proof of the\nstatement `(A âˆª B)á¶œ = Aá¶œ âˆ© Bá¶œ`.  In Mathlib, the name of this theorem is `Set.compl_union`.":
 " Para cualesquiera conjuntos `A` y `B`, `compl_union A B` es una prueba de\n `(A âˆª B)á¶œ = Aá¶œ âˆ© Bá¶œ`. En Mathlib, el nombre de este teorema es `Set.compl_union`.",
 "For any sets `A` and `B`, `compl_inter A B` is a proof of the\nstatement `(A âˆ© B)á¶œ = Aá¶œ âˆª Bá¶œ`.  In Mathlib, the name of this theorem is `Set.compl_inter`.":
 "Para cualesquiera conjuntos `A` y `B`, `compl_inter A B` es una prueba del enunciado `(A âˆ© B)á¶œ = Aá¶œ âˆª Bá¶œ`.  En Mathlib, el nombre de este teorema es `Set.compl_inter`.",
 "For any sets $A$, $B$, and $C$, $A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)$.":
 "Dados tres conjuntos $A$, $B$, y $C$, $A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)$.",
 "For any sets $A$, $B$, and $C$, $A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C)$.":
 "Para cualesquiera conjuntos `A`, `B`, y `C`, `A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C)`.",
 "For any sets $A$, $B$, and $C$, $(A \\cup B) \\cup C = A \\cup (B \\cup C)$.":
 " Para cualesquiera conjuntos $A$, $B$ y $C$, $(A \\cup B) \\cup C = A \\cup (B \\cup C)$.",
 "For any sets $A$, $B$, and $C$, $(A \\cap B) \\cap C = A \\cap (B \\cap C)$.":
 " Para cualesquiera conjuntos $A$, $B$ y $C$, $(A \\cap B) \\cap C = A \\cap (B \\cap C)$.",
 "For any sets $A$ and $B$, $A \\cup B \\subseteq B \\cup A$.":
 " Para cualesquiera conjuntos `A` y `B`, `A âˆª B âŠ† B âˆª A`.",
 "For any sets $A$ and $B$, $A \\cup B = B \\cup A$.":
 " Para cualesquiera conjuntos `A` y `B`, `A âˆª B = B âˆª A`.",
 "For any sets $A$ and $B$, $A \\cap B \\subseteq B \\cap A$.":
 "Para cualesquiera conjuntos `$A$` y `$B$`, `$A \\cap B \\subseteq B \\cap A$`.",
 "For any sets $A$ and $B$, $A \\cap B \\subseteq A$.":
 " Para cualesquiera conjuntos `A` y `B`, `A âˆ© B âŠ† A`.",
 "For any sets $A$ and $B$, $A \\cap B = B \\cap A$.":
 "Para cualesquiera conjuntos `A` y `B`, `A âˆ© B = B âˆ© A`.",
 "For any sets $A$ and $B$, $(A \\cup B)^c = A^c \\cap B^c$.":
 " Para cualesquiera conjuntos $A$ y $B$, $(A \\cup B)^c = A^c \\cap B^c$.",
 "For any sets $A$ and $B$, $(A \\cap B)^c = A^c \\cup B^c$.":
 "Para cualesquiera conjuntos $A$ y $B$, $(A \\cap B)^c = A^c \\cup B^c$.",
 "For any family of sets $F$, $(\\bigcup F)^c = \\bigcap \\{s \\mid s^c \\in F\\}$.":
 " Para cualquier familia de conjuntos $F$, $(\\bigcup F)^c = \\bigcap \\{s \\mid s^c \\in F\\}$.",
 "For any family of sets $F$, $(\\bigcap F)^c = \\bigcup \\{s \\mid s^c \\in F\\}$.":
 " Para cualquier familia de conjuntos $F$, $( \\bigcap F )^c = \\bigcup \\{s \\mid s^c \\in F\\}$.",
 "For any `t`, `A`, and `B`, `mem_pair t A B` is a proof of the statement\n`t âˆˆ {A, B} â†” t = A âˆ¨ t = B`.":
 " Para cualquier `t`, `A`, y `B`, `mem_pair t A B` es una prueba del enunciado\n`t âˆˆ {A, B} â†” t = A âˆ¨ t = B`.",
 "First use `have` to assert that `Â«{x}Â» âˆˆ B`, and\nthen prove `Â«{x}Â» âˆˆ C`.":
 "Usa `have` para afirmar que `Â«{x}Â» âˆˆ B`, y despuÃ©s demuestra `Â«{x}Â» âˆˆ C`.",
 "Family intersection is subset":
 "La intersecciÃ³n de una familia es un subconjunto",
 "Family Union World": "Mundo de la uniÃ³n de familias",
 "Family Intersection World": "Mundo de las intersecciones de familias",
 "Family Combination World": "Mundo combinado de familias.",
 "Element of an intersection": "Elementos de una intersecciÃ³n",
 "Does your situation now remind you of a previous level?":
 "Â¿Te recuerda esta situaciÃ³n al nivel anterior?",
 "Do you see why `Â«{s}Â»` is the value to use as a witness for `t` in the goal?\nYour next step can be either `apply Exists.intro Â«{s}Â»` or `use Â«{s}Â»`.":
 " Â¿Ves por quÃ© `Â«{s}Â»` es el valor que se debe usar como testigo para `t` en el objetivo?\nTu siguiente paso puede ser `apply Exists.intro Â«{s}Â»` o `use Â«{s}Â»`.",
 "Do you see how you can now use the theorem from the previous level?":
 " Â¿Ves cÃ³mo ahora puedes usar el teorema del nivel anterior?",
 "Do you know which half of the goal you're going to prove now?":
 " Â¿Sabes quÃ© mitad del objetivo vas a probar ahora?",
 "Definition of complement": "DefiniciÃ³n de complementario",
 "Congratulations! You have completed your first verified proof!\n\nAlthough this theorem was trivial, it illustrates an important fact: although we\ncalled `h` an *identifier* for the assumption `x âˆˆ A`, it is also recognized by Lean\nas a *proof* of the statement `x âˆˆ A`.  Any time you see `h : P`\nlisted as an assumption, where `P` is some statement, that means that Lean will\nrecognize `h` as a proof of the statement `P`.\n\nRemember that `exact` is a *tactic*. If you ever want information about the `exact` tactic,\nyou can click on `exact` in the list of tactics on the right.\n\nNote that, although `h` was a proof of the goal `x âˆˆ A`, you could not have closed the goal by\nsimply typing `h` in the text box.  Throughout this game, every move you make must invoke a tactic.\n\nNow click on \"Next\" to see a more interesting use of the `exact` tactic.":
 "\nÂ¡Enhorabuena! Has completado tu primera demostraciÃ³n.\n\nAunque este teorema era trivial, ilustra un hecho importante:\naunque llamamos a `h` un *identificador* para la suposiciÃ³n `x âˆˆ A`,\ntambiÃ©n es reconocido por Lean como una *prueba* de la afirmaciÃ³n `x âˆˆ A`.\nCada vez que veas `h : P` enumerado como una suposiciÃ³n, donde `P` es alguna afirmaciÃ³n,\neso significa que Lean reconocerÃ¡ `h` como una prueba de la afirmaciÃ³n `P`.\n\nRecuerda que `exact` es una *tÃ¡ctica*. Si alguna vez quieres obtener informaciÃ³n sobre la tÃ¡ctica `exact`,\npuedes pulsar en `exact` en la lista de tÃ¡cticas a la derecha.\n\nAhora pulsa en \"Next\" para ver un uso mÃ¡s interesante de la tÃ¡ctica `exact`.\n",
 "Congratulations!  You have completed the Set Theory Game!\n\nIf you want to learn more about Lean, check out the [Lean Community](https://leanprover-community.github.io).":
 " Enhorabuena! Has completado el Juego de TeorÃ­a de Conjuntos.\n\nSi quieres aprender mÃ¡s sobre Lean, visita la [Comunidad Lean](https://leanprover-community.github.io).",
 "Complement subsets from subsets": "Conjuntos complementaros de subconjuntos",
 "Complement subsets equivalence":
 "Equivalencia de contenido de complementarios",
 "Complement of an intersection": "Complementario de una intersecciÃ³n",
 "Complement of a union": "Complementario de una uniÃ³n",
 "Complement of a family union": "Complementario de la uniÃ³n de una familia",
 "Complement of a family intersection":
 "Complementario de la intersecciÃ³n de una familia",
 "Complement of a complement": "Complementario de un complementario",
 "Complement World": "Mundo de los complementarios",
 "Combination World": "Mundo combinado",
 "By the way, another set that would have worked as a witness for the existential goal in this\ntheorem is the empty set, denoted `âˆ…`.  However, to justify the use of that witness you would\nhave had to prove `âˆ… âŠ† A`.  Since we already have the theorem `Subset.refl`, it was easier to use\n`A` as the witness.\n\nNow that you know how to prove existential statements, you're ready to start working with\nunions of families.":
 " Por cierto, otro conjunto que habrÃ­a funcionado como testigo para el objetivo existencial en este\nteorema es el conjunto vacÃ­o, denotado `âˆ…`. Sin embargo, para justificar el uso de ese testigo\nhabrÃ­as tenido que probar `âˆ… âŠ† A`. Dado que ya tenemos el teorema `Subset.refl`, fue mÃ¡s fÃ¡cil\nusar `A` como testigo.\n\nAhora que sabes cÃ³mo probar enunciados existenciales, estÃ¡s listo para comenzar a trabajar con\nuniones de familias.",
 "As you saw in the previous level, you can now apply `h1` to `Â«{h3}Â»`\nto justify asserting `x âˆˆ B`, using the `have` tactic.":
 "Como vimos en el nivel anterior, puedes aplicar `h1` a `Â«{h3}Â»`\npara justificar que `x âˆˆ B`, usando la tÃ¡ctica `have`.",
 "As with complements and intersections, one of the key tools for proving theorems about unions\nis a theorem stating the definition.  If you have `x : U`, `A : Set U`, and `B : Set U`,\nthen `mem_union x A B` is a proof of the statement `x âˆˆ A âˆª B â†” x âˆˆ A âˆ¨ x âˆˆ B`.\nThat means you can use `rewrite [mem_union]` to write out the definition of\n`x âˆˆ A âˆª B` if it appears in any assumption or the goal.  (The similar theorem about intersections\nwas called `mem_inter_iff`.  Why isn't this one called `mem_union_iff`?  I don't know.  The\nnaming of theorems in Lean is systematic, but there are occasional surprises.)":
 "Como con los complementarios e intersecciones, una de las herramientas clave para probar los teoremas sobre uniones\nes un teorema que establece la definiciÃ³n. Si tienes `x : U`, `A : Set U` y `B : Set U`,\nentonces `mem_union x A B` es una prueba del enunciado `x âˆˆ A âˆª B â†” x âˆˆ A âˆ¨ x âˆˆ B`.\nEso significa que puedes usar `rewrite [mem_union]` para escribir la definiciÃ³n de\n`x âˆˆ A âˆª B` si aparece en alguna suposiciÃ³n o el objetivo. (El teorema similar sobre intersecciones\nse llamaba `mem_inter_iff`. Â¿Por quÃ© no se llama a este `mem_union_iff`? No lo sÃ©. La denominaciÃ³n de los teoremas en Lean es sistemÃ¡tica, pero de  vez en cuando hay sorpresas.)",
 "As we saw in the last level, `h2 Â«{h4}Â»` is now\na proof of the goal, so `exact h2 Â«{h4}Â»` will close the goal.":
 "Como vimos en el anterior nivel, `h2 {h4}` es ahora una prueba\n  del objetivo, asÃ­ que `exact h2 {h4}` cerrarÃ¡ el objetivo.",
 "As we saw in Complement World, a good first step when your goal is an equation between\nsets is `apply Subset.antisymm`.  For the theorem in this level, that will leave you with\ntwo goals: `A âˆ© B âŠ† B âˆ© A` and `B âˆ© A âŠ† A âˆ© B`.  Fortunately, you can prove *both* of these\ngoals by using the theorem `inter_subset_swap` from the last level.":
 " Como vimos en el Mundo de los complementarios, un buen primer paso cuando tu objetivo es una igualdad entre conjuntos es `apply Subset.antisymm`.  Para el teorema en este nivel, eso te dejarÃ¡ con dos objetivos: `A âˆ© B âŠ† B âˆ© A` y `B âˆ© A âŠ† A âˆ© B`.  Afortunadamente, puedes probar *ambos* estos enunciados utilizando el teorema `inter_subset_swap` del Ãºltimo nivel.",
 "As usual, you may find it helpful to use the `rewrite` tactic to write out the\ndefinition of `Â«{x}Â» âˆˆ â‹‚â‚€ F`, using the theorem `mem_sInter`.":
 "Como de costumbre, puede que resultar Ãºtil utilizar la tÃ¡ctica `rewrite` para escribir la definiciÃ³n de `Â«{x}Â» âˆˆ â‹‚â‚€ F`, utilizando el teorema `mem_sInter`.",
 "As usual, to prove a subset statement you need to introduce both a new object `x` and\na new assumption `h2`.  You can do it in one step with `intro x h2`.":
 "Como de costumbre, para demostrar un contenido, necesitas introducir un nuevo objeto `x` y\n  una nueva suposiciÃ³n `h2`.  Puedes hacerlo de golpe con `intro x h2`.",
 "As usual, if you're not sure how to proceed then writing\nout definitions can help.":
 "Como de costumbre, si no sabes cÃ³mo seguir; escribir las definiciones puede ser Ãºtil.",
 "And": "Y",
 "Although `âˆ…` is a reasonable choice for a set that is a subset of `A`, it is difficult\nto complete the proof with this choice using only methods developed so far in this game.\nGo back and try a different choice.":
 " A pesar de que `âˆ…` es una opciÃ³n razonable para un conjunto que es subconjunto de `A`, es difÃ­cil completar la prueba con esta elecciÃ³n usando solo los mÃ©todos desarrollados hasta ahora en este juego. Vuelve atrÃ¡s e intenta una elecciÃ³n diferente.",
 "Again, work out the consequences of `Â«{h1}Â»` first.":
 " En primer lugar, trabaja en las consecuencias de `Â«{h1}Â»`.",
 "A union intersected with the complement of another is a subset":
 " Una uniÃ³n intersecada con el complemento de otra es un subconjunto.",
 "A union intersected with the complement of an intersection":
 " Una uniÃ³n intersecada con el complemento de una intersecciÃ³n.",
 "A tricky subset proof": "Una prueba mÃ¡s difÃ­cil",
 "A theorem about three families": "Un teorema sobre tres familias",
 "A subset of a union intersected with the complement of another":
 " Un subconjunto de la uniÃ³n intersecada con el complemento de otra",
 "A subset hypothesis": "Una hipÃ³tesis sobre subconjuntos",
 "A set that must be a singleton":
 " Un conjunto que debe ser un elemento Ãºnico",
 "A game about set theory.": " Un juego sobre la teorÃ­a de conjuntos.",
 "*Game version: 4.4*\n\n## Progress saving\n\nThe game stores your progress in your local browser storage.\nIf you delete it, your progress will be lost!\n\nWarning: In most browsers, deleting cookies will also clear the local storage\n(or \"local site data\"). Make sure to download your game progress first!\n\n## Credits\n\n* **Creator:** Daniel J. Velleman; based on the Natural Numbers Game, by Kevin Buzzard\n* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n\n## Resources\n\n* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\n\n## Problems?\n\nPlease ask any questions about this game in the\n[Lean Zulip chat](https://leanprover.zulipchat.com/) forum, for example in\nthe stream \"New Members\". The community will happily help. Note that\nthe Lean Zulip chat is a professional research forum.\nPlease use your full real name there, stay on topic, and be nice. If you're\nlooking for somewhere less formal (e.g. you want to post set theory\ngame memes) then head on over to the [Lean Discord](https://discord.gg/WZ9bs9UCvx).\n\nAlternatively, if you experience issues / bugs you can also open github issues:\n\n* For issues with the game engine, please open an\n[issue at the lean4game repo](https://github.com/leanprover-community/lean4game/issues).\n* For issues about the game's content, please open an\n[issue at the STG repo](https://github.com/djvelleman/STG4/issues).":
 "*VersiÃ³n del juego: 4.4*## Almacenamiento de progreso El juego almacena tu progreso en el almacenamiento local de tu navegador.Si lo eliminas, perderÃ¡s tu progreso!AtenciÃ³n: En la mayorÃ­a de los navegadores, eliminar las cookies tambiÃ©n limpiarÃ¡ el almacenamiento local (o \"datos del sitio local\"). AsegÃºrese de descargar su progreso en el juego primero!## CrÃ©ditos* **Creador:** Daniel J. Velleman; basado en el Juego de nÃºmeros naturales, por Kevin Buzzard* **Motor del juego:** Alexander Bentkamp, Jon Eugster, Patrick Massot## Recursos* El [Lean Zulip chat](https://leanprover.zulipchat.com/) foro## Problemas?Por favor, pregunte cualquier duda sobre este juego en el[Lean Zulip chat](https://leanprover.zulipchat.com/) foro, por ejemplo en el flujo \"Miembros nuevos\". La comunidad estarÃ¡ encantada de ayudar. Note que el Lean Zulip chat es un foro de investigaciÃ³n profesional.Por favor, use su nombre completo y real allÃ­, cÃ©ntrese en el tema y sea amable. Si estÃ¡ buscando un lugar menos formal (por ejemplo, desea publicar memes del juego de la teorÃ­a de conjuntos)entonces dirÃ­jase al [Lean Discord](https://discord.gg/WZ9bs9UCvx).Alternativamente, si experimenta problemas / errores puede abrir issues en github:* Para problemas con el motor del juego, por favor abra un[issue en el repo de lean4game](https://github.com/leanprover-community/lean4game/issues).* Para problemas sobre el contenido del juego, por favor abra un[issue en el repo STG](https://github.com/djvelleman/STG4/issues).",
 "# Welcome to the Set Theory Game\n#### An introduction to mathematical proof.\n\nIn this game, you will solve a sequence of levels by proving theorems.  The game\nis based on an interactive theorem prover called *Lean*.\n\nThe theorems in this game will be about sets.\nA *set* is a collection of objects; the objects in the collection are\ncalled *elements* of the set.  For example, the set of planets in our\nsolar system has eight elements:\nMercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and Neptune.\n\n# Read this.\n\nLearning how to use an interactive theorem prover takes time.\nYou will get the most out of this game if you\nread the help texts like this one.\n\nTo start, click on \"Subset World\".\n\n## More\n\nOpen \"Game Info\" in the \"â‰¡\" menu on the top right for resources,\nlinks, and ways to interact with the Lean community.":
 " # Bienvenido al Juego de TeorÃ­a de Conjuntos\n#### Una introducciÃ³n a la prueba matemÃ¡tica.\n\nEn este juego, resolverÃ¡s una secuencia de niveles demostrando teoremas. El juego se basa en un verificador de teoremas interactivo llamado *Lean*.\n\nLos teoremas de este juego serÃ¡n sobre conjuntos. Un *conjunto* es una colecciÃ³n de objetos; los objetos en la colecciÃ³n se denominan *elementos* del conjunto. Por ejemplo, el conjunto de planetas en nuestro sistema solar tiene ocho elementos:\nMercurio, Venus, Tierra, Marte, JÃºpiter, Saturno, Urano y Neptuno.\n\n# Importante.\n\nAprender a usar un verificador de teoremas interactivo toma tiempo. ObtendrÃ¡s el mÃ¡ximo beneficio de este juego si lees los textos de ayuda como este.\n\nPara comenzar, haga clic en \"Subset World\".\n\n## MÃ¡s\n\nAbra \"InformaciÃ³n del juego\" en el menÃº \"â‰¡\" en la esquina superior derecha para recursos, enlaces y formas de interactuar con la comunidad de Lean.",
 "# Read this first\n\nEach level in this game involves proving a mathematical statement (the \"Goal\").\nWhen you give a proof of this statement that\nis accepted by Lean, we say that you have *closed* the goal.\n\nIn this first level you're going to prove that if `x` belongs to the universe `U`,\n`A` is a set of objects from `U`, and `x âˆˆ A`, then `x âˆˆ A`.  You should see\n`U : Type`, `x : U`, and `A : Set U` under *Objects* in the pane to the right, and\n`h : x âˆˆ A` under *Assumptions*.  The letter `h` here is called an *identifier*\nfor the assumption `x âˆˆ A`.\n\nYou will prove goals in Lean using *tactics*.  The first tactic you're\ngoing to learn is called `exact`, and it is used to close the goal.\nYou can close the goal by typing `exact` followed by a proof of the goal.":
 "\n# Empieza leyendo esto\n\nCada nivel en este juego implica demostrar una afirmaciÃ³n matemÃ¡tica (el \\\"Objetivo\\\").\nCuando presentas una prueba de esta afirmaciÃ³n que\nes aceptada por Lean, decimos que has *cerrado* el objetivo.\n\nEn este primer nivel, vas a demostrar que si `x` pertenece al universo `U`,\n`A` es un conjunto de objetos de `U`, y `x âˆˆ A`, entonces `x âˆˆ A`. DeberÃ­as ver\n`U : Type`, `x : U`, y `A : Set U` bajo *Objects* en el panel a la derecha, y\n`h : x âˆˆ A` bajo *Assumptions*. La letra `h` aquÃ­ se llama un *identificador*\npara la suposiciÃ³n `x âˆˆ A`.\n\nVas a demostrar objetivos en Lean utilizando *tÃ¡cticas*. La primera tÃ¡ctica que vas\na aprender se llama `exact`, y se utiliza para cerrar el objetivo.\nPuedes cerrar el objetivo escribiendo `exact` seguido de una prueba del objetivo.\n"}