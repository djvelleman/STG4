{"level completed! 🎉": "¡Nivel completado!",
 "level completed with warnings… 🎭": "Nivel completado con advertencias... 🎭",
 "intermediate goal solved! 🎉": "¡objetivo intermedio resuelto! 🎉",
 "`⋃₀ F` is the union of the family of sets `F`.  To enter the symbol `⋃₀`, type `\\U0`.":
 " La expresión `⋃₀ F` representa la unión de la familia de conjuntos `F`. Para ingresar el símbolo `⋃₀`, escribe `\\U0`.",
 "`⋂₀ F` is the intersection of the family of sets `F`.  To enter the symbol `⋂₀`, type `\\I0`.":
 " `⋂₀ F` es la intersección de la familia de conjuntos `F`. Para ingresar el símbolo `⋂₀`, escribe `\\I0`.",
 "`¬P` means \\\"it is not the case that P\\\".  To enter the symbol `¬`,\ntype `\\not`.":
 "`¬P` significa \\\"no es cierto que se cumpla P\\\".  Para obtener el símbolo `¬`,\nteclea `\\not`.",
 "`«{h3}» h1` is a proof of `x ∈ B`.": "`«{h3}» h1` es una prueba de `x ∈ B`.",
 "`«{h2}» «{t}» «{h4}»` is now a proof of the goal.":
 "`«{h2}» «{t}» «{h4}»` es ahora una prueba del objetivo.",
 "`x ∈ A` means that `x` is an element of `A`.  To enter the symbol `∈`, type\n`\\mem` or `\\in`.":
 "`x ∈ A` significa que `x` es un elemento de `A`.  Para introducir el símbolo `∈`, teclea\n`\\mem` or `\\in` seguido de un espacio.",
 "`rewrite [compl_compl A] at «{h2}»` will change `Aᶜᶜ` to\n`A`, and `rewrite [compl_compl B] at «{h2}»` will change `Bᶜᶜ` to `B`.  In fact, you can do both\nrewrites in one step:  `rewrite [compl_compl A, compl_compl B] at «{h2}»`.":
 "La táctica `rewrite [compl_compl A] at «{h2}»` cambiará `Aᶜᶜ` por\n`A`, en la hipótesis `«{h2}»`, y el comando `rewrite [compl_compl B] at «{h2}»` cambiará `Bᶜᶜ` por\n`B`. De hecho, puedes realizar ambos cambios en un solo paso:\n`rewrite [compl_compl A, compl_compl B] at «{h2}»`.",
 "`exact And.intro h1 h2` will close the goal.":
 " `exact And.intro h1 h2` cerrará el objetivo.",
 "`compl_subset_compl_of_subset «{h1}»` will prove the goal.":
 "`compl_subset_compl_of_subset «{h1}»` probará el objetivo.",
 "`P ∨ Q` means \"P or Q or both\".  To enter the symbol `∨`, type `\\or`.":
 "`P ∨ Q` significa \"P o Q o ambos\". Para escribir el símbolo `∨`, teclea `\\or`.",
 "`P ∧ Q` means \"P and Q\".  To enter the symbol `∧`, type `\\and`.":
 "`P ∧ Q` significa \"P y Q\". Para escribir el símbolo `∧`, teclea `\\and`.",
 "`P ↔ Q` means \"P if and only if Q\".  You can enter the symbol `↔` by typing `\\iff`.":
 "`P ↔ Q` significa \\\"P si y solo si Q\\\".  Puedes introducir el símbolo `↔` tecleando `\\iff`.",
 "`P → Q` means \"if `P` then `Q`\".  You can enter the symbol `→` by typing `\\imp`.":
 "`P → Q` significa \"si `P` entonces `Q`\".  Puedes introducir el símbolo `→` tecleando `\\imp`.",
 "`Or.inl h` is a proof of the goal.": "`Or.inl h` es una prueba del objetivo.",
 "`Exists.intro A «{h}»` proves the goal.":
 "`Exists.intro A «{h}»` demuestra el objetivo",
 "`A ⊆ B` means that `A` is a subset of `B`.  To enter the symbol `⊆`,\ntype `\\sub`.":
 "`A ⊆ B` significa que `A` es un subconjunto de `B`.  Para introducir el símbolo `⊆`,\nteclea `\\sub`.",
 "Your immediate goal now is to prove that `«{x}» ∈ B`.  Once you close that goal,\nyou'll be asked to prove the second goal, `«{x}» ∈ C`.":
 "Tu objetivo inmediato ahora es probar que `«{x}» ∈ B`. Una vez que cierres\nese objetivo, tendrás que demostrar el segundo objetivo, `«{x}» ∈ C`.",
 "Your immediate goal now is to prove that `Aᶜᶜ ⊆ A`.  Once you close that goal,\nyou'll be asked to prove the second goal, `A ⊆ Aᶜᶜ`.":
 "Tu objetivo inmediato ahora es probar que `Aᶜᶜ ⊆ A`. Una vez que cierres ese objetivo, se te pedirá probar el segundo objetivo, `A ⊆ Aᶜᶜ`.",
 "Your goal says that there is a set that is a subset of `A`.\nThe theorem `Subset.refl` suggests such a set.":
 " Tu objetivo indica que hay un conjunto que es un subconjunto de `A`.\nEl teorema `Subset.refl` sugiere tal conjunto.",
 "Your goal is an existential statement.  Do you see what value to use as a witness?":
 " Tu objetivo es un enunciado existencial. ¿Ves qué valor usar como testigo?",
 "Your goal is a subset statement.\nThat should tell you how to get started.":
 "Tu objetivo es ver un contenido. Eso debería decirte cómo empezar.",
 "You've mastered reasoning about complements, intersections, and unions.  In the next world,\nwe'll start mixing them up!":
 " Dominaste el razonamiento sobre complementarios, intersecciones y uniones. ¡En el próximo mundo, empezaremos a combinarlos!",
 "You've finished Family Intersection World!  As you might guess, you can also take the union of\na family of sets.  Can you guess how to define it?  Continue on to Family Union World to see\nif your guess is right.":
 "¡Terminaste el mundo de las intersecciones de familias! Como probablemente hayas adivinado, también puedes tomar la unión de una familia de conjuntos. ¿Puedes adivinar cómo definirla? Continúa en el mundo de la unión familiar para ver si aciertas.",
 "You've finished Combination World!": " ¡Terminaste el mundo Combinado!",
 "You'll be able to use the theorem `union_subset_swap` in the next level to prove\nthat union is commutative.":
 "En el siguiente nivel podrás utilizar el teorema `union_subset_swap` para probar que la unión es conmutativa.",
 "You should be able to combine ideas from previous levels to solve this one.":
 "Deberías ser capaz de combinar ideas de niveles anteriores para resolver este.",
 "You probably used a step like `rewrite [mem_inter_iff] at h` in this proof.  That step is\nactually optional.  Writing out the definition of intersection probably helps *you*\nunderstand how to proceed with the proof, but *Lean* doesn't need to be told to\nwrite out the definition.  It will do that on its own.  In other words, if you\nhave `h : x ∈ A ∩ B`, Lean will accept `h.left` as a proof of `x ∈ A`.":
 "Probablemente usaste un paso como `rewrite [mem_inter_iff] at h` en esta\nprueba. Ese paso es, de hecho, opcional. Escribir la definición de\nintersección probablemente te ayude a comprender cómo proceder con la\nprueba, pero *Lean* no necesita saber que escriba la definición. Lo hará por\nsí mismo. En otras palabras, si tienes `h : x ∈ A ∩ B`, Lean aceptará`h.left` como una prueba de `x ∈ A`.",
 "You probably used `intro` several times in this proof.  Recall that two `intro` steps in a row\ncan be combined into one step.  Click on `intro` in the list of tactics on the right for\nfurther details.":
 " Probablemente usaste `intro` varias veces en esta prueba. Recuerda que dos pasos de `intro` consecutivos pueden combinarse en un solo paso. Haz clic en `intro` en la lista de tácticas a la derecha para obtener más detalles.",
 "You need to apply `h1` to a family of sets with two\nproperties: the union of the family must be `A`, and knowing that `A` belongs to the\nfamily must help you prove that `A` is a singleton.":
 " Debes aplicar `h1` a una familia de conjuntos con dos\npropiedades: la unión de la familia debe ser `A`, y saber que `A` pertenece a la familia debe ayudarte a probar que `A` es un singleton.",
 "You might be tempted to use `rewrite [compl_inter]` as your next step.  But\nin this situation, `rewrite [compl_inter]` is ambiguous, because there are\ntwo ways that the theorem `compl_inter` could be applied to rewrite the goal: `compl_inter B C`\nis a proof of `(B ∩ C)ᶜ = Bᶜ ∪ Cᶜ` and `compl_inter Aᶜ (B ∩ C)ᶜ` is a proof of\n`(Aᶜ ∩ (B ∩ C)ᶜ)ᶜ = Aᶝᶜ ∪ (B ∩ C)ᶜᶜ`, and either one of those equations could be used to\nrewrite the goal.  If you say `rewrite [compl_inter]`, then Lean will pick one of those two\nrewriting steps, and it might not pick the one you wanted.  So you'd better say explicitly\nwhat you want Lean to apply the theorem `compl_inter` to.":
 " Quizás puedas estar tentado a usar `rewrite [compl_inter]` como tu siguiente paso. Pero en esta situación, `rewrite [compl_inter]` es ambiguo, ya que hay dos maneras en que el teorema `compl_inter` podría ser aplicado para reescribir el objetivo: `compl_inter B C` es una prueba de `(B ∩ C)ᶜ = Bᶜ ∪ Cᶜ` y `compl_inter Aᶜ (B ∩ C)ᶜ` es una prueba de\n`(Aᶜ ∩ (B ∩ C)ᶜ)ᶜ = Aᶝᶜ ∪ (B ∩ C)ᶜᶜ`, y cualquiera de esas ecuaciones podría ser utilizada para\nreescribir el objetivo. Si usas `rewrite [compl_inter]`, entonces Lean elegirá uno de esos dos\npasos de reescritura, y puede que no elija el que querías. Así que es mejor decir explícitamente a que quieres que Lean aplique el teorema `compl_inter`.",
 "You may find it useful to separate out the right half of `«{h1}»`.\nYou can do that with `have «{h1}»r := «{h1}».right`.":
 " Puede que le resulte útil separar la mitad derecha de `«{h1}»`.\nPuede hacerlo con `have «{h1}»r := «{h1}».derecha`.",
 "You know `«{x}» ∈ «{t}»` and `«{t}» = A ∩ «{u}»`.  So you can use `rewrite`\nto get `«{x}» ∈ A ∩ «{u}»`.":
 " Sabes que `«{x}» ∈ «{t}»` y que `«{t}» = A ∩ «{u}»`. Así que puedes usar `rewrite` para obtener `«{x}» ∈ A ∩ «{u}»`.",
 "You haven't used `«{h2}»` yet.  If you don't see how to use it,\nwrite out its definition.":
 " No has utilizado `«{h2}»` aún. Si no ves cómo usarlo,\nescribe su definición.",
 "You can use the `have` tactic to add a new statement to your list of\nassumptions, as long as you can justify it with a proof.  For further\ninformation, click on `have` in the list of tactics on the right.":
 "\nPuedes usar la táctica `have` para añadir una afirmación a tu lista de suposiciones,\nsiempre que puedas justificarla con una demostración. Para más información, pulsa en `have`\nen la lista de tácticas a la derecha.\n",
 "You can use the `by_contra` tactic in any proof to assume the\nopposite of your goal.  But it is most useful when the goal\nstarts with the symbol `¬`.  After using the `by_contra` tactic,\nyour goal will be `False`.\n\nTo complete a proof by contradiction, you must prove contradictory statements.\nIf your goal is `False` and you have assumptions `h1 : P` and `h2 : ¬P`, for\nsome statement `P`, then `exact h2 h1` will close the goal.  Note that `exact h1 h2` won't\nwork; you must list the negative statement first to establish a contradiction.":
 "\nPuedes usar la táctica `by_contra` en cualquier prueba para asumir lo contrario de tu objetivo.\nPero es más útil cuando el objetivo comienza con el símbolo `¬`. Después de usar la táctica `by_contra`,\ntu objetivo será `False`.\n\nPara completar una prueba por contradicción, debes demostrar afirmaciones contradictorias.\nSi tu objetivo es `False` y tienes las suposiciones `h1 : P` y `h2 : ¬P`, para\nalguna afirmación `P`, entonces `exact h2 h1` cerrará el objetivo. Ten en cuenta que `exact h1 h2`\nno funcionará; debes listar la afirmación negativa primero para establecer una contradicción.\n",
 "You can use the `apply` tactic to work backwards from the goal.  Suppose you think that you\nwill be able to use some theorem `t` to prove the goal.  In other words, you think there\nis a proof of the goal of the form `t ?`, where the question mark needs to be replaced\nwith a proof of some statement `P` to which the theorem `t` must be applied.  The tactic\n`apply t` will then set `P` as your goal.  If `t` must be applied to more than one proof to\nestablish the goal, then `apply t` will set all of the needed proofs as goals.":
 "Puedes usar la táctica `apply` para trabajar hacia atrás desde el objetivo.Supongamos que piensas que podrás utilizar algún teorema `t` para probar elobjetivo. En otras palabras, crees que hay una prueba del objetivo de la forma `t ?`, donde el signo de interrogación necesita ser reemplazado por una prueba de algún enunciado `P` a la que se le debe aplicar el teorema `t`. La táctica `apply t` entonces establecerá `P` como tu objetivo. Si `t` debe aplicarse a más de una prueba para establecer el objetivo, entonces `apply t` establecerá todas las pruebas necesarias como objetivos.",
 "You can use `rewrite [mem_setOf]` to write out the meaning of the goal.":
 " Puedes usar `rewrite [mem_setOf]` para escribir el significado del objetivo.",
 "You can use `compl_subset_compl_of_subset «{h1}»` to\njustify the assertion `Aᶜᶜ ⊆ Bᶜᶜ`.":
 "Puedes usar `compl_subset_compl_of_subset «{h1}»` para justificar laafirmación `Aᶜᶜ ⊆ Bᶜᶜ`.",
 "You can think of `h2 : x ∉ B` (which is shorthand for `h2 : ¬x ∈ B`)\nas meaning \"if `x ∈ B` were true, then that would lead to a contradiction\"--in other\nwords, `x ∈ B → False`.\nApplying this to your new assumption `«{h4}» : x ∈ B` will give the contradiction\nyou need.  In other words, `exact h2 «{h4}»` will close the goal.":
 "Puedes pensar en `h2 : x ∉ B` (que es una forma abreviada de `h2 : ¬x ∈ B`)\ncomo significando \"si `x ∈ B` fuera verdadero, eso conduciría a una contradicción\"--dicho\nde otro modo, `x ∈ B → False`.\nAplicar esto a tu nueva suposición `«{h4}» : x ∈ B` dará la contradicción\nque necesitas. En otras palabras, `exact h2 «{h4}»` cerrará el objetivo.",
 "You can separate out the first half of `«{ht}»` with `have «{ht}»l := «{ht}».left`.":
 " Puedes separar la primera mitad de `«{ht}»` con `have «{ht}»l := «{ht}».left`.",
 "You can now combine `«{h2}»` and `«{h4}»` to reach the goal in one step.":
 " Ahora puedes combinar `«{h2}»` y `«{h4}»` para alcanzar el objetivo en un solo paso.",
 "Writing out the meaning of the goal will make the proof easier to understand.":
 "Escribir el significado del objetivo facilitará la comprensión de la prueba.",
 "Writing out the meaning of intersection in the goal will help you see what to do to\ncomplete this level.":
 "Escribir el significado de la intersección en el objetivo te ayudará a ver\nlo que tienes que hacer para completar este nivel.",
 "Writing out the definition of union in the goal should help you see how to proceed.":
 "Escribir la definición de unión en el objetivo debería ayudarte a ver cómo seguir.",
 "Writing out the definition of intersection in the goal will help.":
 "Escribir la definición de intersección en el objetivo ayudará.",
 "Whew!": "¡Uf!",
 "What statement would you like to contradict to complete the proof?":
 " ¿Cuál es el enunciado que deseas contradecir para completar la prueba?",
 "What set can you apply `«{h1}»` to?":
 " ¿A qué conjunto puedes aplicar «{h1}»?",
 "What happens if you intersect `⋃₀ F` with `(⋃₀ G)ᶜ`, for two families `F` and `G`?":
 " ¿Qué sucede si intersecas `⋃₀ F` con `(⋃₀ G)ᶜ`, para dos familias `F` y `G`?",
 "What happens if the subset statement in the last level is reversed?":
 " ¿Qué sucede si se invierte la relación de contenido en el último nivel?",
 "Well done!  You're ready to move on to Union World.":
 "¡Bien hecho! Estás listo para pasar al mundo de la uniones.",
 "Welcome to Subset World! In this world you will learn about sets and\nsubsets, and you will also learn the basics of proving theorems in Lean.\n\nThe elements of the sets in this world will come from a universe called `U`.\nTo specify that an\nobject `x` belongs to the universe `U`, we write `x : U`.  To specify\nthat `A` is a set of objects from `U`, we write `A : Set U`.  (The terminology used\nin Lean is that `x` has *type* `U` and `A` has *type* `Set U`.)  To\nsay that `x` is an element of `A`, we write `x ∈ A`.  (You can enter\nthe symbol `∈` by typing `\\mem` or `\\in`, followed by a space.)\n\nYou will prove theorems in this game by using tools called *tactics*.\nThe aim is to prove the theorem by applying tactics\nin the right order.\n\nLet's learn some basic tactics. Click on \"Start\" below\nto get started.":
 "¡Bienvenido al mundo de los subconjuntos!En este mundo, aprenderás sobre conjuntos y subconjuntos, y también aprenderás los conceptos básicos de cómo demostrar teoremas en Lean. Los elementos de los conjuntos en este mundo provendrán de un universo llamado `U`.(Lean llama a `U` un *Tipo*.) Para especificar que un objeto `x` pertenece al universo `U`,escribimos `x : U`. Para especificar que `A` es un conjunto de objetos de `U`, escribimos`A : Set U`. Para decir que `x` es un elemento de `A`, escribimos `x ∈ A`.(Puedes ingresar el símbolo `∈` escribiendo `\\mem` o `\\in`, seguido de un espacio).Probarás teoremas en este juego utilizando herramientas llamadas *tácticas*.El objetivo es demostrar el teorema aplicando tácticas en el orden correcto.Aprendamos algunas tácticas básicas. Haz click en \\\"Start\\\" a continuación para empezar.",
 "We'll prove one more property of intersections in the next level.":
 "Probaremos una propiedad más de las intersecciones en el siguiente nivel.",
 "We have given this theorem the name `inter_subset_swap`.  Thus, from now on, for\nany sets `A` and `B`, `inter_subset_swap A B` is a proof of `A ∩ B ⊆ B ∩ A`.":
 "Le hemos dado a este teorema el nombre de `inter_subset_swap`. Por lo tanto, desde ahora en adelante, para cualesquiera conjuntos `A` y `B`, `inter_subset_swap A B` es una prueba de `A ∩ B ⊆ B ∩ A`.",
 "Use `intro` to introduce either a new assumption or a new object into your proof.\n\nThere are two situations in which you can use the `intro` tactic:\n* If you are proving a statement of the form `P → Q`, then you can use\nthe tactic `intro h` to introduce the assumption `h : P` and set `Q` as the goal.  Be\nsure to use an identifier that is not already in use.\n* If you are proving a statement of the form `∀ x, P x`, where `P x` is some statement\nabout `x`, then you can use the tactic `intro x` to introduce a new object `x` into the proof.\nBe sure to use a variable name that is not already in use.  The goal will then be `P x`.\n\nYou can do multiple introductions in one step: for example, `intro x h` has the same\neffect as doing `intro x` followed by `intro h`.":
 "\nUsa `intro` para introducir ya sea una nueva suposición o un nuevo objeto en tu prueba.\n\nHay dos situaciones en las que puedes usar la táctica `intro`:\n- Si estás demostrando una afirmación de la forma `P → Q`, entonces puedes usar\nla táctica `intro h` para introducir la suposición `h : P` y establecer `Q` como la meta. Asegúrate\nde usar un identificador que no esté en uso.\n- Si estás demostrando una afirmación de la forma `∀ x, P x`, donde `P x` es una afirmación sobre\n`x`, entonces puedes usar la táctica `intro x` para introducir un nuevo objeto `x` en la prueba.\nAsegúrate de usar un nombre de variable que no esté en uso. El objetivo pasará a ser `P x`.\n\nPuedes realizar múltiples introducciones en un solo paso: por ejemplo, `intro x h` tiene el mismo\nefecto que realizar `intro x` seguido de `intro h`.\n",
 "Use `intro` again to introduce the assumption `«{x}» ∈ A`.":
 "Usa `intro` otra vez para introducir la suposición `«{x}» ∈ A`.",
 "Use `have` to assert a statement that you can prove from your current\nassumptions.  You must give the new assertion an identifier; be sure to\nuse an identifier that is different from those already in use.\n\nIf some expression `t` is a proof of a statement `P`, and `h` is an\nidentifier that is not in use, then `have h : P := t` will add `h : P`\nto the list of assumptions.\n\nThere are two variations on the `have` tactic:\n* Sometimes you want to assert a statement `P`, but the proof of `P` is too\ndifficult to be given in one line.  In that situation, you can simply write\n`have h : P`.  Of course, you must still justify the assertion of `P`, so\nthe proof of `P` becomes your immediate goal.\nOnce the goal of proving `P` has been closed, you will be able to return to\nyour original goal, with `h : P` added to the assumption list.\n* If you write `have h := t`, then Lean will try to figure out what statement\n`P` is proven by the expression `t` and, if it can figure it out, it will fill\nit in for you.":
 "\nUsa `have` para afirmar una declaración que puedes probar a partir de tus suposiciones actuales.\nDebes darle a la nueva afirmación un identificador; asegúrate de\nusar un identificador que sea diferente de los que ya se están utilizando.\n\nSi alguna expresión `t` es una prueba de una afirmación `P`, y `h` es un\nidentificador que no está en uso, entonces `have h : P := t` agregará `h : P`\na la lista de suposiciones.\n\nHay dos posibles formas de usar la táctica `have`:\n* A veces quieres afirmar una declaración `P`, pero la prueba de `P` es demasiado\ndifícil para ser dada en una sola línea. En esa situación, simplemente puedes escribir\n`have h : P`. Por supuesto, aún debes justificar la afirmación de `P`, así que\nla prueba de `P` se convierte en tu objetivo inmediato.\nUna vez que se haya cerrado el objetivo de demostrar `P`, podrás volver a\ntu objetivo original, con `h : P` añadido a la lista de suposiciones.\n* Si escribes `h := t`, entonces Lean intentará deducir qué afirmación `P` es probada por `t`, y\nsi puede hacerlo, directamente añadirá una nueva hipótesis `h : P`.\n",
 "Use `h1`.": "Usa `h1`.",
 "Use `exact` to close a goal.  If some expression `t` is a proof of\nthe goal, then `exact t` will close the goal.\n\nThink of \"exact\" as meaning \"this is exactly what is needed to prove the goal.\"":
 "\nUtiliza `exact` para cerrar un objetivo. Si alguna expresión `t` es una prueba del\nobjetivo, entonces `exact t` cerrará el objetivo.\n\nPuedes pensar que \"exact\" significa\n\"esto es exactamente lo que se necesita para demostrar el objetivo.\"",
 "Union subset of swap": "La unión es un subconjunto de la unión conmutada",
 "Union subset of a set": "La unión como subconjunto de un conjunto",
 "Union of larger family is larger":
 "La unión de una familia más grande es más grande.",
 "Union of a union": "Unión de una unión",
 "Union of a pair": "Unión de un par",
 "Union of a family of intersections": "Unión de una familia de intersecciones",
 "Union is commutative": " La unión es conmutativa.",
 "Union is associative": "La unión es asociativa",
 "Union distributes over intersection":
 "Distributividad de la unión sobre la intersección",
 "Union World": "Mundo de las uniones",
 "Two families with an element in common":
 "Dos familias con un elemento en común",
 "Try `apply Exists.intro (A ∩ «{t}»)` or `use A ∩ «{t}»`.":
 " Intenta `apply Exists.intro (A ∩ «{t}»)` o `use A ∩ «{t}»`.",
 "To work with unions of families, we'll need to know how to work with existential statements.\nIf `P x` is a statement about an unspecified object `x`, then `∃ x, P x` means \"there is\nat least one `x` such that `P x` is true\".  The symbol `∃` is called the\n*existential quantifier*, and you can enter it in Lean by typing `\\exists`.\n\nThe easiest way to prove the statement `∃ x, P x` is to specify a value of `x`, and give a\nproof of `P x` for that value of `x`.  The theorem that allows you to do that is called\n`Exists.intro`.  If you have `h : P a`, for some object `a`, then `Exists.intro a h` is a\nproof of the statement `∃ x, P x`.  (The object `a` is sometimes called a *witness* for\nthe existential statement.)  In this level, you'll try out this theorem.":
 " Para trabajar con uniones de familias, necesitaremos saber cómo trabajar con enunciados existenciales.\nSi `P x` es un enunciado acerca de un objeto no especificado `x`, entonces `∃ x, P x` significa \"existe al menos un `x` tal que `P x` es verdadero\". El símbolo `∃` se llama el *cuantificador existencial*, y puedes ingresarlo en Lean escribiendo `\\exists`.\n\nLa forma más fácil de probar el enunciado `∃ x, P x` es especificar un valor para `x`, y dar una prueba de `P x` para ese valor de `x`. El teorema que permite hacer esto se llama `Exists.intro`. Si tienes `h : P a`, para algún objeto `a`, entonces `Exists.intro a h` es una prueba del enunciado `∃ x, P x`. (El objeto `a` a veces se llama un *testigo* para el enunciado existencial.) En este nivel, intentarás probar este teorema.",
 "To work with intersections, we'll need to understand the word \"and\".\n\nIf `P` and `Q` are statements, then `P ∧ Q` means \"P and Q\".  To enter the\nsymbol `∧`, type `\\and`.  For the statement `P ∧ Q` to be true, `P` and `Q` must\nboth be true.  If you have `h : P ∧ Q`--that is, `h` is a proof of\nthe statement `P ∧ Q`--then in Lean, `h.left` is a proof of `P` and `h.right` is\na proof of `Q`.  That should be all you need to know to solve this level.":
 " Para trabajar con intersecciones, necesitaremos entender la palabra \"y\".\n\nSi `P` y `Q` son enunciados, entonces `P ∧ Q` significa \"P y Q\". Para escribir el símbolo `∧`, teclea `\\and`. Para que la declaración `P ∧ Q` sea verdadera, tanto `P` como `Q` deben ser verdaderos. Si tienes `h : P ∧ Q`-- es decir, `h` es una prueba del enunciado `P ∧ Q`--entonces en Lean, `h.left` es una prueba de `P` y `h.right` es una prueba de `Q`. Eso debería ser todo lo que necesitas saber para resolver este nivel.",
 "To work with complements, we'll need to understand negative statements--that is, statements\nthat say that something is *not* the case.\n\nIf `P` is a statement, then `¬P` means \"it is not the case that P\".  To enter the symbol\n`¬`, type `\\not`.\n\nA common method of proving a negative statement is *proof by\ncontradiction*: to prove a statement of the form `¬P`, you can assume that `P` is true\nand then show that this assumption leads to a contradiction.  The tactic to use for this\nkind of proof is `by_contra`.":
 "Para trabajar con complementos, necesitaremos entender declaraciones negativas, es decir, afirmaciones que indican que algo *no* es cierto.\n\nSi `P`  es una afirmación, entonces `¬P` significa \"no es cierto que P\". Para introducir el símbolo `¬`, escribe `\\not`.\n\nUn método común para demostrar una afirmación negativa es la *prueba por contradicción*: para demostrar una afirmación de la forma `¬P`, puedes asumir que `P` es verdadero y luego mostrar que esta suposición conduce a una contradicción. La táctica a utilizar para este tipo de prueba es `by_contra`.",
 "To understand the logic of this proof, it will help to write out the definition\nof union in `«{h3}»`.":
 "Para entender la lógica de esta prueba, ayudará escribir la definición de unión en «{h3}».",
 "To start on this proof, try writing out the meaning of intersection in `h`.":
 "Para empezar con esta prueba, intenta escribir el significado de intersección en `h`.",
 "To start a proof, you should look first at the goal.\nWhat needs to be done to prove the goal?\nIn this level, the goal is `A ⊆ C`.  What does that\ntell you about how to proceed?":
 "Para empezar una demostración, empieza mirando el objetivo.¿Qué necesitas hacer para demostrar el objetivo?En este nivel, el objetivo es `A ⊆ C`.  ¿Qué te dice eso sobre los pasos a dar?",
 "To make use of `«{h3}»`, you'll need to assert `«{t}»ᶜ ∈ {s | sᶜ ∈ F}`.  If you don't see\nright away how to justify this assertion, you can just write `have «{h3}»a : «{t}»ᶜ ∈ {s | sᶜ ∈ F}`\nand Lean will set `«{t}»ᶜ ∈ {s | sᶜ ∈ F}` as your immediate goal.  Once you achieve that goal,\nLean will add `«{h3}»a : «{t}»ᶜ ∈ {s | sᶜ ∈ F}` to your list of assumptions, and you can continue\nwith the proof of your original goal.  For further details, click on `have` in the list of tactics\non the right.":
 " Para usar `«{h3}»`, necesitarás afirmar `«{t}»ᶜ ∈ {s | sᶜ ∈ F}`. Si no ves de inmediato cómo justificar esta afirmación, puedes simplemente escribir `have «{h3}»a : «{t}»ᶜ ∈ {s | sᶜ ∈ F}` y Lean establecerá `«{t}»ᶜ ∈ {s | sᶜ ∈ F}` como tu objetivo inmediato. Una vez que logres ese objetivo, Lean agregará `«{h3}»a : «{t}»ᶜ ∈ {s | sᶜ ∈ F}` a tu lista de suposiciones y podrás continuar con la prueba de tu objetivo original. Para obtener más detalles, haz clic en `have` en la lista de tácticas a la derecha.",
 "To make use of `«{h2}»`, you'll need to assert `«{t}»ᶜ ∈ {s | sᶜ ∈ F}`.  If you don't see\nright away how to justify this assertion, you can just write `have «{h2}»a : «{t}»ᶜ ∈ {s | sᶜ ∈ F}`\nand Lean will set `«{t}»ᶜ ∈ {s | sᶜ ∈ F}` as your immediate goal.  Once you achieve that goal,\nLean will add `«{h2}»a : «{t}»ᶜ ∈ {s | sᶜ ∈ F}` to your list of assumptions, and you can continue\nwith the proof of your original goal.  For further details, click on `have` in the list of tactics\non the right.":
 " Para usar `«{h2}»`, necesitarás probar `«{t}»ᶜ ∈ {s | sᶜ ∈ F}`. Si no ves de inmediato cómo justificar esta afirmación, puedes escribir `have «{h2}»a : «{t}»ᶜ ∈ {s | sᶜ ∈ F}`\ny Lean establecerá `«{t}»ᶜ ∈ {s | sᶜ ∈ F}` como tu objetivo inmediato. Una vez que hayas logrado ese objetivo,\nLean agregará `«{h2}»a : «{t}»ᶜ ∈ {s | sᶜ ∈ F}` a tu lista de suposiciones y podrás continuar\ncon la prueba de tu objetivo original. Para obtener más detalles, haz clic en `have` en la lista de tácticas\na la derecha.",
 "To get started, you'll need to introduce first\nan object `x` and then the assumption that `x ∈ A`.":
 "Para empezar, hay que introducir un objeto `x` y la hipótesis de que `x ∈ A`.",
 "To get started on this proof, type `have h4 : x ∈ B := h1 h3`\nin the text box and click \"Execute\" or hit \"Return\" or \"Enter\".\nRecall that you can enter the symbol `∈` by typing `\\mem` or `\\in`.":
 "Para iniciar esta prueba, teclea `have h4 : x ∈ B := h1 h3`\n  en la caja de texto y pulsa \"Execute\" o la tecla \"Return\" o \"Enter\".\n  Recuerda que puedes introducir el símbolo `∈` tecleando `\\mem` or `\\in`.",
 "To finish off Combination World, we'll do one more tricky theorem.":
 " Para terminar el mundo combinado, haremos un último teorema algo más difícil.",
 "This time we'll study the intersection of `(⋃₀ F)` and `(⋂₀ G)ᶜ`.":
 " Esta vez estudiaremos la intersección de `(⋃₀ F)` y `(⋂₀ G)ᶜ`.",
 "This should remind you of the first level of this world.  To get a contradiction,\ntry to contradict `«{h2}» : «{x}» ∉ B`.":
 "Esto debería recordarte el primer nivel de este mundo. Para obtener una\n  contradicción, intenta contradecir `«{h2}» : «{x}» ∉ B`.",
 "This proof is longer than previous ones, but it doesn't require any new tactics or theorems.\nJust stick with it and keep applying the ideas from previous levels!":
 "Esta comprobación es más larga que las anteriores, pero no requiere ninguna nueva táctica o teorema. Solo sigue adelante y sigue aplicando las ideas de niveles anteriores.",
 "This proof is a bit tricky.  But you should know how to get started.":
 "Esta prueba es un poco difícil. Pero deberías saber como empezar.",
 "This level shows that family intersections are a generalization of the intersections\nwe studied in Intersection World.  You'll prove that if `A` and `B` are sets, then\n`A ∩ B` is equal to the intersection of the family of sets that contains just `A` and\n`B` and nothing else.\n\nWe'll need notation for the family of sets consisting of just `A` and `B`; we'll denote\nthis family by `{A, B}`.  And, as usual, we'll need a theorem stating the definition of\nthis notation.  For any `t`, `A`, and `B`, `mem_pair t A B` is a proof of the\nstatement `t ∈ {A, B} ↔ t = A ∨ t = B`.":
 " Este nivel muestra que las intersecciones de familias son una generalización de las intersecciones\nque estudiamos en el mundo de las intersecciones. Vas a probar que si `A` y `B` son conjuntos, entonces\n`A ∩ B` es igual a la intersección de la familia de conjuntos que contiene solo `A` y\n`B` y nada más.\n\nNecesitaremos notación para la familia de conjuntos consistente solo en `A` y `B`; denotaremos\na esta familia por `{A, B}`. Y, como de costumbre, necesitaremos un teorema que establezca\nla definición de esta notación. Para cualquier `t`, `A`, y `B`, `mem_pair t A B` es una\ndemostración del enunciado `t ∈ {A, B} ↔ t = A ∨ t = B`.",
 "This level is an exercise in handling sequences of quantifiers that alternate between\n`∀` and `∃`.  A good way to start is to decide which assumption to use first.":
 " Este nivel es un ejercicio para manejar secuencias de cantidades que alternan entre\n`∀` y `∃`. Una buena forma de empezar es decidir qué suposición utilizar primero.",
 "This is different from the previous theorem--the roles of union and intersection have\nbeen swapped.\n\nOnce again, there is a tricky shortcut: there is a way to use the theorem from the\nprevious level to prove this theorem.\n\nBut if you don't see the shortcut, you can use a straightforward approach.\nIf you made it through the last one, you can do this one too!":
 "Esto es diferente del teorema anterior, se han intercambiado los papeles de la unión y la intersección.\n\nDe nuevo, hay un truco: hay una manera de usar el teorema del nivel anterior para probar este teorema.\n\nPero si no ves el atajo, puedes usar un enfoque directo. Si lograste hacerlo con el último, también puedes hacerlo con este.",
 "This example is a better illustration of how the `exact` tactic is usually\nused.  Often `exact` is followed by an expression that combines assumptions\nto prove the goal.  In later levels, we will see other ways in which\nassumptions can be combined to prove a goal.\n\nNote that in this proof, `h1` could be thought of as a function that can be\napplied to a proof of any statement of the form `x ∈ A` to produce a proof\nof `x ∈ B`.  Many proofs in Lean behave like functions.":
 "\nEste ejemplo ilustra mejor cómo se usa normalmente la táctica `exact`.\nA menudo, `exact` va seguido de una expresión que combina hipótesis para demostrar el objetivo.\nEn niveles posteriores, veremos otras formas en las que las hipótesis se pueden combinar para\ndemostrar un objetivo.\n\nObserva que en esta prueba, `h1` podría pensarse como una función que se puede\naplicar a una prueba de cualquier afirmación de la forma `x ∈ A` para producir una prueba\nde `x ∈ B`. Muchas pruebas en Lean se comportan como funciones.\n",
 "There is more than one way to do the proof in this level.  Since the proof involves complements of\nsets, negative statements will arise in the course of the proof.  This suggests two possible techniques.\nYou may be able to use the `push_neg` tactic to reexpress some negative statements as equivalent\npositive statements.  And you may find proof by contradiction useful.":
 " Existe más de una forma de realizar la prueba en este nivel. Dado que la prueba implica\ncomplementarios de conjuntos, aparecerán enunciados negativos durante el curso de la prueba.\nEsto sugiere dos posibles técnicas.\nSe puede usar la táctica `push_neg` para reexpresar algunos enunciados negativos como equivalentes positivos.\nO se puede usar encontrar la prueba por contradicción.",
 "There is another tactic you could have used to complete this proof.  Instead of\n`apply Exists.intro A`, you could write `use A`.  The `use` tactic is actually a powerful\ntactic.  Not only does it fill in `A` for `t` in the existential goal, it then tries to\ncomplete the proof on its own--and in this case, it would have succeeded!":
 " Hay otra táctica que podrías haber utilizado para completar esta prueba. En lugar de\n`apply Exists.intro A`, podrías escribir `use A`. La táctica `use` es una táctica muy potente. No solo sustituye `A` como `t` en el objetivo existencial, sino que luego intenta completar la prueba por su cuenta y, en este caso, habría tenido éxito!",
 "There are two ways to complete the proof now.  Since your goal is a negative statement,\none natural strategy to use would be proof by contradiction.  A second possibility is to\nimitate the approach in the first half: write out the meaning of complement again in the goal,\nand then use the `push_neg` tactic to simplify the resulting double-negative goal.  Either\napproach will work.":
 "Hay dos formas de completar la prueba ahora. Dado que tu objetivo es un enunciado negativo, una estrategia natural que puedes usar sería la prueba por contradicción. Una segunda posibilidad es imitar el enfoque en la primera mitad: escribe de nuevo el significado del complementario en el objetivo y luego utiliza la táctica `push_neg` para simplificar la doble negación resultante. Cualquiera de los dos enfoques funcionará.",
 "The theorem you have proven in this level shows that the subset relation has\na property called *transitivity*.  We have given the theorem the name `Subset.trans`.":
 "El teorema que has demostrado en este nivel dice que la relación de contenido tiene una propiedad llamada *transitividad*. Hemos llamado a este teorema `Subset.trans`.",
 "The theorem you have proven in this level shows that the subset relation has\na property called *reflexivity*.  We have given the theorem the name `Subset.refl`.  You\nwill see it in the list of theorems on the right.  (This theorem is included in Lean's\nmathematical library, Mathlib.  In Mathlib, the name of the theorem is `Set.Subset.refl`.\nMany other set-theoretic theorems in this game have `Set.` at the beginnings of their names\nin Mathlib.)":
 "\nEl teorema que has demostrado en este nivel muestra que la relación de ser subconjunto tiene\nuna propiedad llamada *reflexividad*. Hemos dado al teorema el nombre `sub_ref`.\nLo verás en la lista de teoremas a la derecha. \n (Este teorema está incluido en la biblioteca matemática de Lean, *Mathlib*. \nEn Mathlib, el nombre de este teorema es  `Set.Subset.refl`.Otros muchos teoremas sobre teoría de conjuntos de este juego están en Mathlib con nombres que empiezan por `Set.`).",
 "The theorem `compl_subset_compl_of_subset «{h1}»` doesn't prove the goal,\nbut it comes close.  Do you see what assertion it will justify?":
 "El enunciado `compl_subset_compl_of_subset «{h1}»` no demuestra el\nobjetivo, pero se acerca mucho. ¿Ves qué afirmación justificará?",
 "The tactic `by_cases h : P` breaks the proof into two cases.  In the first case, the\nassumption `h : P` is added to the list of assumptions, and in the second case, the\nassumption `h : ¬P` is added.":
 "La táctica `by_cases h : P` divide la prueba en dos casos. En el primer caso, se añade la suposición `h : P` a la lista de suposiciones y en el segundo caso, se añade la suposición `h : ¬P`.",
 "The situation now should remind you of your first proof, in level 1 of this world.":
 "La situación ahora debería recordarte a tu primera demostración, en el nivel 1 de este mundo.",
 "The second goal is similar, but a little trickier.":
 "El segundo objetivo es similar, pero un poquito más difícil.",
 "The proof of the theorem in this level is very easy.\nSince `x ∈ Aᶜ` and `x ∉ A` are definitionally equivalent, `rfl` will close the goal.":
 "La demostración en este nivel es muy fácil.\n  Como `x ∈ Aᶜ` y `x ∉ A` son iguales por definición, `rfl` cerrará el objetivo.",
 "The proof of the second goal is similar.":
 "La prueba del segundo objetivo es similar.",
 "The proof in this level illustrates how previously proven theorems can be used in proofs.\n\nThere is another tactic you can use if your goal has the form `P ↔ Q`.  In this situation,\nthe tactic `constructor` will have the same effect as `apply Iff.intro`; that is, it will\nset `P → Q` and `Q → P` as goals to be proven.":
 "La prueba en este nivel ilustra cómo se pueden utilizar en una prueba teoremas previamente demostrados.\n\nExiste otra táctica que puedes usar si tu objetivo tiene la forma `P ↔ Q`. En esta situación,\nla táctica `constructor` tendrá el mismo efecto que `apply Iff.intro`; es decir, establecerá `P → Q` y `Q → P` como objetivos a ser probados.",
 "The notation `{a}` denotes a set whose only element is `a`; such a set is called a *singleton*\nset.  The theorem `mem_singleton_iff` expresses the definition of singleton sets: `mem_singleton_iff` is\na proof of any statement of the form `x ∈ {a} ↔ x = a`.":
 " La notación `{a}` denota un conjunto cuyo único elemento es `a`; un conjunto de este tipo se llama *singleton*. El teorema `mem_singleton_iff` expresa la definición de conjuntos singleton: `mem_singleton_iff` es\nuna prueba de cualquier enunciado de la forma `x ∈ {a} ↔ x = a`.",
 "The name of the tactic `rfl` is short for \"reflexivity\", which is the property of\nboth `=` and `↔` that is the basis for the tactic.\n\nWe have given the theorem proven in this level the name `mem_compl_iff`.  In the next level,\nwe will see how we can use it to prove theorems about complements.":
 "Hemos llamado al teorema demostrado en este nivel `comp_def`, porque expresa la definición\ndel complementario. En el siguiente nivel veremos cómo usarlo para demostrar teoremas sobre\ncomplementarios.",
 "The last two steps could have been combined into one step.  In general, if you have\n`h1 : A ∈ F` and `h2 : ∀ t ∈ F, P t`, where `P t` is some statement about `t`, then `h2 A`\nis a proof of `A ∈ F → P A`, and\napplying that proof to `h1` we conclude that `h2 A h1` is a proof of `P A`.  For example,\nif you have `h1 : A ∈ F` and `h2 : ∀ t ∈ F, x ∈ t`, then `h2 A h1` is a proof of `x ∈ A`.":
 " Los últimos dos pasos podrían haberse combinado en un solo paso. En general, si tienes\n`h1 : A ∈ F` y `h2 : ∀ t ∈ F, P t`, donde `P t` es algún enunciado sobre `t`, entonces `h2 A`\nes una prueba de `A ∈ F → P A`, y\naplicando esa prueba a `h1` concluimos que `h2 A h1` es una prueba de `P A`. Por ejemplo,\nsi tienes `h1 : A ∈ F` y `h2 : ∀ t ∈ F, x ∈ t`, entonces `h2 A h1` es una prueba de `x ∈ A`.",
 "The have tactic": "La táctica have",
 "The form of the assumption `«{h}»` now suggests proof by cases.":
 "El aspecto de la hipótesis `«{h}»` ahora sugiere prueba por casos.",
 "The first case is the easy one.": " El primer caso es el fácil.",
 "The exact tactic": "La táctica exact",
 "The assumption `«{h2}»` is now an existential statement.  Thus, `obtain ⟨s, hs⟩ := «{h2}»`\nwill introduce a new object `s` and a new assumption `hs : s ∈ F ∧ «{x}» ∈ s` into the proof.\nOnce the witness `s` has been introduced, the assumption `«{h2}»` becomes redundant, so it is\ndeleted.":
 " La suposición «{h2}» ahora es un enunciado existencial. Por lo tanto, `obtain ⟨s, hs⟩ := «{h2}»`\nintroducirá un nuevo objeto `s` y una nueva hipótesis `hs : s ∈ F ∧ «{x}» ∈ s` en la prueba.\nUna vez que se ha introducido el testigo `s`, la suposición «{h2}» se vuelve redundante, por lo que se elimina.",
 "The assumption `«{h1}»` now says `«{x}» ∉ Aᶜ`, which means `¬«{x}» ∈ Aᶜ`.  It will be helpful to\nwrite out the definition of complement again in this assumption.":
 "La suposición `«{h1}»` ahora dice `«{x}» ∉ Aᶜ`, lo que significa `¬«{x}» ∈ Aᶜ`. Sería útil escribir de nuevo la definición del complemento en esta suposición.",
 "The `rewrite` tactic is smart enough to figure out some things on its own.  If you\nhad just written `rewrite [mem_compl_iff]`, then Lean would have figured out how to apply the\ntheorem `mem_compl_iff` to get an equivalence that could be used to make a replacement in the goal.\nIn other words, it would have figured out that the theorem `mem_compl_iff` had to be applied to\n`A` and `«{x}»`.\n\nSimilarly, you can write `rewrite [mem_compl_iff] at «{h2}»` to write out the meaning of `«{h2}»`.  Lean\nwill figure out that in this case, `mem_compl_iff` has to be applied to `B` and `«{x}»`.":
 "La táctica `rewrite` es suficientemente inteligente para deducir algunas cosas por sí misma.\n  Si hubieras escrito solamente `rewrite [mem_compl_iff]`, Lean habría deducido como aplicar el teorema\n  `mem_compl_iff` para obtener una equivalencia que pueda usarse para hacer una reescritura en el objetivo.\n  En otras palabras, habría deducido que el teorema `mem_compl_iff` tenía que aplicarse a `A` y `«{x}»`.\n\n  Análogamente, puedes escribir  `rewrite [mem_compl_iff] at «{h2}»` para reescribir el significado de«{h2}»`.\n  Lean deducirá que, en ese caso,  `mem_compl_iff`  se tiene que aplicar a `B` y `«{x}»`.",
 "The `rewrite` tactic is often useful for writing out definitions.  For more information about\nhow it works, click on `rewrite` in the list of tactics on the right.  You can also use `rw`\ninstead of `rewrite`.  (There is actually a small difference between the tactics `rw` and\n`rewrite`, but the difference won't concern us in this game.)\n\nYou'll find the theorem you proved in this level listed as `compl_subset_compl_of_subset` in the list of\ntheorems on the right.  This theorem will be useful in the last level of this world.":
 "\nLa táctica `rewrite` es útil a menudo para reescribir definiciones. Para obtener más información\nsobre cómo funciona, pulsa en `rewrite` en la lista de tácticas a la derecha. También puedes usar\n`rw` en lugar de `rewrite`. (De hecho, hay una pequeña diferencia entre las tácticas `rw` y `rewrite`,\npero esa diferencia no nos preocupará en este juego).\n\nEncontrarás el teorema que demostraste en este nivel listado como  `compl_subset_compl_of_subset` en la lista de\nteoremas a la derecha. Este teorema será útil en el último nivel de este mundo.\n",
 "The `push_neg` tactic can reexpress a number of different kinds of negative statements as\nequivalent positive statements; use\n`push_neg` to reexpress a negative goal, and `push_neg at h` to reexpress a negative assumption `h`.\nWe'll see many more uses of the `apply` tactic in this game.\nFor more details about the use of these tactics,\nclick on `push_neg` or `apply` under the list of tactics on the right.\n\nWe have given this theorem the name `compl_compl`.  Both this theorem and the one in the previous\nlevel will be useful in the next level.":
 "La táctica `push_neg` puede reexpresar distintas declaraciones negativas como positivas; usa\n`push_neg` para reexpresar un objetivo negativo, y `push_neg at h` para reexpresar una suposición negativa `h`.\nVeremos muchos más usos de la táctica `apply` en este juego.\nPara obtener más detalles sobre el uso de estas tácticas,\nhaz click en `push_neg` o `apply` bajo la lista de tácticas a la derecha.\n\nHemos dado a este teorema el nombre `compl_compl`. Tanto este teorema como el del nivel anterior serán útiles en el siguiente nivel.",
 "Suppose that for every $s \\in F$ there is some $u \\in G$ such that $s \\cap u \\in H$.\nThen $(\\bigcup F) \\cap (\\bigcap G) \\subseteq \\bigcup H$.":
 " Supongamos que para cada $s \\in F$ hay algún $u \\in G$ tal que $s \\cap u \\in H$.\nEntonces $(\\bigcup F) \\cap (\\bigcap G) \\subseteq \\bigcup H$.",
 "Suppose `A` is a set and `F` is a family of sets.  In this level you'll determine the conditions\nunder which `⋃₀ F` is a subset of `A`.":
 " Supongamos que `A` es un conjunto y que `F` es una familia de conjuntos. En este nivel, determinarás las condiciones bajo las cuales `⋃₀ F` es un subconjunto de `A`.",
 "Suppose $x \\in A$, and $B$ is any set.  Then $x \\in A ∨ x ∈ B$.":
 "Supongamos que $x \\in A$, y $B$ es cualquier conjunto. Entonces, $x \\in A ∨ x \\in B$.",
 "Suppose $x \\in A$ and $x \\notin B$.  Then $\\neg A \\subseteq B$.":
 "Supongamos que $x \\in A$ y $x \\notin B$.  Entonces $\\neg A \\subseteq B$.",
 "Suppose $x \\in A$ and $x \\in B$.  Then $x \\in A$.":
 "Supongamos que $x \\in A$ y $x \\in B$. Entonces $x \\in A$.",
 "Suppose $x \\in A$ and $x \\in B$.  Then $x \\in A \\cap B$.":
 "Supón que $x \\in A$ y $x \\in B$.  Entonces $x \\in A \\cap B$.",
 "Suppose $x \\in A ∩ B$.  Then $x \\in B$.":
 "Supongamos que $x \\in A \\cap B$. Entonces $x \\in B$.",
 "Suppose $F$ is a family of sets and $A \\in F$.  Then $\\bigcap F \\subseteq A$.":
 "Supongamos que $F$ es una familia de conjuntos y $A \\in F$. Entonces $\\bigcap F \\subseteq A$.",
 "Suppose $F$ is a family of sets and $A \\in F$.  Then $A \\subseteq \\bigcup F$.":
 " Supongamos que $F$ es una familia de conjuntos y $A \\in F$. Entonces, $A \\subseteq \\bigcup F$.",
 "Suppose $F$ and $G$ are families of sets.  Then $\\bigcup (F \\cup G) =\n(\\bigcup F) \\cup (\\bigcup G)$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos. Entonces, $ \\bigcup (F \\cup G) = (\\bigcup F) \\cup (\\bigcup G)$.",
 "Suppose $F$ and $G$ are families of sets.  Then $(\\bigcup F) \\cap (\\bigcup G)^c \\subseteq\n\\bigcup (F \\cap G^c)$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos. Entonces $(\\bigcup F) \\cap (\\bigcup G)^c \\subseteq\n\\bigcup (F \\cap G^c)$.",
 "Suppose $F$ and $G$ are families of sets.  Then $(\\bigcup F) \\cap (\\bigcap G)^c \\subseteq\n\\bigcup \\{s \\mid \\exists u \\in F, \\exists v \\in G, s = u \\cap v^c\\}$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos. Entonces $(\\bigcup F ) \\cap ( \\bigcap G )^c \\subseteq \\bigcup \\{s \\mid \\exists u \\in F, \\exists v \\in G, s = u \\cap v^c\\}$.",
 "Suppose $F$ and $G$ are families of sets.  Then\n$\\bigcap (F \\cup G) = (\\bigcap F) \\cap (\\bigcap G)$.":
 "Supongamos que $F$ y $G$ son familias de conjuntos. Entonces\n$\\bigcap (F \\cup G) = (\\bigcap F) \\cap (\\bigcap G)$.",
 "Suppose $F$ and $G$ are families of sets such that for every $s \\in F$ there is some $t \\in G$\nsuch that $s \\subseteq t$, and also there is some $s \\in F$ such that for every $t \\in G$,\n$t \\subseteq s$.  Then $F$ and $G$ have an element in common.":
 " Supongamos que $F$ y $G$ son familias de conjuntos tal que para cada $s \\in F$ hay algún $t \\in G$\ntal que $s \\subseteq t$, y también hay algún $s \\in F$ tal que para cada $t \\in G$,\n$t \\subseteq s$. Entonces, $F$ y $G$ tienen un elemento en común.",
 "Suppose $F$ and $G$ are families of sets and $\\bigcup (F \\cap G^c) \\subseteq (\\bigcup F)\n\\cap (\\bigcup G)^c$.  Then $(\\bigcup F) \\cap (\\bigcup G) \\subseteq \\bigcup (F \\cap G)$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos y $\\bigcup (F \\cap G^c) \\subseteq (\\bigcup F) \\cap (\\bigcup G)^c$. Entonces $(\\bigcup F) \\cap (\\bigcup G) \\subseteq \\bigcup (F \\cap G)$.",
 "Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\nThen $\\bigcup F \\subseteq \\bigcup G$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos y $F \\subseteq G$.\nEntonces $\\bigcup F \\subseteq \\bigcup G$.",
 "Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\nThen $\\bigcap G \\subseteq \\bigcap F$.":
 " Supongamos que $F$ y $G$ son familias de conjuntos y $F \\subseteq G$.\nEntonces $\\bigcap G \\subseteq \\bigcap F $.",
 "Suppose $A$ is a set.  Then there is some set $S$ such that $S \\subseteq A$.":
 " Supongamos que $A$ es un conjunto. Entonces hay algún conjunto $S$ tal que $S \\subseteq A$.",
 "Suppose $A$ is a set.  Then $(A^c)^c = A$.":
 "Supongamos que $A$ es un conjunto. Entonces $(A^c)^c = A$.",
 "Suppose $A$ is a set, and for every family of sets $F$, if $\\bigcup F = A$ then $A \\in F$.\nThen $A$ must be a singleton set.":
 " Supongamos que $A$ es un conjunto y para cada familia de conjuntos $F$, si $\\bigcup F = A$ entonces $A \\in F$.\nEntonces, $A$ debe ser un conjunto de un solo elemento.",
 "Suppose $A$ is a set, $F$ and $G$ are families of sets, and for every set $s$ in $F$,\n$A \\cup s \\in G$.  Then $\\bigcap G \\subseteq A \\cup (\\bigcap F)$.":
 " Supongamos que $A$ es un conjunto, y $F$ y $G$ son familias de conjuntos, y para cada conjunto $s$ en $F$,\n$A \\cup s \\in G$.  Entonces $\\bigcap G \\subseteq A \\cup (\\bigcap F)$.",
 "Suppose $A$ is a set and $F$ is a family of sets.  Then $\\bigcup F$ is a subset of $A$\nif and only if every element of $F$ is a subset of $A$.":
 " Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos. Entonces $bigcup F$ es un subconjunto de $A$\nsi y solo si cada elemento de $F$ es un subconjunto de $A$.",
 "Suppose $A$ is a set and $F$ is a family of sets.  Then $A$ is a subset of $\\bigcap F$ if\nand only if $A$ is a subset of every element of $F$.":
 " Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos. Entonces, $A$ es un subconjunto de $\\bigcap F$ si y solo si $A$ es un subconjunto de cada elemento de $F$.",
 "Suppose $A$ is a set and $F$ is a family of sets.  Then $A \\cap (\\bigcup F) =\n\\bigcup\\{s \\mid \\exists u \\in F, s = A \\cap u\\}$.":
 " Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos. Entonces $A \\cap (\\bigcup F) =\n\\bigcup\\{s \\mid \\exists u \\in F, s = A \\cap u\\}$.",
 "Suppose $A$ and $B$ are sets.  Then $B \\subseteq A \\cup B$.":
 "Supongamos que $A$ y $B$ son conjuntos. Entonces $B \\subseteq A \\cup B$.",
 "Suppose $A$ and $B$ are sets.  Then $A \\subseteq B$ if and only if $B^c \\subseteq A^c$.":
 "Supón que `A` y `B` son conjuntos. Entonces `A` ⊆ `B` si y solo si $B^c \\subseteq A^c$.",
 "Suppose $A$ and $B$ are sets.  Then $A \\cup B = \\bigcup \\{A, B\\}$.":
 " Supongamos que $A$ y $B$ son conjuntos. Entonces $A \\cup B = \\bigcup \\{A, B\\}$.",
 "Suppose $A$ and $B$ are sets.  Then $A \\cap B = \\bigcap \\{A, B\\}$.":
 " Supongamos que $A$ y $B$ son conjuntos. Entonces $A \\cap B = \\bigcap \\{A, B\\}$.",
 "Suppose $A$ and $B$ are sets, $A \\subseteq B$, and $x \\in A$.\nThen $x \\in B$.":
 "Supón que $A$ y $B$ son conjuntos, $A \\subseteq B$, y $x \\in A$.\nEntonces $x \\in B$.",
 "Suppose $A \\subseteq C$ and $B \\subseteq C$.  Then $A \\cup B \\subseteq C$.":
 " Supongamos que $A \\subseteq C$ y $B \\subseteq C$.  Entonces $A \\cup B \\subseteq C$.",
 "Suppose $A \\subseteq B$.  Then $B^c \\subseteq A^c$.":
 "Supongamos $A \\subseteq B$.  Entonces $B^c \\subseteq A^c$.",
 "Suppose $A \\subseteq B$, $B \\subseteq C$, and $x \\in A$.  Then $x \\in C$.":
 "Supón que $A \\subseteq B$, $B \\subseteq C$, y $x \\in A$.  Entonces $x \\in C$.",
 "Suppose $A \\subseteq B$ and $B \\subseteq C$.  Then $A \\subseteq C$.":
 "Sea $A \\subseteq B$ y $B \\subseteq C$.  Entonces $A \\subseteq C$.",
 "Suppose $A \\subseteq B$ and $A \\subseteq C$.  Then $A \\subseteq B \\cap C$.":
 "Supón que $A \\subseteq B$ y $A \\subseteq C$. Entonces $A \\subseteq B\\cap C$.",
 "Suppose $A \\cup C \\subseteq B \\cup C$ and $A \\cap C \\subseteq B \\cap C$.  Then $A \\subseteq B$.":
 "Suponga que `A ∪ C ⊆ B ∪ C` y `A ∩ C ⊆ B ∩ C`. Entonces `A ⊆ B`.",
 "Subset of family union": "Subconjuntos de la intersección de una familia",
 "Subset of an intersection": "Subconjuntos de una intersección",
 "Subset of a union": "Subconjunto de una unión",
 "Subset is transitive": "La relación de contenido es transitiva.",
 "Subset is reflexive": "La relación de contenido es reflexiva",
 "Subset World": "Mundo de los subconjuntos",
 "Start with `have h2 := h1 {s | ...}`.  The hard part is figuring out\nhow to fill in the `...`.":
 " Comienza con `h2 := h1 {s | ...}`. La parte difícil es descubrir cómo llenar el `...`.",
 "So far the elements of all of our sets have been objects in the universe `U`.  But\nsets can contain other kinds of objects!  In the next two worlds, we will work with sets whose\nelements are *sets of objects from `U`*.  We will call these *families of sets* from `U`.  To\nindicate that `F` is a family of sets from `U`, we write `F : Set (Set U)`.\n\nFor example, suppose `U` contains the people in a certain club, and we want to form a committee\nconsisting of five members of the club.  The set of all possible committees is a family\nof sets from `U`.  Each element of this family is a set containing five club members.\n\nFamilies of sets are sets, and everything you've learned about sets applies to families of sets.\nFor example, if you have `F G : Set (Set U)` and `S : Set U`, then `mem_inter_iff S F G` is a proof\nof the statement `S ∈ F ∩ G ↔ S ∈ F ∧ S ∈ G`.  Similarly, `mem_union S F G` is a proof of\n`S ∈ F ∪ G ↔ S ∈ F ∨ S ∈ G`, and `mem_compl_iff F S` is a proof of `S ∈ Fᶜ ↔ S ∉ F`.\n\nIn this world we extend the idea of intersections to families of sets.  If `F` is a family of\nsets from `U`, then the *intersection* of the family `F` is the set of all objects from `U`\nthat belong to every element of `F`.":
 " Hasta ahora, los elementos de todos nuestros conjuntos han sido objetos del universo `U`.  Pero\nlos conjuntos pueden contener otros tipos de objetos.  En los dos mundos siguientes, trabajaremos con conjuntos cuyos\nelementos son *conjuntos de objetos de `U`*.  Llamaremos a estos *familias de conjuntos* de `U`.  Para\nindicar que `F` es una familia de conjuntos de `U`, escribimos `F : Set (Set U)`.\n\nPor ejemplo, supongamos que `U` contiene las personas de un cierto club, y queremos formar un comité\nde cinco miembros del club.  El conjunto de todos los posibles comités es una familia\nde conjuntos de `U`.  Cada elemento de esta familia es un conjunto que contiene cinco miembros del club.\n\nLas familias de conjuntos son conjuntos, y todo lo que has aprendido sobre conjuntos se aplica a las familias de conjuntos.\nPor ejemplo, si tienes `F G : Set (Set U)` y `S : Set U`, entonces `mem_inter_iff S F G` es una prueba\ndel enunciado `S ∈ F ∩ G ↔ S ∈ F ∧ S ∈ G`.  Similarmente, `mem_union S F G` es una prueba de\n`S ∈ F ∪ G ↔ S ∈ F ∨ S ∈ G`, y `mem_compl_iff F S` es una prueba de `S ∈ Fᶜ ↔ S ∉ F`.\n\nEn este mundo extendemos la idea de intersecciones a familias de conjuntos.  Si `F` es una familia de\nconjuntos de `U`, entonces la *intersección* de la familia `F` es el conjunto de todos los objetos de `U`\nque pertenecen a cada elemento de `F`.",
 "Since your goal is an \"if-then\" statement, a good next step\nis `intro h1`.":
 " Como tu objetivo es un enunciado  de tipo \"si-entonces\", un buen siguiente paso es `intro h1`.",
 "Since your goal is an \"if and only if\" statement, a good next step\nis `apply Iff.intro`.":
 "Dado que tu objetivo es un enunciado \"si y solo si\", un buen siguientepaso es `apply Iff.intro`.",
 "Since we also have `h1 : A ∈ F`, you can apply `«{h2A}»` to `h1` to prove that `«{x}» ∈ A`.\nThis means that `«{h2A}» h1` is a proof of the goal.":
 "Como también tenemos `h1 : A ∈ F`, puedes aplicar `«{h2A}»` a `h1` para probar que `«{x}» ∈ A`. Esto significa que `«{h2A}» h1` es una prueba del objetivo.",
 "Since the goal is a subset statement, you should start by\nintroducing an object `x` and the assumption that `x ∈ A ∩ B`.":
 "Como el objetivo es un enunciado de contenido, debes empezar introduciendoun objeto `x` y la hipótesis de que `x ∈ A ∩ B`.",
 "Since our goal in this level is the statement `x ∈ A → x ∈ C`, our first step for\nthis proof is to assume `x ∈ A`.  To introduce that assumption,\nassigning it the identifier `h3`, type `intro h3`.":
 "Como nuestro objetivo es `x ∈ A → x ∈ C`, el primer paso es asumir `x ∈ A`. Para introducir\n  esta hipótesis asignándole el identificador `h3`, teclea `intro h3`.",
 "Since `«{h1}»` is a negative statement, a good way to reach a contradiction\nwould be to contradict it.  In other words, `«{h1}» _` would prove the goal `False` if you can\nfill in the blank with a proof of `«{x}» ∈ ⋃₀ F`.  That means the tactic `apply «{h1}»` will\nset your goal to be `«{x}» ∈ ⋃₀ F`.":
 " Como `«{h1}»` es una declaración negativa, una buena manera de llegar a una contradicción\nsería contradecirla. En otras palabras, `«{h1}» _` probaría el objetivo `False` si puedes\nrellenar el espacio en blanco con una prueba de `«{x}» ∈ ⋃₀ F`. Eso significa que la táctica\n`apply «{h1}»` establecerá tu objetivo como `«{x}» ∈ ⋃₀ F`.",
 "Since `h1 h2` is a proof of `x ∈ B`, you can\nclose the goal with `exact h1 h2`.":
 "Como `h1 h2` es una prueba de `x ∈ B`, puedes cerrar el objetivo con\n  `exact h1 h2`.",
 "Set Theory Game": "Juego de Teoría de Conjuntos\n\n",
 "Remember, you can use `obtain` to introduce a name for the set that is asserted to\nexist in `«{h1}»`.":
 " Recuerda que puedes usar `obtain` para introducir un nombre para el conjunto que `«{h1}»` afirma que existe.",
 "Remember that the goal `∃ t ∈ F, «{x}» ∈ t` is an abbreviation for\n`∃ t, t ∈ F ∧ «{x}» ∈ t`.  As we saw in the last level, we can prove this by coming up with\na witness--that is, a value for `t` that will make the statement `t ∈ F ∧ «{x}» ∈ t` come out\ntrue.  Looking at\n`h1` and `«{h2}»`, it looks like `t = A` would work.  That suggests a way to proceed:\n`Exists.intro A hA` would prove the goal, if `hA` were a proof of `A ∈ F ∧ «{x}» ∈ A`.  In\nother words, if `Exists.intro A` is applied to a proof of `A ∈ F ∧ «{x}» ∈ A`, then it will\nprove the goal.  So if you use the tactic `apply Exists.intro A`, then Lean will\nset `A ∈ F ∧ «{x}» ∈ A` as your new goal.":
 " Recuerda que el objetivo `∃ t ∈ F, «{x}» ∈ t` es una abreviatura para\n`∃ t, t ∈ F ∧ «{x}» ∈ t`. Como vimos en el último nivel, podemos probar esto creando\nun testigo, es decir, un valor para `t` que haga verdadera la declaración `t ∈ F ∧ «{x}» ∈ t`.\nSi miramos\n`h1` y `«{h2}»`, parece que `t = A` funcionaría. Esto sugiere una forma de proceder:\n`Exists.intro A hA` probaría el objetivo, si `hA` fuera una prueba de `A ∈ F ∧ «{x}» ∈ A`. En\notros términos, si se aplica `Exists.intro A` a una prueba de `A ∈ F ∧ «{x}» ∈ A`, entonces probará\nel objetivo. Por lo tanto, si utilizas la táctica `apply Exists.intro A`, entonces Lean establecerá\n`A ∈ F ∧ «{x}» ∈ A` como tu nuevo objetivo.",
 "Remember that `«{h2}» : ∀ t ∈ F, «{x}» ∈ t` is an abbreviation for\n`«{h2}» : ∀ t, t ∈ F → «{x}» ∈ t`.  Since `∀` means \"for all\", `«{h2}»` can be applied to any\nset--that is, we can plug in any set for `t` in `«{h2}»`.\nIn particular, applying it to the set `A`, we can conclude that `A ∈ F → «{x}» ∈ A`.\nTo apply `«{h2}»` to `A`, we just write `«{h2}»` followed by `A`, with a space between them.\nThus, your next step can be `have «{h2}»A : A ∈ F → «{x}» ∈ A := «{h2}» A`.  You can save yourself\na little typing by writing `have «{h2}»A := «{h2}» A`; Lean will figure out what statement is\nproven by `«{h2}» A`.":
 " Recuerda que `«{h2}» : ∀ t ∈ F, «{x}» ∈ t` es una abreviatura de\n`«{h2}» : ∀ t, t ∈ F → «{x}» ∈ t`. Dado que `∀` significa \"para todo\", `«{h2}»` puede aplicarse a cualquier\nconjunto, es decir, podemos sustituir cualquier conjunto por `t` en `«{h2}»`.\nEn particular, al aplicarlo al conjunto `A`, podemos concluir que `A ∈ F → «{x}» ∈ A`.\nPara aplicar `«{h2}»` a `A`, simplemente escribimos `«{h2}»` seguido de `A`, con un espacio entre ellos.\nAsí, tu siguiente paso puede ser `have «{h2}»A : A ∈ F → «{x}» ∈ A := «{h2}» A`. Puedes ahorrarte\nun poco de tecleo escribiendo `have «{h2}»A := «{h2}» A`; Lean entenderá qué enunciado se prueba con `«{h2}» A`.",
 "Recall that `Subset.refl A` is a proof of `A ⊆ A`.\nSo start your proof with `have h : A ⊆ A := Subset.refl A`.":
 " Recuerda que `Subset.refl A` es una prueba de `A ⊆ A`.\nAsí que puedes empezar tu prueba con `have h : A ⊆ A := Subset.refl A`.",
 "Proving existential statements": "Probar enunciados existenciales",
 "Proving a conjunction": "Demostrar una conjunción",
 "Proof by contradiction": "Demostración por contradicción",
 "Proof by cases": "Demostración por casos",
 "Perhaps you have already guessed that there is a theorem about the complement\nof an intersection of a family that is similar to the theorem in the last level.":
 " Quizás ya adivinaste que hay un teorema sobre el complemento de una intersección de una familia que es similar al teorema en el último nivel.",
 "Our goal in this level is again an equation between sets.  In previous proofs of this kind,\nwe've started with the tactic `apply Subset.antisymm`, and that would work here as well.\nBut we're going to try out an alternative: the tactic `ext`.  This tactic applies the principle\nof *extensionality* for sets, which says that if\ntwo sets have exactly the same elements, then they are equal.":
 "Nuestro objetivo en este nivel es, de nuevo, una ecuación entre conjuntos. En pruebas anteriores de este tipo,\nhemos empezado con la táctica `apply Subset.antisymm`, y eso funcionaría aquí igual.\nPero vamos a probar algo diferente: la táctica `ext`. Esta táctica aplica el principio de *extensionalidad* para conjuntos, que dice que si\ndos conjuntos tienen exactamente los mismos elementos, entonces son iguales.",
 "Our first step is to introduce an object `x` into the proof.  To do this, type `intro x`.\nWe have already seen that the `intro` tactic can be used to introduce a new *assumption* into a\nproof.  This step illustrates a second use of `intro`: introducing a new *object* into a proof.":
 "Nuestro primer paso es introducir un objeto `x` en la prueba. Para hacer esto,\n  escribe `intro x`. Ya hemos visto que la táctica `intro` se puede utilizar para introducir\n  una nueva *suposición* en una prueba. Este paso ilustra un segundo uso de `intro`:\n  introducir un nuevo *objeto* en una prueba.",
 "Or": "O",
 "Once again, the use of `rewrite` was not really necessary.  You could prove this\ntheorem with the single step `exact And.intro h1 h2`.":
 "De nuevo, el uso de `rewrite` no era realmente necesario. Puedes probar\neste teorema con un solo paso usando `exact And.intro h1 h2`.",
 "Once again, Lean has left out some parentheses that it regards as unnecessary.\nLean gives intersection higher precedence than union, so it interprets\n`A ∩ B ∪ A ∩ C` as `(A ∩ B) ∪ (A ∩ C)`.":
 "De nuevo, Lean ha omitido algunos paréntesis que considera innecesarios.\nLean da preferencia a la intersección sobre la unión, así que interpreta\n`A ∩ B ∪ A ∩ C` como `(A ∩ B) ∪ (A ∩ C)`.",
 "Of course, you should begin by introducing the assumption\n`h1 : A ⊆ B`.":
 "Por supuesto, debes comenzar introduciendo la suposición\n`h1 : A ⊆ B`.",
 "Of course, you know by now how to start a proof that one set is a subset of another.":
 "Por supuesto, ahora ya sabes como empezar una demostración de que uno está contenido en el otro.",
 "Of course, you could start the proof in this level with either `ext x` or `apply Subset.antisymm`.\nBut there is a shorter solution: you can use\nthe theorem from the previous level (`compl_union`) to prove the\ntheorem in this level.\n\nThe trick to get started on this proof is to rewrite `Aᶜ ∪ Bᶜ` as `(Aᶜ ∪ Bᶜ)ᶜᶜ`.  As you\nknow, `compl_compl (Aᶜ ∪ Bᶜ)` is a proof of the theorem `(Aᶜ ∪ Bᶜ)ᶜᶜ = Aᶜ ∪ Bᶜ`, and therefore\n`rewrite [compl_compl (Aᶜ ∪ Bᶜ)]` could be used to rewrite `(Aᶜ ∪ Bᶜ)ᶜᶜ` as `Aᶜ ∪ Bᶜ`; but we\nwant to go in the opposite direction, rewriting `Aᶜ ∪ Bᶜ` as `(Aᶜ ∪ Bᶜ)ᶜᶜ`. To do that, use\n`rewrite [← compl_compl (Aᶜ ∪ Bᶜ)]`. (To enter the left-pointing arrow, type `\\l`.)":
 "Por supuesto, podrías empezar la prueba en este nivel con `ext x` o `apply Subset.antisymm`.\nPero hay una solución más corta: puedes utilizar el teorema del nivel anterior (`compl_union`) para probar el\nteorema en este nivel.\n\nEl truco para empezar esta prueba es reescribir `Aᶜ ∪ Bᶜ` como `(Aᶜ ∪ Bᶜ)ᶜᶜ`. Como sabes, `compl_compl (Aᶜ ∪ Bᶜ)` es una prueba del teorema `(Aᶜ ∪ Bᶜ)ᶜᶜ = Aᶜ ∪ Bᶜ`, y por lo tanto\n`rewrite [compl_compl (Aᶜ ∪ Bᶜ)]` podría usarse para rewriting `(Aᶜ ∪ Bᶜ)ᶜᶜ` como `Aᶜ ∪ Bᶜ`; pero queremos ir en la dirección opuesta: reescribir `Aᶜ ∪ Bᶜ` como `(Aᶜ ∪ Bᶜ)ᶜᶜ`. Para hacer eso, utiliza\n`rewrite [← compl_compl (Aᶜ ∪ Bᶜ)]`. (Para introducir la flecha hacia la izquierda, escribe `\\l`).",
 "Of course, to start a subset proof you need to introduce an object `x` and an\nassumption `h3`.":
 "Por supuesto, para empezar una prueba de un contenido necesitas introducir un objeto `x` y una\nhipótesis `h3`.",
 "Now your situation is similar to the previous level.":
 "Ahora tu situación es similar al nivel anterior.",
 "Now your goal starts with `∀ t`.  To prove it, you'll need to introduce\na set `t` into the proof, using the tactic `intro t`.  Recall that the set `t` is\n*arbitrary*--that is, `t` could stand for any set--so whatever we prove about `t` will\nbe true for *all* sets `t`.":
 " Ahora tu objetivo empieza con `∀ t`.  Para probarlo, necesitarás introducir un conjunto `t` en la prueba, utilizando la táctica `intro t`. Recuerda que el conjunto `t` es *arbitrario*--es decir, `t` podría representar cualquier conjunto--así que lo que demostremos sobre `t` será verdadero para *todos* los conjuntos `t`.",
 "Now your goal is an if-then statement; that means `intro` is\nappropriate again, to introduce `«{t}» ∈ F` as a new assumption.":
 " Ahora tu objetivo es un enunciado si-entonces; eso significa que `intro` vuelve a ser apropiado para introducir `«{t}» ∈ F` como una nueva hipótesis.",
 "Now your goal is a negative statement, so try proof by contradiction.":
 "Ahora tu objetivo es una negación, así que intenta demostrarlo por contradicción.",
 "Now you have *two* goals.  For the first, the assumption `«{x}» ∈ A ∨ «{x}» ∈ B` has been\nreplaced with `«{x}» ∈ A`, and for the second it has been replaced with `«{x}» ∈ B`.  In both\ncases, you must prove `«{x}» ∈ C`.  The two identifiers after `with` in the `cases'` tactic\nare used as the identifiers of the new assumptions in the two cases.":
 " Ahora tienes *dos* objetivos. Para el primero, la hipótesis `«{x}» ∈ A ∨ «{x}» ∈ B` ha sido reemplazada con `«{x}» ∈ A`, y para el segundo ha sido reemplazada con `«{x}» ∈ B`. En ambos casos, debes probar `«{x}» ∈ C`. Los dos identificadores después de `with` en la táctica `cases'` se usan como los identificadores de las nuevas hipótesis en los dos casos.",
 "Now you can use `Exists.intro` to complete the proof.":
 " Ahora puedes usar `Exists.intro` para completar la prueba.",
 "Now you can use `And.intro` to prove the goal.":
 "Ahora puedes usar `And.intro` para probar el objetivo.",
 "Now write out the definition of complement in `«{h1}»`.":
 "Ahora escribe la definición de complementario en `«{h1}»`.",
 "Now what statement would you like to contradict to complete the proof?":
 " Ahora, ¿qué enunciado te gustaría contradecir para completar la prueba?",
 "Now we're ready to start proving theorems about unions.":
 "Ahora estamos listos para empezar a probar teoremas sobre uniones.",
 "Now we're ready to start proving theorems about intersections.":
 "Ahora estamos listos para comenzar a probar teoremas sobre intersecciones.",
 "Now use `have` to assert that `«{x}» ∈ A ∪ C`.  If you don't see right\naway how to justify this assertion, you can just write `have hAC : «{x}» ∈ A ∪ C` and Lean will\nset `«{x}» ∈ A ∪ C` as your immediate goal.  Once you achieve that goal, Lean will add\n`hAC : «{x}» ∈ A ∪ C` to your list of assumptions, and you can continue with\nthe proof of your original goal.  For further details, click on `have` in the list of tactics\non the right.":
 "Ahora usa `have` para afirmar que `«{x}» ∈ A ∪ C`. Si no ves de inmediato cómo justificar esta afirmación, puedes escribir simplemente `have hAC : «{x}» ∈ A ∪ C` y Lean establecerá `«{x}» ∈ A ∪ C` como tu objetivo inmediato. Una vez que hayas logrado ese objetivo, Lean agregará `hAC : «{x}» ∈ A ∪ C` a tu lista de hipótesis y podrás continuar con la prueba de tu objetivo original. Para obtener más detalles, haz clic en `have` en la lista de tácticas a la derecha.",
 "Now use `h1`.": " Ahora usa `h1.",
 "Now the assumption `«{h3}»` is an \"or\" statement.  The easiest way to use such an\nassumption is to break your proof into cases.  To do this in Lean, use the tactic\n`cases' «{h3}» with «{h3}»A «{h3}»B`.":
 "Ahora la hipótesis `«{h3}»` es una afirmación de tipo \"o\". La forma más fácil de usar tal suposición es dividir tu prueba en casos. Para hacer esto en Lean, usa la táctica\n`cases' «{h3}» with «{h3}»A «{h3}»B`.",
 "Now that you know `«{x}» ∈ B ∪ C`, you can use that\nstatement as the basis for breaking your proof into cases.":
 "Ahora que sabes `«{x}» ∈ B ∪ C`, puedes usar ese\nenunciado como base para dividir tu prueba en casos.",
 "Now that you have `«{hA}» : «{t}» = A`, you can use `rewrite [«{hA}»]` to replace `«{t}»` with\n`A` in the goal.":
 " Ahora que tienes `«{hA}» : «{t}» = A`, puedes utilizar `rewrite [«{hA}»]` para reemplazar `«{t}»` con `A` en el objetivo.",
 "Now `«{h1}»` says `¬«{x}» ∉ A`, which means `¬¬«{x}» ∈ A`.  Of course, this can be simplified to\n`«{x}» ∈ A`.  To perform this simplification, you'll need a new tactic, `push_neg`.  To simplify\nthe assumption `«{h1}»`, write `push_neg at «{h1}»`.":
 "Ahora `«{h1}»` dice `¬«{x}» ∉ A`, lo que significa `¬¬«{x}» ∈ A`. Por supuesto, esto se puede simplificar a\n`«{x}» ∈ A`. Para realizar esta simplificación, necesitarás una nueva táctica, `push_neg`. Para simplificar la hipótesis `«{h1}»`, escribe `push_neg at «{h1}»`.",
 "Now `mem_compl_iff A «{x}»` is a proof of the statement `«{x}» ∈ Aᶜ ↔ «{x}» ∉ A`, which tells us\nthat we can reexpress the goal `«{x}» ∈ Aᶜ` as `«{x}» ∉ A`.  To do this reexpression,\nuse the tactic `rewrite [mem_compl_iff A «{x}»]`.":
 "ahora `mem_compl_iff A «{x}»` es una prueba de `«{x}» ∈ Aᶜ ↔ «{x}» ∉ A`, lo que viene a decir\nque podemos reescribir el objetivo `«{x}» ∈ Aᶜ` como `«{x}» ∉ A`.  Para hacer esta reescritura,\nusa la táctica `rewrite [mem_compl_iff A «{x}»]`.",
 "Now `And.intro «{h}».right «{h}».left` proves the goal.":
 "Ahora `And.intro «{h}».right «{h}».left` prueba el objetivo.",
 "Notice that, as with intersections, Lean groups unions to the left, so\n`A ∪ B ∪ C` means `(A ∪ B) ∪ C`.":
 " Ten en cuenta que, al igual que con las intersecciones, Lean agrupa uniones a la izquierda, por lo que\n`A ∪ B ∪ C` significa `(A ∪ B) ∪ C`.",
 "Notice that «{h}» is now a proof of the goal.":
 "Observa que «{h}» es ahora una prueba del objetivo.",
 "Notice that you haven't used `h2` yet...":
 "Fíjate que aún no has utilizado `h2`...",
 "Notice that you have contradictory assumptions.  You can prove anything\nfrom contradictory assumptions.  Do you see how?":
 "Fíjate en que tienes suposiciones contradictorias. Puedes probar cualquier cosa a partir de suposiciones contradictorias. ¿Ves cómo?",
 "Notice that the parentheses in the next goal are necessary, to indicate that the universal\nquantifier applies only to the subset statement.  Without the parentheses, Lean would interpret\nthe universal quantifier as applying to the entire rest of the statement.":
 "Fíjate en que los paréntesis en el siguiente objetivo son necesarios, para indicar que el cuantificador universal aplica solo al enunciado del subconjunto. Sin los paréntesis, Lean interpretaría el cuantificador universal como aplicándose al resto de la declaración.",
 "Notice that the goal is now `False`.  To achieve that goal,\nyou must prove contradictory statements.  You can do that by\nusing `have` to assert `x ∈ B`, which will contradict `h2 : x ∉ B`.":
 "Observa que el objetivo es ahora `False`. Para lograr ese objetivo,\n  debes demostrar afirmaciones contradictorias. Puedes hacer esto\n  usando `have` para afirmar `h4 : x ∈ B`, lo cual contradirá a `h2 : x ∉ B`.",
 "Notice that `«{x}» : U` has been added to the list of objects, and\nthe goal has changed to `«{x}» ∈ A → «{x}» ∈ A`.  Fortunately, you already know how to prove\na goal of this form.":
 "Observa que se ha añadido  `«{x}» : U` a la lista de objetos, y\nel objetivo ha cambiado a  `«{x}» ∈ A → «{x}» ∈ A`. Afortunadamente, ya sabes cómo demostrar\nun objetivo de esta forma.",
 "Notice that `«{h4}» : x ∈ B` has been added to the list of assumptions.\nCan you complete the proof now?":
 "Observa que  `{h4} : x ∈ B` se ha añadido a la lista de suposiciones.\n  ¿Puedes completar la demostración ahora?",
 "Notice that `«{h3}» : x ∈ A` is now listed under *Assumptions*, and your new goal is\n`x ∈ C`.":
 "Fíjate en que `«{h3}» : x ∈ A` aparece ahora en el apartado *Assumptions*, y tu nuevo\nobjetivo es `x ∈ C`.",
 "Notice that `«{h1}»` could be applied to a proof of `«{x}» ∈ ⋃₀ F` to\nprove the goal.  That means that `apply «{h1}»` will set `«{x}» ∈ ⋃₀ F` as the goal.":
 " Fíjese que `«{h1}»` se puede aplicar a una prueba de `«{x}» ∈ ⋃₀ F` para probar el objetivo. Eso significa que `apply «{h1}»` establecerá `«{x}» ∈ ⋃₀ F` como el objetivo.",
 "Notice that Lean has written the goal as `A ∩ B ∩ C = A ∩ (B ∩ C)`, with no\nparentheses on the left.  When an intersection of more than two sets is written\nwithout parentheses, Lean groups the intersections to the left, so this means\n`(A ∩ B) ∩ C = A ∩ (B ∩ C)`.\n\nTo start this proof, use the tactic `ext x`.":
 "Fíjate en que Lean ha escrito el objetivo como `A ∩ B ∩ C = A ∩ (B ∩ C)`, sin\nparéntesis a la izquierda. Cuando se escribe una intersección de más de dos conjuntos\nsin paréntesis, Lean agrupa las intersecciones hacia la izquierda, así que esto significa\n`(A ∩ B) ∩ C = A ∩ (B ∩ C)`.\n\nPara iniciar esta prueba, use la táctica `ext x`.",
 "Notice that Lean has introduced the new object `«{x}» : U` into the proof, and\nyour goal is now `«{x}» ∈ A ∩ B ∩ C ↔ «{x}» ∈ A ∩ (B ∩ C)`.  Proving this goal will show that\n`A ∩ B ∩ C` and `A ∩ (B ∩ C)` have exactly the same elements, and by the principle of\nextensionality, that will show that the sets are equal.":
 "Ten en cuenta que Lean ha introducido el nuevo objeto `«{x}» : U` en la prueba, y su objetivo ahora es: `«{x}» ∈ A ∩ B ∩ C ↔ «{x}» ∈ A ∩ (B ∩ C)`. Probar este objetivo demostrará que `A ∩ B ∩ C` y `A ∩ (B ∩ C)` tienen exactamente los mismos elementos, y por el principio de extensionalidad, eso demostrará que los conjuntos son iguales.",
 "Note that you can apply `«{h2}»` to `(A ∪ «{t}»)`.\nYou'll need to include the parentheses around `A ∪ «{t}»` when you do that.":
 "Ten en cuenta que se puede aplicar `«{h2}»` a `(A ∪ «{t}»)`.\nPara ello, debes incluir los paréntesis alrededor de `A ∪ «{t}»` cuando lo hagas.",
 "Note that Lean also has a `cases` tactic, but the syntax is a little more complicated.\nThat's why we have chosen to use the `cases'` tactic.\n\nThe `cases'` tactic has other uses.  However, in this game we will be using it only with\nassumptions that are \"or\" statements, to break the proof into cases.":
 " Ten en cuenta que Lean también tiene una táctica `cases`, pero la sintaxis es un poco más complicada. Por eso hemos decidido utilizar la táctica `cases'`.\nLa táctica `cases'` tiene otros usos, pero en este juego solo lo utilizaremos con\nhipótesis de tipo \"o\", para dividir la prueba en casos.",
 "Next, we'll see how to prove that a union is a subset of another set.":
 " A continuación, veremos cómo probar que una unión es un subconjunto de otro conjunto.",
 "Next we'll prove the associative law for unions.":
 " A continuación probaremos la ley asociativa para las uniones.",
 "Look at what you know about `«{s}»` and `«{t}»`.":
 " Mira lo que sabes sobre `«{s}»` y `«{t}»`.",
 "Let $x$ be an object in the universe $U$, and let $A$ be a set whose elements\ncome from $U$.  Then $x \\in A^c \\leftrightarrow x \\notin A$.":
 "Sea $x$ un objeto en el universo $U$, y sea $A$ un conjunto cuyos elementos\nproceden de $U$.  Entonces $x \\in A^c \\leftrightarrow x \\notin A$.",
 "Let $x$ be an object in the universe $U$, and let $A$ be a set whose elements\ncome from $U$.  Suppose that $x ∈ A$.  Then $x \\in A$.":
 "Sea $x$ un objeto en el universo $U$, y sea $A$ un conjunto cuyos elementos proceden de\n$U$.  Supón que $x ∈ A$.  Entonces $x \\in A$.",
 "Let $x$ be an object from the universe $U$, and let $A$, $B$, and $C$ be sets\nsuch that $A \\subseteq B$ and $x \\in B \\to x \\in C$.  Then $x \\in A → x \\in C$.":
 " Deje que $x$ sea un objeto del universo $U$, y dejemos que $A$, $B$ y $C$ sean conjuntos such that $A \\subseteq B$ and $x \\in B \\to x \\in C$.  Entonces $x \\in A → x \\in C$.",
 "Let $A$ be any set.  Then $A \\subseteq A$.":
 "Sea $A$ un conjunto cualquiera.  Entonces $A \\subseteq A$.",
 "Lean will recognize `mem_singleton_iff` is a proof of any statement of the form\n`x ∈ {a} ↔ x = a`.  In Mathlib, the name of this theorem is `Set.mem_singleton_iff`.":
 " Lean reconocerá que `mem_singleton_iff` es una prueba de cualquier enunciado de la forma\n`x ∈ {a} ↔ x = a`. En Mathlib, el nombre de este teorema es `Set.mem_singleton_iff`.",
 "Lean will recognize `mem_setOf` as a proof of any statement of the form\n`a ∈ {x | P x} ↔ P a`.  In Mathlib, the name of this theorem is `Set.mem_setOf`.":
 " Lean reconocerá `mem_setOf` como una prueba de cualquier enunciado de la forma\n`a ∈ {x | P x} ↔ P a`. En Mathlib, el nombre de este teorema es `Set.mem_setOf`.",
 "Lean will recognize `mem_sUnion` as a proof of any statement of the form\n`x ∈ ⋃₀ F ↔ ∃ t ∈ F, x ∈ t`.  In Mathlib, the name of this theorem is `Set.mem_sUnion`.":
 " Lean reconocerá `mem_sUnion` como una prueba de cualquier enunciado de la forma `x ∈ ⋃₀ F ↔ ∃ t ∈ F, x ∈ t`. En Mathlib, el nombre de este teorema es `Set.mem_sUnion`.",
 "Lean will recognize `mem_sInter` as a proof of any statement of the form\n`x ∈ ⋂₀ F ↔ ∀ t ∈ F, x ∈ t`.  In Mathlib, the name of this theorem is `Set.mem_sInter`.":
 " Lean reconocerá `mem_sInter` como una prueba de cualquier enunciado de la forma\n`x ∈ ⋂₀ F ↔ ∀ t ∈ F, x ∈ t`. En Mathlib, el nombre de este teorema es `Set.mem_sInter`.",
 "Just as you were able to apply `h1` to `«{h3}»` in the last step,\nyou can now apply `h2` to `«{h4}»` to prove the goal.":
 "Igual que pudiste aplicar `h1` a `{h3}` en el paso anterior,\n  ahora puedes aplicar `h2` a `«{h4}»` para probar el objetivo.",
 "It would be helpful if you knew that `A ∈ {A, B}`.\nYou can use `have` to assert it.":
 " Sería útil tener que `A ∈ {A, B}`.\nPuedes utilizar `have` para afirmarlo.",
 "It will help you see how to proceed if you\nwrite out the definition of union in both the assumption `«{h}»` and the goal.":
 "Te puede ser útil escribir la definición de unión tanto en la hipótesis `«{h}»` como en el objetivo.",
 "It will help you see how to proceed if you\nwrite out the definition of intersection in both the assumption «{h}» and the goal.\nUsing the `rewrite` tactic isn't necessary; you can just do the rewriting in\nyour head rather than asking Lean to do it.  But if it helps you to figure out the\nproof, go ahead and use the `rewrite` tactic.":
 "Te ayudará a ver cómo proceder si escribes la definición de intersección\ntanto en la hipótesis «{h}» como en el objetivo. Usar la táctica `rewrite`\nno es necesario; puedes hacer las sustituciones en tu cabeza en lugar de\npedirle a Lean que lo haga. Pero si te ayuda a entender la prueba, adelante\ny usa la táctica `rewrite`.",
 "It will help to get as much information as you can out of `«{h1}»`\nbefore addressing the goal.":
 "Te será útil obtener tanta información como puedas de `«{h1}»` antes de abordar el objetivo.",
 "It may help you see how to proceed if you separate\nout the second half of `«{h}»` as a separate assumption.\nYou can do this with `have «{h}»BC : «{x}» ∈ B ∪ C := «{h}».right`.":
 "Para ver cómo proceder, puede ser útil tener la segunda mitad de `«{h}»` como una suposición separada.\nPuedes hacer esto con `have «{h}»BC : «{x}» ∈ B ∪ C := «{h}».right`.",
 "It looks like `«{h2}»` could get you to the goal, if only\nyou knew that `«{t}» ∈ G`.  Can you prove that?":
 "Parece que `«{h2}»` podría llevarte al objetivo si supieras que `«{t}» ∈ G`. ¿Puedes probarlo?",
 "Intersection subset of swap":
 "La intersección es subconjunto de la intersección permutada",
 "Intersection of larger family is smaller":
 "La intersección de una familia más grande, es más pequeña",
 "Intersection of a union of families": "Intersección de una unión de familias",
 "Intersection of a pair": "Intersección de un par",
 "Intersection of a family of unions":
 "Intersección de una familia de uniones.",
 "Intersection is commutative": " La intersección es conmutativa.",
 "Intersection is associative": "La intersección es asociativa",
 "Intersection is a subset":
 "La intersección está contenida en los conjuntos intersecados.",
 "Intersection distributes over union":
 "Distributividad de la intersección sobre la unión",
 "Intersection World": "Mundo de las intersecciones",
 "In this world you'll prove theorems combining complements, intersections, and unions.  For\nthe most part, we'll leave you on your own to figure out these proofs.":
 "En este mundo tendrás que demostrar teoremas combinando complementarios, intersecciones y uniones. Por lo general, te dejaremos solo para que descubras estas pruebas por ti mismo.",
 "In this world we combine family unions and intersections with each other, and with complements.\nThis level contains some of the hardest proofs in the game!":
 " En este mundo combinamos uniones e intersecciones de familias entre sí y con complementos.\nEste nivel contiene algunas de las pruebas más difíciles del juego!",
 "In this proof, we'll need a new proof technique: proof by cases.  And we'll need a new\ntactic to implement that technique in Lean: `cases'`.":
 " En esta prueba, necesitaremos una nueva técnica de demostración: demostración por casos. Y necesitaremos una nueva táctica para implementar esa técnica en Lean: `cases'`.",
 "In this level, your goal is `Aᶜᶜ = A`--that is, the complement of `Aᶜ` is equal to `A`.\nSo `apply Subset.antisymm` is a good way to start.":
 "En este nivel, tu objetivo es `Aᶜᶜ = A`--eso significa que el complementario de `Aᶜ` es igual a `A`--.\nAsí que `apply Subset.antisymm` es una buena manera de empezar.",
 "In this level, you'll show that, as with intersections, family unions generalize the\nunions we studied in Union World.":
 " En este nivel, demostrarás que, al igual que con las intersecciones, las uniones de familias generalizan las uniones que estudiamos en el mundo de las uniones.",
 "In this level, we'll need to use the definition of \"intersection\".  The theorem that\nexpresses that definition is called `mem_inter_iff`.  If you have `x : U`, `A : Set U`, and\n`B : Set U`, then `mem_inter_iff x A B` is a proof of the statement `x ∈ A ∩ B ↔ x ∈ A ∧ x ∈ B`.\nAs we saw in Complement World, that means that the tactic `rewrite [mem_inter_iff x A B]` can be\nused to replace `x ∈ A ∩ B` in the goal with `x ∈ A ∧ x ∈ B`.  Usually Lean can figure out\n`x`, `A`, and `B` on its own, so you can just write `rewrite [mem_inter_iff]`, and you can\nuse `rewrite [mem_inter_iff] at h` to do the replacement in an assumption `h` rather than\nthe goal.\n\nLike `mem_compl_iff`, `mem_inter_iff` can be proven by using the `rfl` tactic.  But we\nwon't ask you to prove it; it is pre-defined in this game.  To enter the symbol `∩`, you\ncan type `\\inter` or `\\cap`.":
 "En este nivel, necesitaremos usar la definición de \"intersección\". El teorema que expresa esa definición se llama `mem_inter_iff`. Si tienes `x : U`, `A : Set U` y `B : Set U`, entonces `mem_inter_iff x A B` es una prueba del enunciado `x ∈ A ∩ B ↔ x ∈ A ∧ x ∈ B`. Como vimos en el Mundo de los complementarios, eso significa que la táctica `rewrite [mem_inter_iff x A B]` puede utilizarse para reemplazar `x ∈ A ∩ B` en el objetivo por `x ∈ A ∧ x ∈ B`. Por lo general, Lean puede averiguar por sí mismo `x`, `A` y `B`, así que puedes escribir simplemente `rewrite [mem_inter_iff]`, y puedes usar `rewrite [mem_inter_iff] at h` para hacer lo mismo en una hipótesis `h` en lugar del objetivo.\n\nAl igual que `mem_compl_iff`, `mem_inter_iff` puede probarse utilizando la táctica `rfl`. Pero no te pediremos que lo pruebes; ya está predefinido en este juego. Para escribir el símbolo `∩`, puedes teclear `\\inter` o `\\cap`.",
 "In this level, we introduce another way to define sets.  If `P x` is a statement about an\nunspecified object `x`, then `{x | P x}` denotes the set of all values of `x` that make `P x`\ncome out true.  This is often called *set-builder notation*.  For example,\n`{x | x ∈ A ∧ x ∈ B}` is another way to write `A ∩ B`.\n\nAs usual, we have a theorem that states the meaning of set-builder notation.  Lean will\nrecognize `mem_setOf` as a proof of any statement of the form `a ∈ {x | P x} ↔ P a`.\nAnd that means that `rewrite [mem_setOf]` will rewrite `a ∈ {x | P x}` as `P a`.":
 " En este nivel, introducimos otra forma de definir conjuntos. Si `P x` es un enunciado sobre un objeto no especificado `x`, entonces `{x | P x}` denota el conjunto de todos los valores de `x` que hacen que `P x` sea verdadero. Esto a menudo se llama *notación constructora de conjuntos*. Por ejemplo,\n`{x | x ∈ A ∧ x ∈ B}` es otra forma de escribir `A ∩ B`.\n\nComo de costumbre, tenemos un teorema que establece el significado de la notación constructora de conjuntos. Lean reconocerá `mem_setOf` como una prueba de cualquier enunciado de la forma `a ∈ {x | P x} ↔ P a`. Y eso significa que `rewrite [mem_setOf]` reescribirá `a ∈ {x | P x}` como `P a`.",
 "In this level, we have assumptions `h1 : A ⊆ B`, `h2 : B ⊆ C`, and `h3 : x ∈ A`.\nAs we saw in the last level, `h1 h3` is a proof that `x ∈ B`.  Unfortunately,\nthat is not the goal, so we can't use `exact h1 h3` to close the goal.\nHowever, we can use the proof `h1 h3` to justify adding `h4 : x ∈ B` to our\nlist of assumptions.  To do that, we'll use a new tactic: `have`.":
 "\nEn este nivel, tenemos las hipótesis `h1 : A ⊆ B`, `h2 : B ⊆ C`, y `h3 : x ∈ A`.\nComo vimos en el nivel anterior, `h1 h3` es una prueba de que `x ∈ B`. Lamentablemente,\nese no es el objetivo, así que no podemos usar `exact h1 h3` para cerrar el objetivo.\nSin embargo, podemos usar la prueba `h1 h3` para justificar agregar `h4 : x ∈ B` a nuestra\nlista de suposiciones. Para hacer eso, usaremos una nueva táctica: `have`.\n",
 "In this level, `F` and `G` are families of sets, and you'll work out how `⋃₀ (F ∪ G)` is related\nto `⋃₀ F` and `⋃₀ G`.":
 " En este nivel, `F` y `G` son familias de conjuntos, y tendrás que averiguar cómo se relaciona `⋃₀ (F ∪ G)` con `⋃₀ F` y `⋃₀ G`.",
 "In this level you'll prove a generalization of the theorem `compl_union` that you proved\nin Combination World.  That theorem was about the complement of a union of two sets; the\ntheorem in this level is about the complement of a union of a family of sets.\n\nAs in the case of `compl_union`, you have a choice about how to deal with the negations that\narise when you write out the meaning of complement.  You can use the `push_neg` tactic to\nreexpress negative statements, or you can use proof by contradiction.":
 " En este nivel, demostrarás una generalización del teorema `compl_union` que probaste en el mundo combinado. Ese teorema trataba sobre el complemento de la unión de dos conjuntos; el teorema en este nivel trata sobre el complemento de la unión de una familia de conjuntos.\n\nComo en el caso de `compl_union`, puedes elegir cómo lidiar con las negaciones que surgen cuando escribes el significado del complemento. Puedes usar la táctica `push_neg` para re-expresar declaraciones negativas, o puedes hacer una prueba por contradicción.",
 "In this level you'll need a new kind of proof by cases.  For any statement `P`, the\ntactic `by_cases h : P` will break the proof into two cases.  In the first case, the new\nassumption `h : P` is added to the list of assumptions, and in second, the new\nassumption `h : ¬P` is added.  Since `P` must be either true or false, these two cases cover\nall possibilities.":
 "En este nivel necesitarás un nuevo tipo de prueba por casos. Para cualquier enunciado `P`, la táctica `by_cases h : P` dividirá la prueba en dos casos.En el primer caso, se añade la nueva suposición `h : P` a la lista de suposiciones y en segundo lugar, se añade la nueva suposición `h : ¬P`. Dado que `P` debe ser verdadero o falso, estos dos casos cubren todas las posibilidades.",
 "In this level we'll prove a statement of the form `P ∧ Q`.  To do this, we'll need\nanother theorem: `And.intro`.  If you have `h1 : P` and `h2 : Q`, then\n`And.intro h1 h2` is a proof of `P ∧ Q`.":
 "En este nivel demostraremos un enunciado de la forma `P ∧ Q`. Para hacer\nesto, necesitaremos otro teorema: `And.intro`. Si tienes `h1 : P` y `h2 :Q`,\nentonces `And.intro h1 h2` es una prueba de `P ∧ Q`.",
 "In this level we have two families of sets, `F` and `G`, with `F ⊆ G`.  That means that\n`⋂₀ G` is the intersection of a family of sets that includes all the sets in `F`, plus\nperhaps more sets.  You're going to prove that intersecting this larger collection of sets\nleads to a smaller result; more precisely, you're going to prove that `⋂₀ G ⊆ ⋂₀ F`.\n\nOf course, by now you know how to start a proof that one set is a subset of another.":
 " En este nivel tenemos dos familias de conjuntos, `F` y `G`, con `F ⊆ G`. Esto significa que\n`⋂₀ G` es la intersección de una familia de conjuntos que incluye todos los conjuntos en `F`, más\nquizás más conjuntos. Vas a probar que intersecar esta colección más grande de conjuntos\nlleva a un resultado más pequeño; más precisamente, vas a probar que `⋂₀ G ⊆ ⋂₀ F`.\n\nPor supuesto, ya sabes cómo empezar una prueba de que un conjunto es un subconjunto de otro.",
 "In this level we have two families of sets, `F` and `G`, with `F ⊆ G`.  In Family Intersection\nWorld, you proved that in this situation, `⋂₀ G ⊆ ⋂₀ F`.  In this level, you'll prove that\nwith family unions, it works the other way: `⋃₀ F ⊆ ⋃₀ G`.\n\nWe'll need a new tactic for this proof.  An assumption of the form `h : ∃ x, P x` tells you that\nan object with a certain property exists.  If you have such an assumption, then it is usually\nhelpful to introduce a name for such an object.  You can do this with the `obtain` tactic.  If\nyou write `obtain ⟨w, hw⟩ := h`, then Lean will introduce a new object `w` and a new assumption\n`hw : P w`.  Thus, the object `w` is a witness for the existential assumption `h`.  Note that\nin the `obtain` tactic, `w` and `hw` must be enclosed in angle brackets: `⟨ ⟩`.  You can\nenter these by typing either `\\<` and `\\>` or `\\langle` and `\\rangle`.":
 " En este nivel tenemos dos familias de conjuntos, `F` y `G`, con `F ⊆ G`. En el Mundo de la intersección de familias, demostraste que en esta situación, `⋂₀ G ⊆ ⋂₀ F`. En este nivel, probarás que con uniones de familias, funciona al revés: `⋃₀ F ⊆ ⋃₀ G`.\n\nNecesitaremos una nueva táctica para esta prueba. Una suposición de la forma `h : ∃ x, P x` te dice que existe un objeto con cierta propiedad. Si tienes una hipótesis así, entonces suele ser útil introducir un nombre para tal objeto. Lo puedes hacer con la táctica `obtain`. Si escribes `obtain ⟨w, hw⟩ := h`, entonces Lean introducirá un nuevo objeto `w` y una nueva suposición `hw : P w`. Por lo tanto, el objeto `w` es un testigo para la suposición existencial `h`. Ten en cuenta que en la táctica `obtain`, `w` y `hw` deben estar encerrados en corchetes angulares: `⟨ ⟩`. Puedes escribirlos tecleando `\\<` y `\\>` o `\\langle` y `\\rangle`.",
 "In this last level of Complement World, you'll prove a statement of the form `P ↔ Q`.  The most\nuseful theorem for this purpose is `Iff.intro`.  If you have `h1 : P → Q` and `h2 : Q → P`, then\n`Iff.intro h1 h2` is a proof of `P ↔ Q`.  As we saw in the last level, that means you can start your\nproof with `apply Iff.intro`.  Lean will set `P → Q` and `Q → P` as the goals that are needed\nto complete the proof.":
 "En este último nivel del mundo de complementarios, demostrarás un enunciado dela forma `P ↔ Q`. El teorema más útil para este propósito es `Iff.intro`. Si tienes `h1 : P → Q` y `h2 : Q → P`, entonces `Iff.intro h1 h2` es una prueba de `P ↔ Q`. Como vimos en el último nivel, eso significa que puedes comenzar tu prueba con `apply Iff.intro`. Lean establecerá `P → Q` y `Q → P` como los objetivos que deben ser probados para completar la demostración.",
 "In this game you will learn the basics of theorem proving in Lean by proving\ntheorems about unions, intersections, and complements of sets.":
 " En este juego aprenderás los conceptos básicos de prueba de teoremas en Lean al probar teoremas sobre uniones, intersecciones y complementos de conjuntos.",
 "In the next level we're going to prove that union is commutative; that is,\n`A ∪ B = B ∪ A`.  We're going to imitate the approach we used in Intersection World\nto prove that intersection is commutative.  We begin by proving `A ∪ B ⊆ B ∪ A`.":
 " En el siguiente nivel vamos a probar que la unión es conmutativa; es decir,\n`A ∪ B = B ∪ A`. Vamos a imitar el enfoque que utilizamos en el Mundo de las Intersecciones\npara probar que la intersección es conmutativa. Comenzamos demostrando `A ∪ B ⊆ B ∪ A`.",
 "In the next level we're going to prove that intersection is commutative; that is,\n`A ∩ B = B ∩ A`.  As a warm-up, in this level we prove `A ∩ B ⊆ B ∩ A`.":
 "En el siguiente nivel vamos a probar que la intersección es conmutativa; es decir,\n`A ∩ B = B ∩ A`. Como calentamiento, en este nivel probaremos `A ∩ B ⊆ B ∩ A`.",
 "In the last level, you proved the theorem `mem_compl_iff`.  If you have `A : Set U` and `x : U`,\nthen `mem_compl_iff A x` is a proof of the statement `x ∈ Aᶜ ↔ x ∉ A`.\n\nYou could think of the statement `x ∈ Aᶜ ↔ x ∉ A` as saying that if `x ∈ Aᶜ` occurs anywhere\nin a proof, you can replace it with `x ∉ A`.  There is a tactic called `rewrite` that can be\nused to perform such replacements.  You'll get to try out the `rewrite` tactic in this level.":
 "\nEn el último nivel, demostraste el teorema `comp_def`. Si tienes `x : U` y `A : Set U`,\nentonces `comp_def x A` es una prueba de la afirmación `x ∈ Aᶜ ↔ x ∉ A`.\n\nPodrías pensar en la afirmación `x ∈ Aᶜ ↔ x ∉ A` como decir que si `x ∈ Aᶜ` ocurre en cualquier\nparte de una prueba, puedes reemplazarlo con `x ∉ A`. Hay una táctica llamada `rewrite` que se puede\nusar para realizar tales reemplazos. Tendrás la oportunidad de probar la táctica `rewrite` en este nivel.\n",
 "In order to complete this proof, type `exact h` in the text box\nunder the goal and click on \"Execute\" or hit the \"Return\" or \"Enter\" key.":
 "Para completar esta prueba, teclea `exact h` en la caja de texto bajo el objetivo\n  y haz click en  \"Execute\" o pulsa le tecla \"Return\" o \"Enter\".",
 "In mathematical writing, the union of the family $F$ is usually denoted $\\bigcup F$.\nIn Lean, the union of a family `F` is denoted `⋃₀ F`.  (You can enter the symbol\n`⋃₀` by typing `\\U0`.)\n\nSuppose we have `F : Set (Set U)` and `x : U`.  Then `x ∈ ⋃₀ F` means that there is at least\none set `t` such that `t ∈ F` and `x ∈ t`.  To write this statement in Lean, we write\n`∃ t, t ∈ F ∧ x ∈ t`.  Lean abbreviates this statement as `∃ t ∈ F, x ∈ t`.\n\nAs with other set theory operations, we have a theorem that expresses this definition.  Lean will\nrecognize `mem_sUnion` as a proof of any statement of the form `x ∈ ⋃₀ F ↔ ∃ t ∈ F, x ∈ t`.\n\nIn this level, you'll try out these ideas.":
 " En la notación matemática, la unión de la familia $F$ suele denotarse como $ \\bigcup F$.\nEn Lean, la unión de una familia `F` se denota con `⋃₀ F`. (Puedes ingresar el símbolo\n`⋃₀` escribiendo `\\U0`.)\n\nSupongamos que tenemos `F : Set (Set U)` y `x : U`. Entonces, `x ∈ ⋃₀ F` significa que hay al menos\nun conjunto `t` tal que `t ∈ F` y `x ∈ t`. Para escribir este enunciado en Lean, escribimos\n`∃ t, t ∈ F ∧ x ∈ t`. Lean abrevia este enunciado como `∃ t ∈ F, x ∈ t`.\n\nComo con otras operaciones de la teoría de conjuntos, tenemos un teorema que expresa esta definición. Lean reconocerá `mem_sUnion` como una prueba de cualquier declaración del tipo `x ∈ ⋃₀ F ↔ ∃ t ∈ F, x ∈ t`.\n\nEn este nivel, probarás estas ideas.",
 "In mathematical writing, the intersection of the family $F$ is usually denoted $\\bigcap F$.\nIn Lean, the intersection of a family `F` is denoted `⋂₀ F`.  (You can enter the symbol\n`⋂₀` by typing `\\I0`.)\n\nSuppose we have `F : Set (Set U)` and `x : U`.  Then `x ∈ ⋂₀ F` means that for every set `t`, if\n`t` is in `F`, then `x ∈ t`.  To write this statement in Lean, we write `∀ t, t ∈ F → x ∈ t`.\nLean abbreviates this statement as `∀ t ∈ F, x ∈ t`.\nThe symbol `∀` is called the *universal quantifier*, and you can enter it in Lean by typing\n`\\forall`.  Note that `∀ t, t ∈ F → x ∈ t` means `∀ t, (t ∈ F → x ∈ t)`, not\n`(∀ t, t ∈ F) → x ∈ t`.  In other words, Lean interprets the universal quantifier as applying\nto the entire rest of the statement.  If you want it to apply to less, you have to\nuse parentheses to indicate that.\n\nAs with other set theory operations, we have a theorem that expresses this definition.  Lean will\nrecognize `mem_sInter` as a proof of any statement of the form `x ∈ ⋂₀ F ↔ ∀ t ∈ F, x ∈ t`.\n\nIn this level, you'll try out these ideas.":
 "En notación matemática, la intersección de la familia $F$ suele denotarse como $\\bigcap F$.\nEn Lean, la intersección de una familia `F` se denota `⋂₀ F`. (Puedes ingresar el símbolo\n`⋂₀` escribiendo `\\I0`.)\n\nSupongamos que tenemos `F : Set (Set U)` y `x : U`. Entonces `x ∈ ⋂₀ F` significa que para cada conjunto `t`, si\n`t` está en `F`, entonces `x ∈ t`. Para escribir esta declaración en Lean, escribimos `∀ t, t ∈ F → x ∈ t`.\nLean abrevia esta declaración como `∀ t ∈ F, x ∈ t`.\nEl símbolo `∀` se llama el *cuantificador universal*, y puedes introducirlo en Lean escribiendo\n`\\forall`. Note que `∀ t, t ∈ F → x ∈ t` significa `∀ t, (t ∈ F → x ∈ t)`, no\n`(∀ t, t ∈ F) → x ∈ t`. En otras palabras, Lean interpreta el cuantificador universal como aplicándose al resto de la declaración. Si quieres que se aplique a menos, debes utilizar paréntesis para indicarlo.\n\nComo con otras operaciones de teoría de conjuntos, tenemos un teorema que expresa esta definición. Lean reconocerá `mem_sInter` como una prueba de cualquier enunciado de la forma `x ∈ ⋂₀ F ↔ ∀ t ∈ F, x ∈ t`.\n\nEn este nivel, trabajaremos estas ideas.",
 "In general, if your goal has the form `P → Q`, then the tactic `intro h` will add `h : P` to\nthe list of assumptions and set `Q` to be the goal.  If you have assumptions\n`h1 : P → Q` and `h2 : P`, then `h1 h2` is a proof of `Q`.  This is another example of a proof\nacting like a function: a proof of `P → Q` can be thought of as a function which, when\napplied to a proof of `P`, produces a proof of `Q`.\n\nAs usual, for more information about the new tactic `intro`, you can click on `intro`\nin the list of tactics on the right.":
 "\nEn general, si tu objetivo es de la forma `P → Q`, la táctica `intro h` añadirá `h : P` a la lista\nde hipótesis, y establecerá `Q` como el objetivo a probar. Si tienes hipótesis\n`h1 : P → Q` y `h2 : P`, `h1 h2` es una prueba de `Q`. Este es otro ejemplo de una prueba funcionando\ncomo una función: una prueba de `P → Q` se puede ver como una función que, cuando se aplica a `P`\nproduce una prueba de `Q`.\n\nComo de costumbre, para más información sobre la táctica `intro`, puedes pulsar en\n`intro` en la lista de tácticas de la derecha.\n",
 "In general, if you think that some theorem `t` could be used to prove the goal, the tactic\n`apply t` will work backwards from the goal, setting as new goals any hypotheses that are\nneeded for the application of the theorem `t`.\n\nIf your goal has the form `P ∧ Q`, then the `constructor` tactic will have the same\neffect as `apply And.intro`; that is, it will set `P` and `Q` as goals to be proven.":
 "En general, si crees que algún teorema `t` podría usarse para probar el objetivo, la táctica\n`apply t` funcionará hacia atrás desde el objetivo, estableciendo como nuevos objetivos las hipótesis que sean necesarias para la aplicación del teorema `t`.\n\nSi tu objetivo tiene la forma `P ∧ Q`, entonces la táctica `constructor` tendrá el mismo efecto que `apply And.intro`; es decir, establecerá `P` y `Q` como objetivos para ser probados.",
 "Implication": "Implicaciones",
 "If your goal is a statement of the form `P ↔ Q`, and `P` and `Q` are definitionally\nequivalent (that is, equivalent by virtue of the definitions of the symbols occurring in\nthem), then the `rfl` tactic will close the goal.  It will also close a goal of the form\n`X = Y`, if `X` and `Y` are definitionally equal (that is, equal by virtue of definitions).":
 "Si tu objetivo es una afirmación de la forma `P ↔ Q`, y `P` y `Q` son equivalentes por definición\n(es decir, equivalentes por virtud de las definiciones de los símbolos que aparecen en ellas),\nentonces la táctica `rfl` cerrará el objetivo. También cerrará un objetivo de la forma\n`X = Y`, si `X` e `Y` son iguales por definición.\n",
 "If your goal is a negative statement, then the tactic `push_neg` will try to reexpress it as\nan equivalent positive statement.  Similarly, if an assumption `h` is a negative\nstatement, then `push_neg at h` will try to reexpress `h`.  Here are some examples of\nreexpressions performed by the `push_neg` tactic:\n* `¬¬P` is converted to `P`.\n* `¬(P ∨ Q)` is converted to `¬P ∧ ¬Q`.\n* `¬(P ∧ Q)` is converted to `P → ¬Q`.\n* `¬(P → Q)` is converted to `P ∧ ¬Q`.\n* `¬∀ x, P x` is converted to `∃ x, ¬P x`.\n* `¬∃ x, P x` is converted to `∀ x, ¬P x`.":
 "Si tu objetivo es un enunciado negativo, entonces la táctica `push_neg` intentará reexpresarlo como un enunciado equivalente positivo. De manera similar, si una hipótesis `h` es un enunciado negativo, entonces `push_neg at h` intentará reexpresar `h`. Aquí hay algunos ejemplos de reexpresiones realizadas por la táctica `push_neg`:\n* `¬¬P` se convierte en `P`.\n* `¬(P ∨ Q)` se convierte en `¬P ∧ ¬Q`.\n* `¬(P ∧ Q)` se convierte en `P → ¬Q`.\n* `¬(P → Q)` se convierte en `P ∧ ¬Q`.\n* `¬∀ x, P x` se convierte en `∃ x, ¬P x`.\n* `¬∃ x, P x` se convierte en `∀ x, ¬P x`.",
 "If your goal is `∃ x, P x`, where `P x` represents some statement about `x`, and `a` is a\nvalue that could be assigned to `x`, then the tactic `use a` will\nset `P a` to be the goal.  It will then see if this new goal follows easily from your\nassumptions, and if so it will close the goal.":
 " Si tu objetivo es `∃ x, P x`, donde `P x` representa alguna afirmación sobre `x`, y `a` es un\nvalor que podría asignarse a `x`, entonces la táctica `use a` establecerá `P a` como objetivo.  Luego verá si este nuevo objetivo se sigue fácilmente de sus suposiciones, y si es así, cerrará el objetivo.",
 "If your goal is `¬P`, for some statement `P`, then the tactic\n`by_contra h` will introduce the new assumption `h : P`, and set the\ngoal to be `False`.  If your goal is a statement `P` that is not a negative\nstatement, then `by_contra h` will introduce the new assumption\n`h : ¬P`.\n\nTo achieve your new goal, you will need to establish\n`h1 : Q` and `h2 : ¬Q`, for some statement `Q`.  If you can do that,\nthen `h2 h1` will prove the goal `False`.  Notice that `h1 h2` will not be\nrecognized as a proof of `False`; the negative statement must come first.":
 "Si tu objetivo es `¬P`, para alguna afirmación `P`, entonces la táctica`by_contra h` introducirá la nueva suposición `h : P` y establecerá el objetivo como `False`. Si tu objetivo es una afirmación `P` que no es negativa,entonces `by_contra h` introducirá la nueva suposición`¬P`.Para lograr tu nuevo objetivo, deberás establecer`h1 : Q` y `h2 : ¬Q`, para alguna afirmación `Q`. Si puedes hacer eso,entonces `h2 h1` demostrará el objetivo `False`. Observa que `h1 h2` no será reconocido como una prueba de `False`; la afirmación negativa debe venir primero.",
 "If your goal is `A = B`, where `A` and `B` are sets, then the tactic `ext x` will introduce\na new arbitrary object `x` into the proof and set the goal to be `x ∈ A ↔ x ∈ B`.":
 "Si tu objetivo es `A = B`, donde `A` y `B` son conjuntos, entonces la táctica `ext x` introducirá\nun nuevo objeto `x` arbitrario en la prueba y `x ∈ A ↔ x ∈ B` como nuevo objetivo.",
 "If you're stuck at this point,\nit may help you see how to proceed if you separate\nout the first half of `«{h1}»` as a separate assumption.\nYou can do this with `have hAB : «{x}» ∈ A ∩ B := «{h1}».left`.":
 "Si te atascas en este punto,\nte puede ser útil si separar\nla primera mitad de `«{h1}»` como una suposición separada.\nPuedes hacer esto con `have hAB : «{x}» ∈ A ∩ B := «{h1}».left`.",
 "If you start your proof with `apply Subset.antisymm`, then you'll be able to use\nthe theorem `union_subset_swap` that you proved in the last level.":
 " Si comienzas tu prueba con `apply Subset.antisymm`, podrás usar\nel teorema `union_subset_swap` que demostraste en el último nivel.",
 "If you have an assumption `h : ∃ x, P x`, then the tactic `obtain ⟨w, hw⟩ := h` will\nintroduce a new object `w` and a new assumption `hw : P w` into the proof.  To enter the\nangle brackets `⟨ ⟩`, type either `\\<` and `\\>` or `\\langle` and `\\rangle`.":
 " Si tienes una suposición `h : ∃ x, P x`, entonces la táctica `obtain ⟨w, hw⟩ := h` introducirá un nuevo objeto `w` y una nueva suposición `hw : P w` en la prueba. Para ingresar los corchetes angulares `⟨ ⟩`, teclea  `\\<` y `\\>` o `\\langle` y `\\rangle`.",
 "If you have `x : U`, `A : Set U`, and `B : Set U`, then `mem_union x A B` is a proof of the\nstatement `x ∈ A ∪ B ↔ x ∈ A ∨ x ∈ B`.  In Mathlib, the name of this theorem is `Set.mem_union`.":
 "Si tienes `x : U`, `A : Set U`, y `B : Set U`, entonces `mem_union x A B` es una prueba del enunciado `x ∈ A ∪ B ↔ x ∈ A ∨ x ∈ B`. En Mathlib, el nombre de este teorema es `Set.mem_union`.",
 "If you have `x : U`, `A : Set U`, and `B : Set U`, then `mem_inter_iff x A B` is a proof of the\nstatement `x ∈ A ∩ B ↔ x ∈ A ∧ x ∈ B`.\nIn Mathlib, the name of this theorem is `Set.mem_inter_iff`.":
 "Si tienes `x : U`, `A : Set U`, y `B : Set U`, entonces `mem_inter_iff x A B` es una prueba del\nenunciado `x ∈ A ∩ B ↔ x ∈ A ∧ x ∈ B`.\nEn Mathlib, el nombre de este teorema es `Set.mem_inter_iff`.",
 "If you have `h1 : P` and `h2 : Q`, then `And.intro h1 h2` is a proof of `P ∧ Q`.":
 "Si tienes `h1 : P` y `h2 : Q`, entonces `And.intro h1 h2` es una prueba de `P ∧ Q`.",
 "If you have `h1 : P → Q` and `h2 : Q → P`, then `Iff.intro h1 h2` is a proof of `P ↔ Q`.":
 "Si tienes `h1 : P → Q` y `h2 : Q → P`, entonces `Iff.intro h1 h2` es una prueba de `P ↔ Q`.",
 "If you have `h1 : A ⊆ B` and `h2 : B ⊆ C`, then `Subset.trans h1 h2` is a proof of `A ⊆ C`.\nIn Mathlib, the name of this theorem is `Set.Subset.trans`.":
 "Si tienes `h1 : A ⊆ B` y `h2 : B ⊆ C`, `sub_trans h1 h2` es una prueba de `A ⊆ C`.\nEn Mathlib, el nombre de este teorema es `Set.Subset.trans`.",
 "If you have `h1 : A ⊆ B` and `h2 : B ⊆ A`, then `Subset.antisymm h1 h2` is a proof of `A = B`.\nIn Mathlib, the name of this theorem is `Set.Subset.antisymm`.":
 "Si tienes `h1 : A ⊆ B` y `h2 : B ⊆ A`, entonces `Subset.antisymm h1 h2` es una prueba de `A = B`.\nEn Mathlib, el nombre de este teorema es `Set.Subset.antisymm`.",
 "If you have `h : Q`, then `Or.inr h` can be used as a proof of `P ∨ Q`, for\nany statement `P`.":
 "Si tienes `h : Q`, entonces `Or.inr h` puede usarse como una prueba de `P ∨Q`, para cualquier enunciado `P`.",
 "If you have `h : P`, then `Or.inl h` can be used as a proof of `P ∨ Q`, for\nany statement `Q`.":
 "Si tienes `h : P`, entonces `Or.inl h` se puede usar como prueba de `P ∨ Q`, para cualquier enunciado `Q`.",
 "If you have `h : A ⊆ B`, then `compl_subset_compl_of_subset h` is a proof of `Bᶜ ⊆ Aᶜ`.\nIn Mathlib, the name of this theorem is `Set.compl_subset_compl_of_subset`.":
 "Si tienes `h : A ⊆ B`, entonces `compl_subset_compl_of_subset h` es una prueba de `Bᶜ ⊆ Aᶜ`.\nEn Mathlib, este teorema se llama `Set.compl_subset_compl_of_subset`.",
 "If you have `A : Set U`, then `Subset.refl A` is a proof of `A ⊆ A`.\nIn Mathlib, the name of this theorem is `Set.Subset.refl`.":
 "Si tenemos `A : Set U`, entonces `sub_ref A` es una prueba de que `A ⊆ A`.\nEn Mathlib, este teorema se llama `Set.Subset.refl`.",
 "If you have `A : Set U`, then `Aᶜ` is defined to be the set of all objects in the universe `U`\nthat are not elements of `A`.  That means that if you also have `x : U`, then the statements\n`x ∈ Aᶜ` and `x ∉ A` are equivalent.  We express this by saying that the statement\n`x ∈ Aᶜ ↔ x ∉ A` is true.  (The symbol `↔` means \"if and only if\", and you can enter it\nby typing `\\iff`.  You can enter the superscript `c` in the notation for the complement\nof a set by typing `\\compl` or `\\^c`.)\n\nIn this level, we're going to prove that the statement `x ∈ Aᶜ ↔ x ∉ A` is true, and to do\nit we'll use a new tactic: `rfl`.  The `rfl` tactic can prove any statement of the form\n`P ↔ Q` if `P` and `Q` are statements that are equivalent by virtue of the definitions of\nthe symbols occurring in them.  (We say in this case that `P` and `Q` are *definitionally\nequivalent*.)  The `rfl` tactic can also prove statements of the form `X = Y`, if `X` and\n`Y` are definitionally equal--that is, equal by virtue of definitions.":
 "\nSi tienes `A : Set U`, entonces `Aᶜ` se define como el conjunto de todos los objetos en el universo\n`U` que no son elementos de `A`. Esto significa que si también tienes `x : U`, entonces las\nafirmaciones `x ∈ Aᶜ` y `x ∉ A` son equivalentes. Expresamos esto diciendo que la afirmación\n`x ∈ Aᶜ ↔ x ∉ A` es verdadera. (El símbolo `↔` significa \\\"si y solo si\\\", y puedes introducirlo\nescribiendo `\\iff`. Puedes ingresar el superíndice `c` en la notación para el complemento de un\nconjunto escribiendo `\\compl` o `\\^c`.)\n\nEn este nivel, vamos a demostrar que la afirmación `x ∈ Aᶜ ↔ x ∉ A` es verdadera, y para hacerlo\nusaremos una nueva táctica: `rfl`. La táctica `rfl` puede demostrar cualquier afirmación de la forma\n`P ↔ Q` si `P` y `Q` son afirmaciones que son equivalentes por virtud de las definiciones de los\nsímbolos que aparecen en ellas. (Decimos en este caso que `P` y `Q` son *equivalentes por definición*.)\nLa táctica `rfl` también puede demostrar afirmaciones de la forma `X = Y`,\nsi `X` e `Y` son iguales por definición.\n",
 "If you have `A : Set U` and `x : U`, then `mem_compl_iff A x` is a proof of the statement\n`x ∈ Aᶜ ↔ x ∉ A`.  In Mathlib, the name of this theorem is `Set.mem_compl_iff`.":
 "Si tienes `x : U` y `A : Set U`, entonces `comp_def x A` es una prueba de la afirmación\n`x ∈ Aᶜ ↔ x ∉ A`.",
 "If you had `hB : «{x}» ∈ B` and `hC : «{x}» ∈ C`, then `And.intro hB hC`\nwould prove the goal.  So there are two ways to proceed.  One possibility is to use\n`have` to introduce the assumptions `«{x}» ∈ B` and `«{x}» ∈ C`--that is, if you can see\nhow to justify those statements!  Then you can use `And.intro` to prove the goal.\n\nThe second possibility is to use the `apply` tactic.  Recall that if you write\n`apply And.intro`, then Lean will figure out that the\ntheorem `And.intro` could be applied to prove the goal, if only you had proofs of\n`«{x}» ∈ B` and `«{x}» ∈ C`.  So it will set those two statements as goals, to be proven\none after the other.":
 "Si tuvieras `hB : «{x}» ∈ B` y `hC : «{x}» ∈ C`, entonces `And.intro hB hC`\nprobaría el objetivo. Así que hay dos maneras de proceder. Una posibilidad es usar\n`have` para introducir las suposiciones `«{x}» ∈ B` y `«{x}» ∈ C` -- si puedes ver\ncómo justificar esas declaraciones-- Luego puedes usar `And.intro` para probar el objetivo.\n\nLa segunda posibilidad es usar la táctica `apply`. Recuerda que si escribes\n`apply And.intro`, entonces Lean se dará cuenta de que el\nteorema `And.intro` podría aplicarse para probar el objetivo, solo necesitarías pruebas de\n`«{x}» ∈ B` y `«{x}» ∈ C`. Entonces establecería esas dos declaraciones como objetivos, a ser probados uno tras otro.",
 "If the expression `t` is a proof of a statement of the form `P ↔ Q`, then the tactic\n`rewrite [t]` will replace `P` anywhere that it occurs in the goal with `Q`.  If you want to\nreplace `Q` with `P`, use `rewrite [← t]`.  (Type `\\l` to enter the symbol `←`.)  To do the\nreplacement in an assumption `h`, use `rewrite [t] at h`.\n\nThe `rewrite` tactic can also be used with equations.  If `t` is a proof of an equation\n`p = q`, then `rewrite [t]` will replace `p` with `q` wherever it appears, and `rewrite [← t]`\nwill replace `q` with `p`.\n\nTo do multiple replacements, one after another, put a list of proofs inside the brackets, like\nthis:  `rewrite [t1, t2]`.":
 "\"Si la expresión `t` es una prueba de una afirmación de la forma `P ↔ Q`, entonces la táctica\n`rewrite [t]` reemplazará `P` en cualquier lugar donde aparezca en la meta con `Q`. Si deseas\nreemplazar `Q` con `P`, usa `rewrite [← t]`. (Escribe `\\l` para ingresar el símbolo `←`.) Para\nrealizar el reemplazo en una suposición `h`, usa `rewrite [t] at h`.\n\nLa táctica `rewrite` también se puede usar con ecuaciones. Si `t` es una prueba de una ecuación\n`p = q`, entonces `rewrite [t]` reemplazará `p` con `q` dondequiera que aparezca, y `rewrite [← t]`\nreemplazará `q` con `p`.\n\nPara realizar múltiples reemplazos, uno después de otro, coloca una lista de pruebas dentro de los corchetes, así:\n`rewrite [t1, t2]`.\n",
 "If `«{x}» ∈ A`, then the goal is easy to prove.  This suggests breaking\nthe proof into cases depending on whether or not `«{x}» ∈ A`.  You can do this with the tactic\n`by_cases hA : «{x}» ∈ A`.":
 " Si `«{x}» ∈ A`, entonces es fácil probar el objetivo. Esto sugiere dividir la prueba en casos según si `«{x}» ∈ A` o no. Puedes hacerlo con la táctica `by_cases hA : «{x}» ∈ A`.",
 "If `h` is a proof of a statement of the form `P ∨ Q`, then the tactic\n`cases' h with h1 h2` will break your proof into cases.  In case 1, you'll have the new\nassumption `h1 : P`, and in case 2 you'll have `h2 : Q`.  In both cases you have to prove\nthe original goal.\n\nThe `cases'` tactic has other uses.  In particular, it can be applied to proofs of statements\nthat do not have the form `P ∨ Q`.  However, we will not discuss these other uses of the\n`cases'` tactic in this game.":
 " Si `h` es una prueba de un enunciado de la forma `P ∨ Q`, entonces la táctica\n`cases' h with h1 h2` dividirá tu prueba en casos. En el caso 1, tendrás la nueva\nsuposición `h1 : P`, y en el caso 2 tendrás `h2 : Q`. En ambos casos tienes que probar\nel objetivo original.\n\nLa táctica `cases'` tiene otros usos. En particular, puede aplicarse a pruebas de enunciados\nque no tienen la forma `P ∨ Q`. Sin embargo, no discutiremos estos otros usos de la\ntáctica `cases'` en este juego.",
 "If `P` and `Q` are statements, then `P → Q` means \"if P then Q\".\nTo enter the symbol `→`, type `\\imp` (short for \"implies\").\n\nThe most straightforward way to prove a statement of the form `P → Q` is to assume that\n`P` is true and then prove `Q`.  To do that, we'll need a new tactic: `intro`.":
 "\nSi `P` y `Q` son afirmaciones, entonces `P → Q` significa \"si P, entonces Q\".\nPara ingresar el símbolo `→`, escribe `\\imp` (abreviatura de \"implica\").\n\nLa manera más directa de demostrar una afirmación de la forma `P → Q` es asumir que\n`P` es verdadero y luego demostrar `Q`. Para hacer eso, necesitaremos una nueva táctica: `intro`.\n",
 "If `P x` represents a statement about an unspecified object `x`, then `∀ x, P x` means\n\"for all `x`, `P x` is true\".  To enter the symbol `∀`, type `\\forall`.":
 "Si `P x` representa un enunciado sobre un objeto no especificado `x`, entonces `∀ x, P x` significa\n\"para todos los `x`, `P x` es verdadero\". Para ingresar el símbolo `∀`, teclee `\\forall`.",
 "If `P x` represents a statement about `x`, then `∃ x, P x` means \"there is at least one\n`x` such that `P x` is true\".  To enter the symbol `∃`, type `\\exists`.":
 " Si `P x` representa un enunciado sobre `x`, entonces `∃ x, P x` significa \"existe al menos un\n`x` tal que `P x` es verdadero\".  Para ingresar el símbolo `∃`, escribe `\\exists`.",
 "If `P x` represents a statement about `x` and you have `h : P a`, for some object `a`, then\n`Exists.intro a h` is a proof of `∃ x, P x`.":
 " Si `P x` representa un enunciado sobre `x` y tienes `h : P a`, para algún objeto `a`, entonces\n`Exists.intro a h` es una prueba de `∃ x, P x`.",
 "If `F` is a family of sets from `U`, then the *union* of `F` is the set of all objects from\n`U` that belong to at least one element of `F`.  We'll investigate unions of families in this\nworld.":
 " Si `F` es una familia de conjuntos de `U`, entonces la *unión* de `F` es el conjunto de todos los objetos\nde `U` que pertenecen al menos a un elemento de `F`. Investigaremos uniones de familias en este\nmundo.",
 "If `F` and `G` are families of sets, what is `⋂₀ (F ∪ G)`?  In this level, you'll find out!":
 "Si `F` y `G` son familias de conjuntos, ¿qué es `⋂₀ (F ∪ G)`? En este nivel, lo veremos.",
 "If `A` is a set, then `compl_compl A` is a proof of `Aᶜᶜ = A`.":
 "Si `A` es un conjunto, entonces `compl_compl A` es una prueba de `Aᶜᶜ = A`.",
 "If `A` is a set of objects from the universe `U`, then the *complement* of `A`,\ndenoted `Aᶜ`, is the set of all objects in the universe `U` that are *not*\nelements of `A`.\n\nFor example, if `U` consists of all people and `A` is the set of people who are more than\n6 feet tall, then `Aᶜ` is the set of all people who are at most 6 feet tall.\n\nIn this world, we'll see how to prove theorems about complements.":
 "Si `A` es un conjunto de objetos del universo `U`, entonces el *complementario* de `A`,\ndenotado `Aᶜ`, es el conjunto de todos los objetos en el universo `U` que no son\nelementos de `A`.\n\nPor ejemplo, si `U` consiste en todas las personas y `A` es el conjunto de personas que miden más de 2 metros, entonces `Aᶜ` es el conjunto de todas las personas que miden a lo sumo 2 metros.\n\nEn este mundo, veremos cómo probar teoremas sobre complementarios.",
 "If `A` is a set and `F` is a family of sets, under what circumstances is it the case\nthat `A ⊆ ⋂₀ F`?  In this level you'll discover the answer to that question.":
 " Si `A` es un conjunto y `F` es una familia de conjuntos, ¿bajo qué circunstancias es cierto que `A ⊆ ⋂₀ F`? En este nivel descubrirás la respuesta a esa pregunta.",
 "If `A` is a of objects from the universe `U`, then `Aᶜ` is the complement of `A`; that is,\n`Aᶜ` is the set of objects from `U` that are not elements of `A`.  You can enter the symbol `ᶜ`\nby typing `\\compl` or `\\^c`.":
 "Si `A` es un conjunto de objetos del universo `U`, entonces `Aᶜ` es el complementario de `A`;\nes decir, `Aᶜ` es el conjunto de objetos de `U` que no son elementos de `A`. Puedes ingresar el\nsímbolo `ᶜ` escribiendo `\\compl` o `\\^c`.",
 "If `A` and `B` are sets, then we say that `A` is a *subset* of `B` if\nevery element of `A` is also an element of `B`.  The notation `A ⊆ B` means\nthat `A` is a subset of `B`.  (To enter the symbol `⊆`, type `\\sub`,\nfollowed by a space.)\n\nIf you have `h1 : A ⊆ B`, then `h1` is a proof that, if something is an element\nof `A`, then it is also an element of `B`.  Thus, if you also have `h2 : x ∈ A`,\nthen you can apply `h1` to `h2` to conclude that `x ∈ B`.  To apply `h1` to `h2`,\nyou simply write `h1` followed by `h2`, with a space between them.  Thus, in\nthis situation, `h1 h2` is a proof of `x ∈ B`.\n\nSee if you can use this to complete this level.  If you need a hint, click on\n\"Show more help!\".":
 "\nSi `A` and `B` son conjuntos, decimos que `A` es un *subconjunto* de `B` si\ntodo elemento de `A` es también un elemento de `B`. Esto lo denotamos como `A ⊆ B`.\n(Para introducir el símbolo `⊆`, teclea `\\sub`, seguido por un espacio.)\n\nSi tienes `h1 : A ⊆ B`, entonces `h1` is una prueba de que, si algo es un elemento de `A`,\ntambién es un elemento de `B`. Así, si tienes también `h2 : x ∈ A`,\npuedes aplicar `h1` a `h2` para concluir que `x ∈ B`.  Para aplicar `h1` a `h2`,\nsimplemente escribe `h1` seguido de `h2`, con un espacio en medio. Así, en esta situación,\n`h1 h2` es una prueba de `x ∈ B`.\n\nIntenta completar este nivel. Si necesitas ayuda, pulsa en\n\"Show more help!\".\n",
 "If `A` and `B` are sets, then the *union* of `A` and `B`, denoted\n`A ∪ B`, is the set you get by throwing all the elements of `A` and `B`\ntogether into one set.  In other words, for an object to be an element of\n`A ∪ B`, it must be an element of either `A` or `B`, or both.\n\nFor example, if `A` is the set of all people under 30, and `B` is the set of\nall people over 20, then `A ∪ B` is the set of all people.\n\nIn this world you'll prove some basic properties of unions of sets.":
 " Si `A` y `B` son conjuntos, entonces la *unión* de `A` y `B`, denotada\n`A ∪ B`, es el conjunto que se obtiene al poner todos los elementos de `A` y `B`\njuntos en un solo conjunto. En otras palabras, para que un objeto sea un elemento de\n`A ∪ B`, debe ser un elemento de `A` o de `B`, o de ambos.\n\nPor ejemplo, si `A` es el conjunto de todas las personas menores de 30, y `B` es\nel conjunto de todas las personas mayores de 20, entonces `A ∪ B` es el conjunto de\ntodas las personas.\n\nEn este mundo demostrarás algunas propiedades básicas de uniones de conjuntos.",
 "If `A` and `B` are sets, then the *intersection* of `A` and `B`, denoted\n`A ∩ B`, is the set of elements that the two sets have in common.  In other words,\nfor an object to be an element of `A ∩ B`, it must be an element of both `A` and `B`.\n\nFor example, if `A` is the set of all round things, and `B` is the set of all red things,\nthen `A ∩ B` is the set of all round red things.\n\nIn this world you'll prove some basic properties of intersections of sets.":
 " Si `A` y `B` son conjuntos, entonces la *intersección* de `A` y `B`, denotada por\n`A ∩ B`, es el conjunto de elementos que los dos conjuntos tienen en común. En otras palabras,\npara que un objeto sea un elemento de `A ∩ B`, debe ser un elemento tanto de `A` como de `B`.\n\nPor ejemplo, si `A` es el conjunto de todas las cosas redondas y `B` es el conjunto de todas las cosas rojas,\nentonces `A ∩ B` es el conjunto de todas las cosas redondas rojas.\n\nEn este mundo demostrarás algunas propiedades básicas de las intersecciones de conjuntos.",
 "If `A` and `B` are sets, then `A ∪ B` is the union of `A` and `B`.\nTo enter the symbol `∪`, type `\\union`.":
 "Si `A` y `B` son conjuntos, entonces `A ∪ B` es la unión de `A` y `B`.\nPara escribir el símbolo `∪`, teclea `\\union`.",
 "If `A` and `B` are sets, then `A ∩ B` is the intersection of `A` and `B`.\nTo enter the symbol `∩`, type `\\inter` or `\\cap`.":
 "Si `A` y `B` son conjuntos, entonces `A ∩ B` es la intersección de `A` y `B`.\nPara escribir el símbolo `∩`, teclea `\\inter` o `\\cap`.",
 "How do you prove that one set is a subset of another?  To prove that `A ⊆ B`,\nyou have to show that if some object `x` is an element of `A`, then it is also\nan element of `B`.  To do that, you'll have to introduce an object called `x` into\nthe proof.  The object denoted by `x` could be anything, so we say that it is\n*arbitrary*.\n\nIn this level, we start with a simple example of this kind of proof.  We're going\nto show that if `A` is a set, then `A ⊆ A`.":
 "\n¿Cómo demuestras que un conjunto es un subconjunto de otro? Para demostrar que `A ⊆ B`,\ntienes que mostrar que si algún objeto `x` es un elemento de `A`, entonces también lo es\nun elemento de `B`. Para hacer eso, tendrás que introducir un objeto `x` en\nla prueba. Este elemento `x` podría ser cualquiera, así que decimos que es *arbitrario*.\n\nEn este nivel, comenzamos con un ejemplo simple de este tipo de prueba. Vamos a mostrar\nque si `A` es un conjunto, entonces `A ⊆ A`.\n",
 "How do we prove that two sets `A` and `B` are equal?  One way to do it is to use the theorem\n`Subset.antisymm`.  This theorem is pre-defined in this game; you don't need to prove it.\nIf you have `h1 : A ⊆ B` and `h2 : B ⊆ A`, then\n`Subset.antisymm h1 h2` is a proof of `A = B`.  The theorem `Subset.antisymm` says that the\nsubset relation has a property called *antisymmetry*.\n\nBut what if you don't already know `A ⊆ B` and `B ⊆ A`?  In that case, you can use a new\ntactic, `apply`.  If your goal is `A = B` and you write `apply Subset.antisymm`, then Lean will\nfigure out that the theorem `Subset.antisymm` could be applied to prove the goal, if only you had\nproofs of `A ⊆ B` and `B ⊆ A`.  So it will set those *two* statements as goals.\n\nIf your goal says that two sets are equal, a good way to begin is with\n`apply Subset.antisymm`.  (Later we'll see a second approach to proving sets are equal.)\n\nThis level also introduces another new tactic, `push_neg`.":
 "¿Cómo demostramos que dos conjuntos `A` y `B` son iguales? Una manera de hacerlo es utilizar el teorema\n`Subset.antisymm`. Este teorema está predefinido en este juego; no necesitas probarlo.\nSi tienes `h1 : A ⊆ B` y `h2 : B ⊆ A`, entonces\n`Subset.antisymm h1 h2` es una prueba de `A = B`. El teorema `Subset.antisymm` dice que la\nrelación de subset tiene una propiedad llamada *antisimetría*.\n\nPero ¿qué pasa si aún no sabes que `A ⊆ B` y `B ⊆ A`? En ese caso, puedes usar una nueva\ntáctica, `apply`. Si tu objetivo es `A = B` y escribes `apply Subset.antisymm`, entonces Lean\nverá que el teorema `Subset.antisymm` podría aplicarse para probar el objetivo, si tuvieras\npruebas de `A ⊆ B` y `B ⊆ A`. Entonces establecerá esos *dos* enunciados como objetivos a demostrar.\n\nSi tu objetivo dice que dos conjuntos son iguales, una buena manera de empezar es con\n`apply Subset.antisymm`. (Más tarde veremos un segundo enfoque para probar que los conjuntos son iguales.)\n\nEste nivel también introduce otra nueva táctica, `push_neg`.",
 "Here's an idea that you may find helpful for this proof:\nIf you're proving an \"or\" statement and you think you'll be\nable to prove either the left or right side of the statement, then `apply Or.inl` or\n`apply Or.inr` will set the goal to be the left or right side.  Alternatively, the tactic\n`left` has the same effect as `apply Or.inl`, and `right` has the same effect as\n`apply Or.inr`.\n\nYou can start this proof with either `ext x` or `apply Subset.antisymm`.":
 " Aquí tienes una idea que tal vez te sea útil para esta prueba:\nSi estás probando una declaración \"o\" y crees que podrás probar\nel lado izquierdo o derecho de la declaración, entonces `apply Or.inl` o\n`apply Or.inr` establecerá el lado izquierdo o derecho como objetivo. Alternativamente, la táctica\n`left` tiene el mismo efecto que `apply Or.inl`, y `right` tiene el mismo efecto que\n`apply Or.inr`.\n\nPuedes empezar esta prueba con  `ext x` o `apply Subset.antisymm`.",
 "Here's an approach you might try:  If only you had `hFG : «{t}» ∈ F ∪ G`, then\n`«{h1}» «{t}» hFG` would prove the goal.  So if you use the tactic `apply «{h1}» «{t}»`, Lean\nwill figure out that `«{h1}» «{t}»` could be applied to a proof of `«{t}» ∈ F ∪ G` to prove\nthe goal, and it will therefore set `«{t}» ∈ F ∪ G` as your goal.":
 "Este es un enfoque que podrías probar: si tuvieras `hFG : «{t}» ∈ F ∪ G`, entonces `«{h1}» «{t}» hFG` probaría el objetivo. Entonces, si usas la táctica `apply «{h1}» «{t}»`, Lean\nverá que `«{h1}» «{t}»` podría aplicarse a una prueba de `«{t}» ∈ F ∪ G` para probar el objetivo, y por lo tanto establecerá `«{t}» ∈ F ∪ G` como su objetivo.",
 "Here's a theorem about three related families of sets.":
 " Aquí hay un teorema sobre tres familias de conjuntos relacionadas.",
 "Fortunately, we can use the theorem `compl_compl` to prove `Aᶜᶜ = A` and\n`Bᶜᶜ = B`, and those statements should get us from `«{h2}»` to the goal.\nWe have seen in previous levels that the `rewrite` tactic can be applied to a proof of a\nstatement of the form `P ↔ Q` to replace `P` with `Q`.  The tactic can also be applied to\nequations: if `t` is a proof of an equation `p = q`, then `rewrite [t]` will\nreplace `p` with `q`.":
 "Por suerte, podemos usar el teorema `compl_compl` para probar `Aᶜᶜ = A` y `Bᶜᶜ = B`, y esos enunciados deberían llevarnos desde `«{h2}»` hasta el objetivo.\nHemos visto en niveles anteriores que la `táctica rewrite` puede aplicarse a una prueba de un enunciado de la forma `P ↔ Q` para reemplazar `P` con `Q`. La táctica también puede aplicarse a ecuaciones: si `t` es una prueba de una ecuación `p = q`, entonces `rewrite [t]` reemplazará `p` por `q`.",
 "Fortunately, the theorem `compl_subset_compl_of_subset` can now be used to prove the goal.\n(Click on `compl_subset_compl_of_subset` in the list of theorems on the right if you don't\nremember what the theorem says.)":
 "Por suerte, el teorema `compl_subset_compl_of_subset` puede usarse ahora para probar el objetivo.\n(Haz click en `compl_subset_compl_of_subset` en la lista de teoremas a la derecha si no recuerdas\nqué dice el teorema.)",
 "For working with unions, the important logical word is \"or\".\n\nIf `P` and `Q` are statements, then `P ∨ Q` means \"P or Q or both\".  To enter the\nsymbol `∨`, type `\\or`.  For the statement `P ∨ Q` to be true, either `P` or `Q` must\nbe true.  This gives us two ways to prove a statement of this form.  If you have\n`h : P`, then `Or.inl h` can be used to prove `P ∨ Q`.  If you have `h : Q`, then\n`Or.inr h` proves `P ∨ Q`.":
 " Para trabajar con uniones, la palabra lógica importante es \"o\".\n\nSi `P` y `Q` son enunciados, entonces `P ∨ Q` significa \"P o Q o ambos\".  Para escribir el símbolo `∨`, teclea `\\or`.  Para que la declaración `P ∨ Q` sea verdadera, se debe cumplir al menos una de las siguientes condiciones: `P` o `Q`.  Esto nos da dos maneras de probar un enunciado de esta forma.  Si tienes `h : P`, entonces `Or.inl h` puede utilizarse para probar `P ∨ Q`.  Si tienes `h : Q`, entonces `Or.inr h` demuestra `P ∨ Q`.",
 "For the theorem in this level, your goal is `¬A ⊆ B`.  To use proof by contradiction\nin this proof, you must begin by introducing the assumption `h3 : A ⊆ B`.  To do that, type\n`by_contra h3`":
 "Para el teorema en este nivel, tu objetivo es `¬A ⊆ B`. Para utilizar la prueba por contradicción\n  en esta demostración, debes comenzar introduciendo la suposición `h3 : A ⊆ B`. Para hacerlo, escribe\n  `by_contra h3`.",
 "For the second case, which half of the goal do you think you should try to prove?\nYou can use `apply Or.inl` or `apply Or.inr` (or the equivalent tactics `left` or `right`)\nto specify what goal you're going to prove.":
 " Para el segundo caso, ¿qué mitad del objetivo crees que deberías intentar probar?\nPuedes usar `apply Or.inl` o `apply Or.inr` (o las tácticas equivalentes `left` o `right`)\npara especificar qué objetivo vas a probar.",
 "For the proof in this level, `apply Iff.intro` will create the goals `A ⊆ B → Bᶜ ⊆ Aᶜ`\nand `Bᶜ ⊆ Aᶜ → A ⊆ B`.":
 "Para la prueba en este nivel, `apply Iff.intro` creará los objetivos `A ⊆ B → Bᶜ ⊆ Aᶜ` y `Bᶜ ⊆ Aᶜ → A ⊆ B`.",
 "For any sets `A`, `B`, and `C`, `union_distrib_left A B C` is a proof of the\nstatement `A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)`.  In Mathlib, the name of this theorem\nis `Set.union_distrib_left`.":
 "Para cualesquiera conjuntos `A`, `B` y `C`, `union_distrib_left A B C` es una prueba del enunciado `A ∪ (B ∩ C) = (A ∪ B) ∩ (A ∪ C)`. En Mathlib, el nombre de este teorema es `Set.union_distrib_left`.",
 "For any sets `A`, `B`, and `C`, `union_assoc A B C` is a proof of the\nstatement `(A ∪ B) ∪ C = A ∪ (B ∪ C)`.  In Mathlib, the name of this theorem is `Set.union_assoc`.":
 " Para cualesquiera conjuntos `A`, `B` y `C`, `union_assoc A B C` es una prueba del enunciado `(A ∪ B) ∪ C = A ∪ (B ∪ C)`. En Mathlib, el nombre de este teorema es `Set.union_assoc`.",
 "For any sets `A`, `B`, and `C`, `inter_distrib_left A B C` is a proof of the\nstatement `A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)`.  In Mathlib, the name of this theorem\nis `Set.inter_distrib_left`.":
 "Para cualesquiera conjuntos `A`, `B` y `C`, `inter_distrib_left A B C` es una prueba de `A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)`. En Mathlib, el nombre de este teorema es `Set.inter_distrib_left`.",
 "For any sets `A`, `B`, and `C`, `inter_assoc A B C` is a proof of the\nstatement `(A ∩ B) ∩ C = A ∩ (B ∩ C)`.  Im Mathlib, the name of this theorem is `Set.inter_assoc`.":
 "Para cualesquiera conjuntos `A`, `B` y `C`, `inter_assoc A B C` es una prueba de `(A ∩ B) ∩ C = A ∩ (B ∩ C)`. En Mathlib, el nombre de este teorema es `Set.inter_assoc`.",
 "For any sets `A` and `B`, `union_sub_swap A B` is a proof of\n`A ∪ B ⊆ B ∪ A`.":
 " Para cualesquiera conjuntos `A` y `B`, `union_sub_swap A B` es una prueba de\n`A ∪ B ⊆ B ∪ A`.",
 "For any sets `A` and `B`, `union_comm A B` is a proof of the\nstatement `A ∪ B = B ∪ A`.  In Mathlib, the name of this theorem is `Set.union_comm`.":
 " Para cualesquiera conjuntos `A` y `B`, `union_comm A B` es una prueba de\n`A ∪ B = B ∪ A`. En Mathlib, el nombre de este teorema es `Set.union_comm`.",
 "For any sets `A` and `B`, `inter_subset_swap A B` is a proof of\n`A ∩ B ⊆ B ∩ A`.":
 "Para cualesquiera conjuntos `A` y `B`, `inter_subset_swap A B` es una prueba de\n`A ∩ B ⊆ B ∩ A`.",
 "For any sets `A` and `B`, `inter_comm A B` is a proof of the\nstatement `A ∩ B = B ∩ A`.  In Mathlib, the name of this theorem is `Set.inter_comm`.":
 "Para cualesquiera conjuntos `A` y `B`, `inter_comm A B` es una prueba de\n`A ∩ B = B ∩ A`. En Mathlib, el nombre de este teorema es  `Set.inter_comm`.",
 "For any sets `A` and `B`, `compl_union A B` is a proof of the\nstatement `(A ∪ B)ᶜ = Aᶜ ∩ Bᶜ`.  In Mathlib, the name of this theorem is `Set.compl_union`.":
 " Para cualesquiera conjuntos `A` y `B`, `compl_union A B` es una prueba de\n `(A ∪ B)ᶜ = Aᶜ ∩ Bᶜ`. En Mathlib, el nombre de este teorema es `Set.compl_union`.",
 "For any sets `A` and `B`, `compl_inter A B` is a proof of the\nstatement `(A ∩ B)ᶜ = Aᶜ ∪ Bᶜ`.  In Mathlib, the name of this theorem is `Set.compl_inter`.":
 "Para cualesquiera conjuntos `A` y `B`, `compl_inter A B` es una prueba del enunciado `(A ∩ B)ᶜ = Aᶜ ∪ Bᶜ`.  En Mathlib, el nombre de este teorema es `Set.compl_inter`.",
 "For any sets $A$, $B$, and $C$, $A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)$.":
 "Dados tres conjuntos $A$, $B$, y $C$, $A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)$.",
 "For any sets $A$, $B$, and $C$, $A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C)$.":
 "Para cualesquiera conjuntos `A`, `B`, y `C`, `A ∩ (B ∪ C) = (A ∩ B) ∪ (A ∩ C)`.",
 "For any sets $A$, $B$, and $C$, $(A \\cup B) \\cup C = A \\cup (B \\cup C)$.":
 " Para cualesquiera conjuntos $A$, $B$ y $C$, $(A \\cup B) \\cup C = A \\cup (B \\cup C)$.",
 "For any sets $A$, $B$, and $C$, $(A \\cap B) \\cap C = A \\cap (B \\cap C)$.":
 " Para cualesquiera conjuntos $A$, $B$ y $C$, $(A \\cap B) \\cap C = A \\cap (B \\cap C)$.",
 "For any sets $A$ and $B$, $A \\cup B \\subseteq B \\cup A$.":
 " Para cualesquiera conjuntos `A` y `B`, `A ∪ B ⊆ B ∪ A`.",
 "For any sets $A$ and $B$, $A \\cup B = B \\cup A$.":
 " Para cualesquiera conjuntos `A` y `B`, `A ∪ B = B ∪ A`.",
 "For any sets $A$ and $B$, $A \\cap B \\subseteq B \\cap A$.":
 "Para cualesquiera conjuntos `$A$` y `$B$`, `$A \\cap B \\subseteq B \\cap A$`.",
 "For any sets $A$ and $B$, $A \\cap B \\subseteq A$.":
 " Para cualesquiera conjuntos `A` y `B`, `A ∩ B ⊆ A`.",
 "For any sets $A$ and $B$, $A \\cap B = B \\cap A$.":
 "Para cualesquiera conjuntos `A` y `B`, `A ∩ B = B ∩ A`.",
 "For any sets $A$ and $B$, $(A \\cup B)^c = A^c \\cap B^c$.":
 " Para cualesquiera conjuntos $A$ y $B$, $(A \\cup B)^c = A^c \\cap B^c$.",
 "For any sets $A$ and $B$, $(A \\cap B)^c = A^c \\cup B^c$.":
 "Para cualesquiera conjuntos $A$ y $B$, $(A \\cap B)^c = A^c \\cup B^c$.",
 "For any family of sets $F$, $(\\bigcup F)^c = \\bigcap \\{s \\mid s^c \\in F\\}$.":
 " Para cualquier familia de conjuntos $F$, $(\\bigcup F)^c = \\bigcap \\{s \\mid s^c \\in F\\}$.",
 "For any family of sets $F$, $(\\bigcap F)^c = \\bigcup \\{s \\mid s^c \\in F\\}$.":
 " Para cualquier familia de conjuntos $F$, $( \\bigcap F )^c = \\bigcup \\{s \\mid s^c \\in F\\}$.",
 "For any `t`, `A`, and `B`, `mem_pair t A B` is a proof of the statement\n`t ∈ {A, B} ↔ t = A ∨ t = B`.":
 " Para cualquier `t`, `A`, y `B`, `mem_pair t A B` es una prueba del enunciado\n`t ∈ {A, B} ↔ t = A ∨ t = B`.",
 "First use `have` to assert that `«{x}» ∈ B`, and\nthen prove `«{x}» ∈ C`.":
 "Usa `have` para afirmar que `«{x}» ∈ B`, y después demuestra `«{x}» ∈ C`.",
 "Family intersection is subset":
 "La intersección de una familia es un subconjunto",
 "Family Union World": "Mundo de la unión de familias",
 "Family Intersection World": "Mundo de las intersecciones de familias",
 "Family Combination World": "Mundo combinado de familias.",
 "Element of an intersection": "Elementos de una intersección",
 "Does your situation now remind you of a previous level?":
 "¿Te recuerda esta situación al nivel anterior?",
 "Do you see why `«{s}»` is the value to use as a witness for `t` in the goal?\nYour next step can be either `apply Exists.intro «{s}»` or `use «{s}»`.":
 " ¿Ves por qué `«{s}»` es el valor que se debe usar como testigo para `t` en el objetivo?\nTu siguiente paso puede ser `apply Exists.intro «{s}»` o `use «{s}»`.",
 "Do you see how you can now use the theorem from the previous level?":
 " ¿Ves cómo ahora puedes usar el teorema del nivel anterior?",
 "Do you know which half of the goal you're going to prove now?":
 " ¿Sabes qué mitad del objetivo vas a probar ahora?",
 "Definition of complement": "Definición de complementario",
 "Congratulations! You have completed your first verified proof!\n\nAlthough this theorem was trivial, it illustrates an important fact: although we\ncalled `h` an *identifier* for the assumption `x ∈ A`, it is also recognized by Lean\nas a *proof* of the statement `x ∈ A`.  Any time you see `h : P`\nlisted as an assumption, where `P` is some statement, that means that Lean will\nrecognize `h` as a proof of the statement `P`.\n\nRemember that `exact` is a *tactic*. If you ever want information about the `exact` tactic,\nyou can click on `exact` in the list of tactics on the right.\n\nNote that, although `h` was a proof of the goal `x ∈ A`, you could not have closed the goal by\nsimply typing `h` in the text box.  Throughout this game, every move you make must invoke a tactic.\n\nNow click on \"Next\" to see a more interesting use of the `exact` tactic.":
 "\n¡Enhorabuena! Has completado tu primera demostración.\n\nAunque este teorema era trivial, ilustra un hecho importante:\naunque llamamos a `h` un *identificador* para la suposición `x ∈ A`,\ntambién es reconocido por Lean como una *prueba* de la afirmación `x ∈ A`.\nCada vez que veas `h : P` enumerado como una suposición, donde `P` es alguna afirmación,\neso significa que Lean reconocerá `h` como una prueba de la afirmación `P`.\n\nRecuerda que `exact` es una *táctica*. Si alguna vez quieres obtener información sobre la táctica `exact`,\npuedes pulsar en `exact` en la lista de tácticas a la derecha.\n\nAhora pulsa en \"Next\" para ver un uso más interesante de la táctica `exact`.\n",
 "Congratulations!  You have completed the Set Theory Game!\n\nIf you want to learn more about Lean, check out the [Lean Community](https://leanprover-community.github.io).":
 " Enhorabuena! Has completado el Juego de Teoría de Conjuntos.\n\nSi quieres aprender más sobre Lean, visita la [Comunidad Lean](https://leanprover-community.github.io).",
 "Complement subsets from subsets": "Conjuntos complementaros de subconjuntos",
 "Complement subsets equivalence":
 "Equivalencia de contenido de complementarios",
 "Complement of an intersection": "Complementario de una intersección",
 "Complement of a union": "Complementario de una unión",
 "Complement of a family union": "Complementario de la unión de una familia",
 "Complement of a family intersection":
 "Complementario de la intersección de una familia",
 "Complement of a complement": "Complementario de un complementario",
 "Complement World": "Mundo de los complementarios",
 "Combination World": "Mundo combinado",
 "By the way, another set that would have worked as a witness for the existential goal in this\ntheorem is the empty set, denoted `∅`.  However, to justify the use of that witness you would\nhave had to prove `∅ ⊆ A`.  Since we already have the theorem `Subset.refl`, it was easier to use\n`A` as the witness.\n\nNow that you know how to prove existential statements, you're ready to start working with\nunions of families.":
 " Por cierto, otro conjunto que habría funcionado como testigo para el objetivo existencial en este\nteorema es el conjunto vacío, denotado `∅`. Sin embargo, para justificar el uso de ese testigo\nhabrías tenido que probar `∅ ⊆ A`. Dado que ya tenemos el teorema `Subset.refl`, fue más fácil\nusar `A` como testigo.\n\nAhora que sabes cómo probar enunciados existenciales, estás listo para comenzar a trabajar con\nuniones de familias.",
 "As you saw in the previous level, you can now apply `h1` to `«{h3}»`\nto justify asserting `x ∈ B`, using the `have` tactic.":
 "Como vimos en el nivel anterior, puedes aplicar `h1` a `«{h3}»`\npara justificar que `x ∈ B`, usando la táctica `have`.",
 "As with complements and intersections, one of the key tools for proving theorems about unions\nis a theorem stating the definition.  If you have `x : U`, `A : Set U`, and `B : Set U`,\nthen `mem_union x A B` is a proof of the statement `x ∈ A ∪ B ↔ x ∈ A ∨ x ∈ B`.\nThat means you can use `rewrite [mem_union]` to write out the definition of\n`x ∈ A ∪ B` if it appears in any assumption or the goal.  (The similar theorem about intersections\nwas called `mem_inter_iff`.  Why isn't this one called `mem_union_iff`?  I don't know.  The\nnaming of theorems in Lean is systematic, but there are occasional surprises.)":
 "Como con los complementarios e intersecciones, una de las herramientas clave para probar los teoremas sobre uniones\nes un teorema que establece la definición. Si tienes `x : U`, `A : Set U` y `B : Set U`,\nentonces `mem_union x A B` es una prueba del enunciado `x ∈ A ∪ B ↔ x ∈ A ∨ x ∈ B`.\nEso significa que puedes usar `rewrite [mem_union]` para escribir la definición de\n`x ∈ A ∪ B` si aparece en alguna suposición o el objetivo. (El teorema similar sobre intersecciones\nse llamaba `mem_inter_iff`. ¿Por qué no se llama a este `mem_union_iff`? No lo sé. La denominación de los teoremas en Lean es sistemática, pero de  vez en cuando hay sorpresas.)",
 "As we saw in the last level, `h2 «{h4}»` is now\na proof of the goal, so `exact h2 «{h4}»` will close the goal.":
 "Como vimos en el anterior nivel, `h2 {h4}` es ahora una prueba\n  del objetivo, así que `exact h2 {h4}` cerrará el objetivo.",
 "As we saw in Complement World, a good first step when your goal is an equation between\nsets is `apply Subset.antisymm`.  For the theorem in this level, that will leave you with\ntwo goals: `A ∩ B ⊆ B ∩ A` and `B ∩ A ⊆ A ∩ B`.  Fortunately, you can prove *both* of these\ngoals by using the theorem `inter_subset_swap` from the last level.":
 " Como vimos en el Mundo de los complementarios, un buen primer paso cuando tu objetivo es una igualdad entre conjuntos es `apply Subset.antisymm`.  Para el teorema en este nivel, eso te dejará con dos objetivos: `A ∩ B ⊆ B ∩ A` y `B ∩ A ⊆ A ∩ B`.  Afortunadamente, puedes probar *ambos* estos enunciados utilizando el teorema `inter_subset_swap` del último nivel.",
 "As usual, you may find it helpful to use the `rewrite` tactic to write out the\ndefinition of `«{x}» ∈ ⋂₀ F`, using the theorem `mem_sInter`.":
 "Como de costumbre, puede que resultar útil utilizar la táctica `rewrite` para escribir la definición de `«{x}» ∈ ⋂₀ F`, utilizando el teorema `mem_sInter`.",
 "As usual, to prove a subset statement you need to introduce both a new object `x` and\na new assumption `h2`.  You can do it in one step with `intro x h2`.":
 "Como de costumbre, para demostrar un contenido, necesitas introducir un nuevo objeto `x` y\n  una nueva suposición `h2`.  Puedes hacerlo de golpe con `intro x h2`.",
 "As usual, if you're not sure how to proceed then writing\nout definitions can help.":
 "Como de costumbre, si no sabes cómo seguir; escribir las definiciones puede ser útil.",
 "And": "Y",
 "Although `∅` is a reasonable choice for a set that is a subset of `A`, it is difficult\nto complete the proof with this choice using only methods developed so far in this game.\nGo back and try a different choice.":
 " A pesar de que `∅` es una opción razonable para un conjunto que es subconjunto de `A`, es difícil completar la prueba con esta elección usando solo los métodos desarrollados hasta ahora en este juego. Vuelve atrás e intenta una elección diferente.",
 "Again, work out the consequences of `«{h1}»` first.":
 " En primer lugar, trabaja en las consecuencias de `«{h1}»`.",
 "A union intersected with the complement of another is a subset":
 " Una unión intersecada con el complemento de otra es un subconjunto.",
 "A union intersected with the complement of an intersection":
 " Una unión intersecada con el complemento de una intersección.",
 "A tricky subset proof": "Una prueba más difícil",
 "A theorem about three families": "Un teorema sobre tres familias",
 "A subset of a union intersected with the complement of another":
 " Un subconjunto de la unión intersecada con el complemento de otra",
 "A subset hypothesis": "Una hipótesis sobre subconjuntos",
 "A set that must be a singleton":
 " Un conjunto que debe ser un elemento único",
 "A game about set theory.": " Un juego sobre la teoría de conjuntos.",
 "*Game version: 4.4*\n\n## Progress saving\n\nThe game stores your progress in your local browser storage.\nIf you delete it, your progress will be lost!\n\nWarning: In most browsers, deleting cookies will also clear the local storage\n(or \"local site data\"). Make sure to download your game progress first!\n\n## Credits\n\n* **Creator:** Daniel J. Velleman; based on the Natural Numbers Game, by Kevin Buzzard\n* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n\n## Resources\n\n* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\n\n## Problems?\n\nPlease ask any questions about this game in the\n[Lean Zulip chat](https://leanprover.zulipchat.com/) forum, for example in\nthe stream \"New Members\". The community will happily help. Note that\nthe Lean Zulip chat is a professional research forum.\nPlease use your full real name there, stay on topic, and be nice. If you're\nlooking for somewhere less formal (e.g. you want to post set theory\ngame memes) then head on over to the [Lean Discord](https://discord.gg/WZ9bs9UCvx).\n\nAlternatively, if you experience issues / bugs you can also open github issues:\n\n* For issues with the game engine, please open an\n[issue at the lean4game repo](https://github.com/leanprover-community/lean4game/issues).\n* For issues about the game's content, please open an\n[issue at the STG repo](https://github.com/djvelleman/STG4/issues).":
 "*Versión del juego: 4.4*## Almacenamiento de progreso El juego almacena tu progreso en el almacenamiento local de tu navegador.Si lo eliminas, perderás tu progreso!Atención: En la mayoría de los navegadores, eliminar las cookies también limpiará el almacenamiento local (o \"datos del sitio local\"). Asegúrese de descargar su progreso en el juego primero!## Créditos* **Creador:** Daniel J. Velleman; basado en el Juego de números naturales, por Kevin Buzzard* **Motor del juego:** Alexander Bentkamp, Jon Eugster, Patrick Massot## Recursos* El [Lean Zulip chat](https://leanprover.zulipchat.com/) foro## Problemas?Por favor, pregunte cualquier duda sobre este juego en el[Lean Zulip chat](https://leanprover.zulipchat.com/) foro, por ejemplo en el flujo \"Miembros nuevos\". La comunidad estará encantada de ayudar. Note que el Lean Zulip chat es un foro de investigación profesional.Por favor, use su nombre completo y real allí, céntrese en el tema y sea amable. Si está buscando un lugar menos formal (por ejemplo, desea publicar memes del juego de la teoría de conjuntos)entonces diríjase al [Lean Discord](https://discord.gg/WZ9bs9UCvx).Alternativamente, si experimenta problemas / errores puede abrir issues en github:* Para problemas con el motor del juego, por favor abra un[issue en el repo de lean4game](https://github.com/leanprover-community/lean4game/issues).* Para problemas sobre el contenido del juego, por favor abra un[issue en el repo STG](https://github.com/djvelleman/STG4/issues).",
 "# Welcome to the Set Theory Game\n#### An introduction to mathematical proof.\n\nIn this game, you will solve a sequence of levels by proving theorems.  The game\nis based on an interactive theorem prover called *Lean*.\n\nThe theorems in this game will be about sets.\nA *set* is a collection of objects; the objects in the collection are\ncalled *elements* of the set.  For example, the set of planets in our\nsolar system has eight elements:\nMercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and Neptune.\n\n# Read this.\n\nLearning how to use an interactive theorem prover takes time.\nYou will get the most out of this game if you\nread the help texts like this one.\n\nTo start, click on \"Subset World\".\n\n## More\n\nOpen \"Game Info\" in the \"≡\" menu on the top right for resources,\nlinks, and ways to interact with the Lean community.":
 " # Bienvenido al Juego de Teoría de Conjuntos\n#### Una introducción a la prueba matemática.\n\nEn este juego, resolverás una secuencia de niveles demostrando teoremas. El juego se basa en un verificador de teoremas interactivo llamado *Lean*.\n\nLos teoremas de este juego serán sobre conjuntos. Un *conjunto* es una colección de objetos; los objetos en la colección se denominan *elementos* del conjunto. Por ejemplo, el conjunto de planetas en nuestro sistema solar tiene ocho elementos:\nMercurio, Venus, Tierra, Marte, Júpiter, Saturno, Urano y Neptuno.\n\n# Importante.\n\nAprender a usar un verificador de teoremas interactivo toma tiempo. Obtendrás el máximo beneficio de este juego si lees los textos de ayuda como este.\n\nPara comenzar, haga clic en \"Subset World\".\n\n## Más\n\nAbra \"Información del juego\" en el menú \"≡\" en la esquina superior derecha para recursos, enlaces y formas de interactuar con la comunidad de Lean.",
 "# Read this first\n\nEach level in this game involves proving a mathematical statement (the \"Goal\").\nWhen you give a proof of this statement that\nis accepted by Lean, we say that you have *closed* the goal.\n\nIn this first level you're going to prove that if `x` belongs to the universe `U`,\n`A` is a set of objects from `U`, and `x ∈ A`, then `x ∈ A`.  You should see\n`U : Type`, `x : U`, and `A : Set U` under *Objects* in the pane to the right, and\n`h : x ∈ A` under *Assumptions*.  The letter `h` here is called an *identifier*\nfor the assumption `x ∈ A`.\n\nYou will prove goals in Lean using *tactics*.  The first tactic you're\ngoing to learn is called `exact`, and it is used to close the goal.\nYou can close the goal by typing `exact` followed by a proof of the goal.":
 "\n# Empieza leyendo esto\n\nCada nivel en este juego implica demostrar una afirmación matemática (el \\\"Objetivo\\\").\nCuando presentas una prueba de esta afirmación que\nes aceptada por Lean, decimos que has *cerrado* el objetivo.\n\nEn este primer nivel, vas a demostrar que si `x` pertenece al universo `U`,\n`A` es un conjunto de objetos de `U`, y `x ∈ A`, entonces `x ∈ A`. Deberías ver\n`U : Type`, `x : U`, y `A : Set U` bajo *Objects* en el panel a la derecha, y\n`h : x ∈ A` bajo *Assumptions*. La letra `h` aquí se llama un *identificador*\npara la suposición `x ∈ A`.\n\nVas a demostrar objetivos en Lean utilizando *tácticas*. La primera táctica que vas\na aprender se llama `exact`, y se utiliza para cerrar el objetivo.\nPuedes cerrar el objetivo escribiendo `exact` seguido de una prueba del objetivo.\n"}