# SPDX-FileCopyrightText: 2024 Miguel Angel Marco Buzunariz <mmarco@unizar.es>
# mmarco <mmarco@unizar.es>, 2024.
msgid ""
msgstr ""
"Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Apr 10 17:24:48 2024\n"
"PO-Revision-Date: 2024-05-30 18:22+0200\n"
"Last-Translator: Miguel Angel Marco Buzunariz <mmarco@unizar.es>\n"
"Language-Team: Spanish <kde-i18n-doc@kde.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Lokalize 24.02.2\n"

#: GameServer.RpcHandlers
msgid "level completed! ğŸ‰"
msgstr "Â¡Nivel completado!"

#: GameServer.RpcHandlers
msgid "level completed with warningsâ€¦ ğŸ­"
msgstr "Nivel completado con advertencias... ğŸ­"

#: GameServer.RpcHandlers
msgid "intermediate goal solved! ğŸ‰"
msgstr "Â¡objetivo intermedio resuelto! ğŸ‰"

#: Game.Levels.Subset.L01exact
msgid "The exact tactic"
msgstr "La tÃ¡ctica exact"

#: Game.Levels.Subset.L01exact
msgid ""
"# Read this first\n"
"\n"
"Each level in this game involves proving a mathematical statement (the"
" \"Goal\").\n"
"When you give a proof of this statement that\n"
"is accepted by Lean, we say that you have *closed* the goal.\n"
"\n"
"In this first level you're going to prove that if `x` belongs to the universe"
" `U`,\n"
"`A` is a set of objects from `U`, and `x âˆˆ A`, then `x âˆˆ A`.  You should see\n"
"`U : Type`, `x : U`, and `A : Set U` under *Objects* in the pane to the"
" right, and\n"
"`h : x âˆˆ A` under *Assumptions*.  The letter `h` here is called an"
" *identifier*\n"
"for the assumption `x âˆˆ A`.\n"
"\n"
"You will prove goals in Lean using *tactics*.  The first tactic you're\n"
"going to learn is called `exact`, and it is used to close the goal.\n"
"You can close the goal by typing `exact` followed by a proof of the goal."
msgstr ""
"\n"
"# Empieza leyendo esto\n"
"\n"
"Cada nivel en este juego implica demostrar una afirmaciÃ³n matemÃ¡tica (el"
" \\\"Objetivo\\\").\n"
"Cuando presentas una prueba de esta afirmaciÃ³n que\n"
"es aceptada por Lean, decimos que has *cerrado* el objetivo.\n"
"\n"
"En este primer nivel, vas a demostrar que si `x` pertenece al universo `U`,\n"
"`A` es un conjunto de objetos de `U`, y `x âˆˆ A`, entonces `x âˆˆ A`. DeberÃ­as"
" ver\n"
"`U : Type`, `x : U`, y `A : Set U` bajo *Objects* en el panel a la derecha,"
" y\n"
"`h : x âˆˆ A` bajo *Assumptions*. La letra `h` aquÃ­ se llama un"
" *identificador*\n"
"para la suposiciÃ³n `x âˆˆ A`.\n"
"\n"
"Vas a demostrar objetivos en Lean utilizando *tÃ¡cticas*. La primera tÃ¡ctica"
" que vas\n"
"a aprender se llama `exact`, y se utiliza para cerrar el objetivo.\n"
"Puedes cerrar el objetivo escribiendo `exact` seguido de una prueba del"
" objetivo.\n"

#: Game.Levels.Subset.L01exact
msgid ""
"Use `exact` to close a goal.  If some expression `t` is a proof of\n"
"the goal, then `exact t` will close the goal.\n"
"\n"
"Think of \"exact\" as meaning \"this is exactly what is needed to prove the"
" goal.\""
msgstr ""
"\n"
"Utiliza `exact` para cerrar un objetivo. Si alguna expresiÃ³n `t` es una"
" prueba del\n"
"objetivo, entonces `exact t` cerrarÃ¡ el objetivo.\n"
"\n"
"Puedes pensar que \"exact\" significa\n"
"\"esto es exactamente lo que se necesita para demostrar el objetivo.\""

#: Game.Levels.Subset.L01exact
msgid ""
"`x âˆˆ A` means that `x` is an element of `A`.  To enter the symbol `âˆˆ`, type\n"
"`\\mem` or `\\in`."
msgstr ""
"`x âˆˆ A` significa que `x` es un elemento de `A`.  Para introducir el sÃ­mbolo"
" `âˆˆ`, teclea\n"
"`\\mem` or `\\in` seguido de un espacio."

#: Game.Levels.Subset.L01exact
msgid ""
"Let $x$ be an object in the universe $U$, and let $A$ be a set whose"
" elements\n"
"come from $U$.  Suppose that $x âˆˆ A$.  Then $x \\in A$."
msgstr ""
"Sea $x$ un objeto en el universo $U$, y sea $A$ un conjunto cuyos elementos"
" proceden de\n"
"$U$.  SupÃ³n que $x âˆˆ A$.  Entonces $x \\in A$."

#: Game.Levels.Subset.L01exact
msgid ""
"In order to complete this proof, type `exact h` in the text box\n"
"under the goal and click on \"Execute\" or hit the \"Return\" or \"Enter\""
" key."
msgstr ""
"Para completar esta prueba, teclea `exact h` en la caja de texto bajo el"
" objetivo\n"
"  y haz click en  \"Execute\" o pulsa le tecla \"Return\" o \"Enter\"."

#: Game.Levels.Subset.L01exact
msgid ""
"Congratulations! You have completed your first verified proof!\n"
"\n"
"Although this theorem was trivial, it illustrates an important fact: although"
" we\n"
"called `h` an *identifier* for the assumption `x âˆˆ A`, it is also recognized"
" by Lean\n"
"as a *proof* of the statement `x âˆˆ A`.  Any time you see `h : P`\n"
"listed as an assumption, where `P` is some statement, that means that Lean"
" will\n"
"recognize `h` as a proof of the statement `P`.\n"
"\n"
"Remember that `exact` is a *tactic*. If you ever want information about the"
" `exact` tactic,\n"
"you can click on `exact` in the list of tactics on the right.\n"
"\n"
"Note that, although `h` was a proof of the goal `x âˆˆ A`, you could not have"
" closed the goal by\n"
"simply typing `h` in the text box.  Throughout this game, every move you make"
" must invoke a tactic.\n"
"\n"
"Now click on \"Next\" to see a more interesting use of the `exact` tactic."
msgstr ""
"\n"
"Â¡Enhorabuena! Has completado tu primera demostraciÃ³n.\n"
"\n"
"Aunque este teorema era trivial, ilustra un hecho importante:\n"
"aunque llamamos a `h` un *identificador* para la suposiciÃ³n `x âˆˆ A`,\n"
"tambiÃ©n es reconocido por Lean como una *prueba* de la afirmaciÃ³n `x âˆˆ A`.\n"
"Cada vez que veas `h : P` enumerado como una suposiciÃ³n, donde `P` es alguna"
" afirmaciÃ³n,\n"
"eso significa que Lean reconocerÃ¡ `h` como una prueba de la afirmaciÃ³n `P`.\n"
"\n"
"Recuerda que `exact` es una *tÃ¡ctica*. Si alguna vez quieres obtener"
" informaciÃ³n sobre la tÃ¡ctica `exact`,\n"
"puedes pulsar en `exact` en la lista de tÃ¡cticas a la derecha.\n"
"\n"
"Ahora pulsa en \"Next\" para ver un uso mÃ¡s interesante de la tÃ¡ctica"
" `exact`.\n"

#: Game.Levels.Subset.L02subhyp
msgid "A subset hypothesis"
msgstr "Una hipÃ³tesis sobre subconjuntos"

#: Game.Levels.Subset.L02subhyp
msgid ""
"If `A` and `B` are sets, then we say that `A` is a *subset* of `B` if\n"
"every element of `A` is also an element of `B`.  The notation `A âŠ† B` means\n"
"that `A` is a subset of `B`.  (To enter the symbol `âŠ†`, type `\\sub`,\n"
"followed by a space.)\n"
"\n"
"If you have `h1 : A âŠ† B`, then `h1` is a proof that, if something is an"
" element\n"
"of `A`, then it is also an element of `B`.  Thus, if you also have `h2 : x âˆˆ"
" A`,\n"
"then you can apply `h1` to `h2` to conclude that `x âˆˆ B`.  To apply `h1` to"
" `h2`,\n"
"you simply write `h1` followed by `h2`, with a space between them.  Thus, in\n"
"this situation, `h1 h2` is a proof of `x âˆˆ B`.\n"
"\n"
"See if you can use this to complete this level.  If you need a hint, click"
" on\n"
"\"Show more help!\"."
msgstr ""
"\n"
"Si `A` and `B` son conjuntos, decimos que `A` es un *subconjunto* de `B` si\n"
"todo elemento de `A` es tambiÃ©n un elemento de `B`. Esto lo denotamos como `A"
" âŠ† B`.\n"
"(Para introducir el sÃ­mbolo `âŠ†`, teclea `\\sub`, seguido por un espacio.)\n"
"\n"
"Si tienes `h1 : A âŠ† B`, entonces `h1` is una prueba de que, si algo es un"
" elemento de `A`,\n"
"tambiÃ©n es un elemento de `B`. AsÃ­, si tienes tambiÃ©n `h2 : x âˆˆ A`,\n"
"puedes aplicar `h1` a `h2` para concluir que `x âˆˆ B`.  Para aplicar `h1` a"
" `h2`,\n"
"simplemente escribe `h1` seguido de `h2`, con un espacio en medio. AsÃ­, en"
" esta situaciÃ³n,\n"
"`h1 h2` es una prueba de `x âˆˆ B`.\n"
"\n"
"Intenta completar este nivel. Si necesitas ayuda, pulsa en\n"
"\"Show more help!\".\n"

#: Game.Levels.Subset.L02subhyp
msgid ""
"`A âŠ† B` means that `A` is a subset of `B`.  To enter the symbol `âŠ†`,\n"
"type `\\sub`."
msgstr ""
"`A âŠ† B` significa que `A` es un subconjunto de `B`.  Para introducir el"
" sÃ­mbolo `âŠ†`,\n"
"teclea `\\sub`."

#: Game.Levels.Subset.L02subhyp
msgid ""
"Suppose $A$ and $B$ are sets, $A \\subseteq B$, and $x \\in A$.\n"
"Then $x \\in B$."
msgstr ""
"SupÃ³n que $A$ y $B$ son conjuntos, $A \\subseteq B$, y $x \\in A$.\n"
"Entonces $x \\in B$."

#: Game.Levels.Subset.L02subhyp
msgid ""
"Since `h1 h2` is a proof of `x âˆˆ B`, you can\n"
"close the goal with `exact h1 h2`."
msgstr ""
"Como `h1 h2` es una prueba de `x âˆˆ B`, puedes cerrar el objetivo con\n"
"  `exact h1 h2`."

#: Game.Levels.Subset.L02subhyp
msgid ""
"This example is a better illustration of how the `exact` tactic is usually\n"
"used.  Often `exact` is followed by an expression that combines assumptions\n"
"to prove the goal.  In later levels, we will see other ways in which\n"
"assumptions can be combined to prove a goal.\n"
"\n"
"Note that in this proof, `h1` could be thought of as a function that can be\n"
"applied to a proof of any statement of the form `x âˆˆ A` to produce a proof\n"
"of `x âˆˆ B`.  Many proofs in Lean behave like functions."
msgstr ""
"\n"
"Este ejemplo ilustra mejor cÃ³mo se usa normalmente la tÃ¡ctica `exact`.\n"
"A menudo, `exact` va seguido de una expresiÃ³n que combina hipÃ³tesis para"
" demostrar el objetivo.\n"
"En niveles posteriores, veremos otras formas en las que las hipÃ³tesis se"
" pueden combinar para\n"
"demostrar un objetivo.\n"
"\n"
"Observa que en esta prueba, `h1` podrÃ­a pensarse como una funciÃ³n que se"
" puede\n"
"aplicar a una prueba de cualquier afirmaciÃ³n de la forma `x âˆˆ A` para"
" producir una prueba\n"
"de `x âˆˆ B`. Muchas pruebas en Lean se comportan como funciones.\n"

#: Game.Levels.Subset.L03have
msgid "The have tactic"
msgstr "La tÃ¡ctica have"

#: Game.Levels.Subset.L03have
msgid ""
"In this level, we have assumptions `h1 : A âŠ† B`, `h2 : B âŠ† C`, and `h3 : x âˆˆ"
" A`.\n"
"As we saw in the last level, `h1 h3` is a proof that `x âˆˆ B`. "
" Unfortunately,\n"
"that is not the goal, so we can't use `exact h1 h3` to close the goal.\n"
"However, we can use the proof `h1 h3` to justify adding `h4 : x âˆˆ B` to our\n"
"list of assumptions.  To do that, we'll use a new tactic: `have`."
msgstr ""
"\n"
"En este nivel, tenemos las hipÃ³tesis `h1 : A âŠ† B`, `h2 : B âŠ† C`, y `h3 : x âˆˆ"
" A`.\n"
"Como vimos en el nivel anterior, `h1 h3` es una prueba de que `x âˆˆ B`."
" Lamentablemente,\n"
"ese no es el objetivo, asÃ­ que no podemos usar `exact h1 h3` para cerrar el"
" objetivo.\n"
"Sin embargo, podemos usar la prueba `h1 h3` para justificar agregar `h4 : x âˆˆ"
" B` a nuestra\n"
"lista de suposiciones. Para hacer eso, usaremos una nueva tÃ¡ctica: `have`.\n"

#: Game.Levels.Subset.L03have
msgid ""
"Use `have` to assert a statement that you can prove from your current\n"
"assumptions.  You must give the new assertion an identifier; be sure to\n"
"use an identifier that is different from those already in use.\n"
"\n"
"If some expression `t` is a proof of a statement `P`, and `h` is an\n"
"identifier that is not in use, then `have h : P := t` will add `h : P`\n"
"to the list of assumptions.\n"
"\n"
"There are two variations on the `have` tactic:\n"
"* Sometimes you want to assert a statement `P`, but the proof of `P` is too\n"
"difficult to be given in one line.  In that situation, you can simply write\n"
"`have h : P`.  Of course, you must still justify the assertion of `P`, so\n"
"the proof of `P` becomes your immediate goal.\n"
"Once the goal of proving `P` has been closed, you will be able to return to\n"
"your original goal, with `h : P` added to the assumption list.\n"
"* If you write `have h := t`, then Lean will try to figure out what"
" statement\n"
"`P` is proven by the expression `t` and, if it can figure it out, it will"
" fill\n"
"it in for you."
msgstr ""
"\n"
"Usa `have` para afirmar una declaraciÃ³n que puedes probar a partir de tus"
" suposiciones actuales.\n"
"Debes darle a la nueva afirmaciÃ³n un identificador; asegÃºrate de\n"
"usar un identificador que sea diferente de los que ya se estÃ¡n utilizando.\n"
"\n"
"Si alguna expresiÃ³n `t` es una prueba de una afirmaciÃ³n `P`, y `h` es un\n"
"identificador que no estÃ¡ en uso, entonces `have h : P := t` agregarÃ¡ `h :"
" P`\n"
"a la lista de suposiciones.\n"
"\n"
"Hay dos posibles formas de usar la tÃ¡ctica `have`:\n"
"* A veces quieres afirmar una declaraciÃ³n `P`, pero la prueba de `P` es"
" demasiado\n"
"difÃ­cil para ser dada en una sola lÃ­nea. En esa situaciÃ³n, simplemente puedes"
" escribir\n"
"`have h : P`. Por supuesto, aÃºn debes justificar la afirmaciÃ³n de `P`, asÃ­"
" que\n"
"la prueba de `P` se convierte en tu objetivo inmediato.\n"
"Una vez que se haya cerrado el objetivo de demostrar `P`, podrÃ¡s volver a\n"
"tu objetivo original, con `h : P` aÃ±adido a la lista de suposiciones.\n"
"* Si escribes `h := t`, entonces Lean intentarÃ¡ deducir quÃ© afirmaciÃ³n `P` es"
" probada por `t`, y\n"
"si puede hacerlo, directamente aÃ±adirÃ¡ una nueva hipÃ³tesis `h : P`.\n"

#: Game.Levels.Subset.L03have
msgid ""
"Suppose $A \\subseteq B$, $B \\subseteq C$, and $x \\in A$.  Then $x \\in C$."
msgstr ""
"SupÃ³n que $A \\subseteq B$, $B \\subseteq C$, y $x \\in A$.  Entonces $x "
"\\in C$."

#: Game.Levels.Subset.L03have
msgid ""
"To get started on this proof, type `have h4 : x âˆˆ B := h1 h3`\n"
"in the text box and click \"Execute\" or hit \"Return\" or \"Enter\".\n"
"Recall that you can enter the symbol `âˆˆ` by typing `\\mem` or `\\in`."
msgstr ""
"Para iniciar esta prueba, teclea `have h4 : x âˆˆ B := h1 h3`\n"
"  en la caja de texto y pulsa \"Execute\" o la tecla \"Return\" o \"Enter\".\n"
"  Recuerda que puedes introducir el sÃ­mbolo `âˆˆ` tecleando `\\mem` or `\\in`."

#: Game.Levels.Subset.L03have
msgid ""
"Notice that `Â«{h4}Â» : x âˆˆ B` has been added to the list of assumptions.\n"
"Can you complete the proof now?"
msgstr ""
"Observa que  `{h4} : x âˆˆ B` se ha aÃ±adido a la lista de suposiciones.\n"
"  Â¿Puedes completar la demostraciÃ³n ahora?"

#: Game.Levels.Subset.L03have
msgid ""
"As we saw in the last level, `h2 Â«{h4}Â»` is now\n"
"a proof of the goal, so `exact h2 Â«{h4}Â»` will close the goal."
msgstr ""
"Como vimos en el anterior nivel, `h2 {h4}` es ahora una prueba\n"
"  del objetivo, asÃ­ que `exact h2 {h4}` cerrarÃ¡ el objetivo."

#: Game.Levels.Subset.L03have
msgid ""
"You can use the `have` tactic to add a new statement to your list of\n"
"assumptions, as long as you can justify it with a proof.  For further\n"
"information, click on `have` in the list of tactics on the right."
msgstr ""
"\n"
"Puedes usar la tÃ¡ctica `have` para aÃ±adir una afirmaciÃ³n a tu lista de"
" suposiciones,\n"
"siempre que puedas justificarla con una demostraciÃ³n. Para mÃ¡s informaciÃ³n,"
" pulsa en `have`\n"
"en la lista de tÃ¡cticas a la derecha.\n"

#: Game.Levels.Subset.L04imp
msgid "Implication"
msgstr "Implicaciones"

#: Game.Levels.Subset.L04imp
msgid ""
"If `P` and `Q` are statements, then `P â†’ Q` means \"if P then Q\".\n"
"To enter the symbol `â†’`, type `\\imp` (short for \"implies\").\n"
"\n"
"The most straightforward way to prove a statement of the form `P â†’ Q` is to"
" assume that\n"
"`P` is true and then prove `Q`.  To do that, we'll need a new tactic: `intro`."
msgstr ""
"\n"
"Si `P` y `Q` son afirmaciones, entonces `P â†’ Q` significa \"si P, entonces"
" Q\".\n"
"Para ingresar el sÃ­mbolo `â†’`, escribe `\\imp` (abreviatura de \"implica\").\n"
"\n"
"La manera mÃ¡s directa de demostrar una afirmaciÃ³n de la forma `P â†’ Q` es"
" asumir que\n"
"`P` es verdadero y luego demostrar `Q`. Para hacer eso, necesitaremos una"
" nueva tÃ¡ctica: `intro`.\n"

#: Game.Levels.Subset.L04imp
msgid ""
"`P â†’ Q` means \"if `P` then `Q`\".  You can enter the symbol `â†’` by typing "
"`\\imp`."
msgstr ""
"`P â†’ Q` significa \"si `P` entonces `Q`\".  Puedes introducir el sÃ­mbolo `â†’`"
" tecleando `\\imp`."

#: Game.Levels.Subset.L04imp
msgid ""
"Use `intro` to introduce either a new assumption or a new object into your"
" proof.\n"
"\n"
"There are two situations in which you can use the `intro` tactic:\n"
"* If you are proving a statement of the form `P â†’ Q`, then you can use\n"
"the tactic `intro h` to introduce the assumption `h : P` and set `Q` as the"
" goal.  Be\n"
"sure to use an identifier that is not already in use.\n"
"* If you are proving a statement of the form `âˆ€ x, P x`, where `P x` is some"
" statement\n"
"about `x`, then you can use the tactic `intro x` to introduce a new object"
" `x` into the proof.\n"
"Be sure to use a variable name that is not already in use.  The goal will"
" then be `P x`.\n"
"\n"
"You can do multiple introductions in one step: for example, `intro x h` has"
" the same\n"
"effect as doing `intro x` followed by `intro h`."
msgstr ""
"\n"
"Usa `intro` para introducir ya sea una nueva suposiciÃ³n o un nuevo objeto en"
" tu prueba.\n"
"\n"
"Hay dos situaciones en las que puedes usar la tÃ¡ctica `intro`:\n"
"- Si estÃ¡s demostrando una afirmaciÃ³n de la forma `P â†’ Q`, entonces puedes"
" usar\n"
"la tÃ¡ctica `intro h` para introducir la suposiciÃ³n `h : P` y establecer `Q`"
" como la meta. AsegÃºrate\n"
"de usar un identificador que no estÃ© en uso.\n"
"- Si estÃ¡s demostrando una afirmaciÃ³n de la forma `âˆ€ x, P x`, donde `P x` es"
" una afirmaciÃ³n sobre\n"
"`x`, entonces puedes usar la tÃ¡ctica `intro x` para introducir un nuevo"
" objeto `x` en la prueba.\n"
"AsegÃºrate de usar un nombre de variable que no estÃ© en uso. El objetivo"
" pasarÃ¡ a ser `P x`.\n"
"\n"
"Puedes realizar mÃºltiples introducciones en un solo paso: por ejemplo, `intro"
" x h` tiene el mismo\n"
"efecto que realizar `intro x` seguido de `intro h`.\n"

#: Game.Levels.Subset.L04imp
msgid ""
"Let $x$ be an object from the universe $U$, and let $A$, $B$, and $C$ be"
" sets\n"
"such that $A \\subseteq B$ and $x \\in B \\to x \\in C$.  Then $x \\in A â†’ x"
" \\in C$."
msgstr ""
" Deje que $x$ sea un objeto del universo $U$, y dejemos que $A$, $B$ y $C$ "
"sean conjuntos such that $A \\subseteq B$ and $x \\in B \\to x \\in C$.  "
"Entonces $x \\in A â†’ x \\in C$."

#: Game.Levels.Subset.L04imp
msgid ""
"Since our goal in this level is the statement `x âˆˆ A â†’ x âˆˆ C`, our first step"
" for\n"
"this proof is to assume `x âˆˆ A`.  To introduce that assumption,\n"
"assigning it the identifier `h3`, type `intro h3`."
msgstr ""
"Como nuestro objetivo es `x âˆˆ A â†’ x âˆˆ C`, el primer paso es asumir `x âˆˆ A`."
" Para introducir\n"
"  esta hipÃ³tesis asignÃ¡ndole el identificador `h3`, teclea `intro h3`."

#: Game.Levels.Subset.L04imp
msgid ""
"Notice that `Â«{h3}Â» : x âˆˆ A` is now listed under *Assumptions*, and your new"
" goal is\n"
"`x âˆˆ C`."
msgstr ""
"FÃ­jate en que `Â«{h3}Â» : x âˆˆ A` aparece ahora en el apartado *Assumptions*, y"
" tu nuevo\n"
"objetivo es `x âˆˆ C`."

#: Game.Levels.Subset.L04imp
msgid ""
"As you saw in the previous level, you can now apply `h1` to `Â«{h3}Â»`\n"
"to justify asserting `x âˆˆ B`, using the `have` tactic."
msgstr ""
"Como vimos en el nivel anterior, puedes aplicar `h1` a `Â«{h3}Â»`\n"
"para justificar que `x âˆˆ B`, usando la tÃ¡ctica `have`."

#: Game.Levels.Subset.L04imp
msgid ""
"Just as you were able to apply `h1` to `Â«{h3}Â»` in the last step,\n"
"you can now apply `h2` to `Â«{h4}Â»` to prove the goal."
msgstr ""
"Igual que pudiste aplicar `h1` a `{h3}` en el paso anterior,\n"
"  ahora puedes aplicar `h2` a `Â«{h4}Â»` para probar el objetivo."

#: Game.Levels.Subset.L04imp
msgid ""
"In general, if your goal has the form `P â†’ Q`, then the tactic `intro h` will"
" add `h : P` to\n"
"the list of assumptions and set `Q` to be the goal.  If you have assumptions\n"
"`h1 : P â†’ Q` and `h2 : P`, then `h1 h2` is a proof of `Q`.  This is another"
" example of a proof\n"
"acting like a function: a proof of `P â†’ Q` can be thought of as a function"
" which, when\n"
"applied to a proof of `P`, produces a proof of `Q`.\n"
"\n"
"As usual, for more information about the new tactic `intro`, you can click on"
" `intro`\n"
"in the list of tactics on the right."
msgstr ""
"\n"
"En general, si tu objetivo es de la forma `P â†’ Q`, la tÃ¡ctica `intro h`"
" aÃ±adirÃ¡ `h : P` a la lista\n"
"de hipÃ³tesis, y establecerÃ¡ `Q` como el objetivo a probar. Si tienes"
" hipÃ³tesis\n"
"`h1 : P â†’ Q` y `h2 : P`, `h1 h2` es una prueba de `Q`. Este es otro ejemplo"
" de una prueba funcionando\n"
"como una funciÃ³n: una prueba de `P â†’ Q` se puede ver como una funciÃ³n que,"
" cuando se aplica a `P`\n"
"produce una prueba de `Q`.\n"
"\n"
"Como de costumbre, para mÃ¡s informaciÃ³n sobre la tÃ¡ctica `intro`, puedes"
" pulsar en\n"
"`intro` en la lista de tÃ¡cticas de la derecha.\n"

#: Game.Levels.Subset.L05subref
msgid "Subset is reflexive"
msgstr "La relaciÃ³n de contenido es reflexiva"

#: Game.Levels.Subset.L05subref
msgid ""
"How do you prove that one set is a subset of another?  To prove that `A âŠ†"
" B`,\n"
"you have to show that if some object `x` is an element of `A`, then it is"
" also\n"
"an element of `B`.  To do that, you'll have to introduce an object called `x`"
" into\n"
"the proof.  The object denoted by `x` could be anything, so we say that it"
" is\n"
"*arbitrary*.\n"
"\n"
"In this level, we start with a simple example of this kind of proof.  We're"
" going\n"
"to show that if `A` is a set, then `A âŠ† A`."
msgstr ""
"\n"
"Â¿CÃ³mo demuestras que un conjunto es un subconjunto de otro? Para demostrar"
" que `A âŠ† B`,\n"
"tienes que mostrar que si algÃºn objeto `x` es un elemento de `A`, entonces"
" tambiÃ©n lo es\n"
"un elemento de `B`. Para hacer eso, tendrÃ¡s que introducir un objeto `x` en\n"
"la prueba. Este elemento `x` podrÃ­a ser cualquiera, asÃ­ que decimos que es"
" *arbitrario*.\n"
"\n"
"En este nivel, comenzamos con un ejemplo simple de este tipo de prueba. Vamos"
" a mostrar\n"
"que si `A` es un conjunto, entonces `A âŠ† A`.\n"

#: Game.Levels.Subset.L05subref
msgid ""
"If you have `A : Set U`, then `Subset.refl A` is a proof of `A âŠ† A`.\n"
"In Mathlib, the name of this theorem is `Set.Subset.refl`."
msgstr ""
"Si tenemos `A : Set U`, entonces `sub_ref A` es una prueba de que `A âŠ† A`.\n"
"En Mathlib, este teorema se llama `Set.Subset.refl`."

#: Game.Levels.Subset.L05subref
msgid "Let $A$ be any set.  Then $A \\subseteq A$."
msgstr "Sea $A$ un conjunto cualquiera.  Entonces $A \\subseteq A$."

#: Game.Levels.Subset.L05subref
msgid ""
"Our first step is to introduce an object `x` into the proof.  To do this,"
" type `intro x`.\n"
"We have already seen that the `intro` tactic can be used to introduce a new"
" *assumption* into a\n"
"proof.  This step illustrates a second use of `intro`: introducing a new"
" *object* into a proof."
msgstr ""
"Nuestro primer paso es introducir un objeto `x` en la prueba. Para hacer"
" esto,\n"
"  escribe `intro x`. Ya hemos visto que la tÃ¡ctica `intro` se puede utilizar"
" para introducir\n"
"  una nueva *suposiciÃ³n* en una prueba. Este paso ilustra un segundo uso de"
" `intro`:\n"
"  introducir un nuevo *objeto* en una prueba."

#: Game.Levels.Subset.L05subref
msgid ""
"Notice that `Â«{x}Â» : U` has been added to the list of objects, and\n"
"the goal has changed to `Â«{x}Â» âˆˆ A â†’ Â«{x}Â» âˆˆ A`.  Fortunately, you already"
" know how to prove\n"
"a goal of this form."
msgstr ""
"Observa que se ha aÃ±adido  `Â«{x}Â» : U` a la lista de objetos, y\n"
"el objetivo ha cambiado a  `Â«{x}Â» âˆˆ A â†’ Â«{x}Â» âˆˆ A`. Afortunadamente, ya sabes"
" cÃ³mo demostrar\n"
"un objetivo de esta forma."

#: Game.Levels.Subset.L05subref
msgid "Use `intro` again to introduce the assumption `Â«{x}Â» âˆˆ A`."
msgstr "Usa `intro` otra vez para introducir la suposiciÃ³n `Â«{x}Â» âˆˆ A`."

#: Game.Levels.Subset.L05subref
msgid ""
"The situation now should remind you of your first proof, in level 1 of this "
"world."
msgstr ""
"La situaciÃ³n ahora deberÃ­a recordarte a tu primera demostraciÃ³n, en el nivel"
" 1 de este mundo."

#: Game.Levels.Subset.L05subref
msgid "Notice that Â«{h}Â» is now a proof of the goal."
msgstr "Observa que Â«{h}Â» es ahora una prueba del objetivo."

#: Game.Levels.Subset.L05subref
msgid ""
"The theorem you have proven in this level shows that the subset relation has\n"
"a property called *reflexivity*.  We have given the theorem the name"
" `Subset.refl`.  You\n"
"will see it in the list of theorems on the right.  (This theorem is included"
" in Lean's\n"
"mathematical library, Mathlib.  In Mathlib, the name of the theorem is"
" `Set.Subset.refl`.\n"
"Many other set-theoretic theorems in this game have `Set.` at the beginnings"
" of their names\n"
"in Mathlib.)"
msgstr ""
"\n"
"El teorema que has demostrado en este nivel muestra que la relaciÃ³n de ser"
" subconjunto tiene\n"
"una propiedad llamada *reflexividad*. Hemos dado al teorema el nombre"
" `sub_ref`.\n"
"Lo verÃ¡s en la lista de teoremas a la derecha. \n"
" (Este teorema estÃ¡ incluido en la biblioteca matemÃ¡tica de Lean, *Mathlib*."
" \n"
"En Mathlib, el nombre de este teorema es  `Set.Subset.refl`.Otros muchos"
" teoremas sobre teorÃ­a de conjuntos de este juego estÃ¡n en Mathlib con"
" nombres que empiezan por `Set.`)."

#: Game.Levels.Subset.L06subtrans
msgid "Subset is transitive"
msgstr "La relaciÃ³n de contenido es transitiva."

#: Game.Levels.Subset.L06subtrans
msgid ""
"To start a proof, you should look first at the goal.\n"
"What needs to be done to prove the goal?\n"
"In this level, the goal is `A âŠ† C`.  What does that\n"
"tell you about how to proceed?"
msgstr ""
"Para empezar una demostraciÃ³n, empieza mirando el objetivo.Â¿QuÃ© necesitas "
"hacer para demostrar el objetivo?En este nivel, el objetivo es `A âŠ† C`.  "
"Â¿QuÃ© te dice eso sobre los pasos a dar?"

#: Game.Levels.Subset.L06subtrans
msgid ""
"If you have `h1 : A âŠ† B` and `h2 : B âŠ† C`, then `Subset.trans h1 h2` is a"
" proof of `A âŠ† C`.\n"
"In Mathlib, the name of this theorem is `Set.Subset.trans`."
msgstr ""
"Si tienes `h1 : A âŠ† B` y `h2 : B âŠ† C`, `sub_trans h1 h2` es una prueba de `A"
" âŠ† C`.\n"
"En Mathlib, el nombre de este teorema es `Set.Subset.trans`."

#: Game.Levels.Subset.L06subtrans
msgid "Suppose $A \\subseteq B$ and $B \\subseteq C$.  Then $A \\subseteq C$."
msgstr "Sea $A \\subseteq B$ y $B \\subseteq C$.  Entonces $A \\subseteq C$."

#: Game.Levels.Subset.L06subtrans
msgid ""
"To get started, you'll need to introduce first\n"
"an object `x` and then the assumption that `x âˆˆ A`."
msgstr ""
"Para empezar, hay que introducir un objeto `x` y la hipÃ³tesis de que `x âˆˆ "
"A`."

#: Game.Levels.Subset.L06subtrans
msgid "Does your situation now remind you of a previous level?"
msgstr "Â¿Te recuerda esta situaciÃ³n al nivel anterior?"

#: Game.Levels.Subset.L06subtrans
msgid ""
"First use `have` to assert that `Â«{x}Â» âˆˆ B`, and\n"
"then prove `Â«{x}Â» âˆˆ C`."
msgstr ""
"Usa `have` para afirmar que `Â«{x}Â» âˆˆ B`, y despuÃ©s demuestra `Â«{x}Â» âˆˆ C`."

#: Game.Levels.Subset.L06subtrans
msgid ""
"The theorem you have proven in this level shows that the subset relation has\n"
"a property called *transitivity*.  We have given the theorem the name"
" `Subset.trans`."
msgstr ""
"El teorema que has demostrado en este nivel dice que la relaciÃ³n de "
"contenido tiene una propiedad llamada *transitividad*. Hemos llamado a este "
"teorema `Subset.trans`."

#: Game.Levels.Subset
msgid "Subset World"
msgstr "Mundo de los subconjuntos"

#: Game.Levels.Subset
msgid ""
"Welcome to Subset World! In this world you will learn about sets and\n"
"subsets, and you will also learn the basics of proving theorems in Lean.\n"
"\n"
"The elements of the sets in this world will come from a universe called `U`.\n"
"To specify that an\n"
"object `x` belongs to the universe `U`, we write `x : U`.  To specify\n"
"that `A` is a set of objects from `U`, we write `A : Set U`.  (The"
" terminology used\n"
"in Lean is that `x` has *type* `U` and `A` has *type* `Set U`.)  To\n"
"say that `x` is an element of `A`, we write `x âˆˆ A`.  (You can enter\n"
"the symbol `âˆˆ` by typing `\\mem` or `\\in`, followed by a space.)\n"
"\n"
"You will prove theorems in this game by using tools called *tactics*.\n"
"The aim is to prove the theorem by applying tactics\n"
"in the right order.\n"
"\n"
"Let's learn some basic tactics. Click on \"Start\" below\n"
"to get started."
msgstr ""
"Â¡Bienvenido al mundo de los subconjuntos!En este mundo, aprenderÃ¡s sobre "
"conjuntos y subconjuntos, y tambiÃ©n aprenderÃ¡s los conceptos bÃ¡sicos de cÃ³mo"
" demostrar teoremas en Lean. Los elementos de los conjuntos en este mundo "
"provendrÃ¡n de un universo llamado `U`.(Lean llama a `U` un *Tipo*.) Para "
"especificar que un objeto `x` pertenece al universo `U`,escribimos `x : U`. "
"Para especificar que `A` es un conjunto de objetos de `U`, escribimos`A : "
"Set U`. Para decir que `x` es un elemento de `A`, escribimos `x âˆˆ A`.(Puedes"
" ingresar el sÃ­mbolo `âˆˆ` escribiendo `\\mem` o `\\in`, seguido de un "
"espacio).ProbarÃ¡s teoremas en este juego utilizando herramientas llamadas "
"*tÃ¡cticas*.El objetivo es demostrar el teorema aplicando tÃ¡cticas en el "
"orden correcto.Aprendamos algunas tÃ¡cticas bÃ¡sicas. Haz click en "
"\\\"Start\\\" a continuaciÃ³n para empezar."

#: Game.Levels.Comp.L01contra
msgid "Proof by contradiction"
msgstr "DemostraciÃ³n por contradicciÃ³n"

#: Game.Levels.Comp.L01contra
msgid ""
"To work with complements, we'll need to understand negative statements--that"
" is, statements\n"
"that say that something is *not* the case.\n"
"\n"
"If `P` is a statement, then `Â¬P` means \"it is not the case that P\".  To"
" enter the symbol\n"
"`Â¬`, type `\\not`.\n"
"\n"
"A common method of proving a negative statement is *proof by\n"
"contradiction*: to prove a statement of the form `Â¬P`, you can assume that"
" `P` is true\n"
"and then show that this assumption leads to a contradiction.  The tactic to"
" use for this\n"
"kind of proof is `by_contra`."
msgstr ""
"Para trabajar con complementos, necesitaremos entender declaraciones"
" negativas, es decir, afirmaciones que indican que algo *no* es cierto.\n"
"\n"
"Si `P`  es una afirmaciÃ³n, entonces `Â¬P` significa \"no es cierto que P\"."
" Para introducir el sÃ­mbolo `Â¬`, escribe `\\not`.\n"
"\n"
"Un mÃ©todo comÃºn para demostrar una afirmaciÃ³n negativa es la *prueba por"
" contradicciÃ³n*: para demostrar una afirmaciÃ³n de la forma `Â¬P`, puedes"
" asumir que `P` es verdadero y luego mostrar que esta suposiciÃ³n conduce a"
" una contradicciÃ³n. La tÃ¡ctica a utilizar para este tipo de prueba es"
" `by_contra`."

#: Game.Levels.Comp.L01contra
msgid ""
"If your goal is `Â¬P`, for some statement `P`, then the tactic\n"
"`by_contra h` will introduce the new assumption `h : P`, and set the\n"
"goal to be `False`.  If your goal is a statement `P` that is not a negative\n"
"statement, then `by_contra h` will introduce the new assumption\n"
"`h : Â¬P`.\n"
"\n"
"To achieve your new goal, you will need to establish\n"
"`h1 : Q` and `h2 : Â¬Q`, for some statement `Q`.  If you can do that,\n"
"then `h2 h1` will prove the goal `False`.  Notice that `h1 h2` will not be\n"
"recognized as a proof of `False`; the negative statement must come first."
msgstr ""
"Si tu objetivo es `Â¬P`, para alguna afirmaciÃ³n `P`, entonces la "
"tÃ¡ctica`by_contra h` introducirÃ¡ la nueva suposiciÃ³n `h : P` y establecerÃ¡ "
"el objetivo como `False`. Si tu objetivo es una afirmaciÃ³n `P` que no es "
"negativa,entonces `by_contra h` introducirÃ¡ la nueva suposiciÃ³n`Â¬P`.Para "
"lograr tu nuevo objetivo, deberÃ¡s establecer`h1 : Q` y `h2 : Â¬Q`, para "
"alguna afirmaciÃ³n `Q`. Si puedes hacer eso,entonces `h2 h1` demostrarÃ¡ el "
"objetivo `False`. Observa que `h1 h2` no serÃ¡ reconocido como una prueba de "
"`False`; la afirmaciÃ³n negativa debe venir primero."

#: Game.Levels.Comp.L01contra
msgid ""
"`Â¬P` means \\\"it is not the case that P\\\".  To enter the symbol `Â¬`,\n"
"type `\\not`."
msgstr ""
"`Â¬P` significa \\\"no es cierto que se cumpla P\\\".  Para obtener el sÃ­mbolo"
" `Â¬`,\n"
"teclea `\\not`."

#: Game.Levels.Comp.L01contra
msgid "Suppose $x \\in A$ and $x \\notin B$.  Then $\\neg A \\subseteq B$."
msgstr ""
"Supongamos que $x \\in A$ y $x \\notin B$.  Entonces $\\neg A \\subseteq B$."

#: Game.Levels.Comp.L01contra
msgid ""
"For the theorem in this level, your goal is `Â¬A âŠ† B`.  To use proof by"
" contradiction\n"
"in this proof, you must begin by introducing the assumption `h3 : A âŠ† B`.  To"
" do that, type\n"
"`by_contra h3`"
msgstr ""
"Para el teorema en este nivel, tu objetivo es `Â¬A âŠ† B`. Para utilizar la"
" prueba por contradicciÃ³n\n"
"  en esta demostraciÃ³n, debes comenzar introduciendo la suposiciÃ³n `h3 : A âŠ†"
" B`. Para hacerlo, escribe\n"
"  `by_contra h3`."

#: Game.Levels.Comp.L01contra
msgid ""
"Notice that the goal is now `False`.  To achieve that goal,\n"
"you must prove contradictory statements.  You can do that by\n"
"using `have` to assert `x âˆˆ B`, which will contradict `h2 : x âˆ‰ B`."
msgstr ""
"Observa que el objetivo es ahora `False`. Para lograr ese objetivo,\n"
"  debes demostrar afirmaciones contradictorias. Puedes hacer esto\n"
"  usando `have` para afirmar `h4 : x âˆˆ B`, lo cual contradirÃ¡ a `h2 : x âˆ‰ B`."

#: Game.Levels.Comp.L01contra
msgid "`Â«{h3}Â» h1` is a proof of `x âˆˆ B`."
msgstr "`Â«{h3}Â» h1` es una prueba de `x âˆˆ B`."

#: Game.Levels.Comp.L01contra
msgid ""
"You can think of `h2 : x âˆ‰ B` (which is shorthand for `h2 : Â¬x âˆˆ B`)\n"
"as meaning \"if `x âˆˆ B` were true, then that would lead to a"
" contradiction\"--in other\n"
"words, `x âˆˆ B â†’ False`.\n"
"Applying this to your new assumption `Â«{h4}Â» : x âˆˆ B` will give the"
" contradiction\n"
"you need.  In other words, `exact h2 Â«{h4}Â»` will close the goal."
msgstr ""
"Puedes pensar en `h2 : x âˆ‰ B` (que es una forma abreviada de `h2 : Â¬x âˆˆ B`)\n"
"como significando \"si `x âˆˆ B` fuera verdadero, eso conducirÃ­a a una"
" contradicciÃ³n\"--dicho\n"
"de otro modo, `x âˆˆ B â†’ False`.\n"
"Aplicar esto a tu nueva suposiciÃ³n `Â«{h4}Â» : x âˆˆ B` darÃ¡ la contradicciÃ³n\n"
"que necesitas. En otras palabras, `exact h2 Â«{h4}Â»` cerrarÃ¡ el objetivo."

#: Game.Levels.Comp.L01contra
msgid ""
"You can use the `by_contra` tactic in any proof to assume the\n"
"opposite of your goal.  But it is most useful when the goal\n"
"starts with the symbol `Â¬`.  After using the `by_contra` tactic,\n"
"your goal will be `False`.\n"
"\n"
"To complete a proof by contradiction, you must prove contradictory"
" statements.\n"
"If your goal is `False` and you have assumptions `h1 : P` and `h2 : Â¬P`, for\n"
"some statement `P`, then `exact h2 h1` will close the goal.  Note that `exact"
" h1 h2` won't\n"
"work; you must list the negative statement first to establish a contradiction."
msgstr ""
"\n"
"Puedes usar la tÃ¡ctica `by_contra` en cualquier prueba para asumir lo"
" contrario de tu objetivo.\n"
"Pero es mÃ¡s Ãºtil cuando el objetivo comienza con el sÃ­mbolo `Â¬`. DespuÃ©s de"
" usar la tÃ¡ctica `by_contra`,\n"
"tu objetivo serÃ¡ `False`.\n"
"\n"
"Para completar una prueba por contradicciÃ³n, debes demostrar afirmaciones"
" contradictorias.\n"
"Si tu objetivo es `False` y tienes las suposiciones `h1 : P` y `h2 : Â¬P`,"
" para\n"
"alguna afirmaciÃ³n `P`, entonces `exact h2 h1` cerrarÃ¡ el objetivo. Ten en"
" cuenta que `exact h1 h2`\n"
"no funcionarÃ¡; debes listar la afirmaciÃ³n negativa primero para establecer"
" una contradicciÃ³n.\n"

#: Game.Levels.Comp.L02compdef
msgid "Definition of complement"
msgstr "DefiniciÃ³n de complementario"

#: Game.Levels.Comp.L02compdef
msgid ""
"If you have `A : Set U`, then `Aá¶œ` is defined to be the set of all objects in"
" the universe `U`\n"
"that are not elements of `A`.  That means that if you also have `x : U`, then"
" the statements\n"
"`x âˆˆ Aá¶œ` and `x âˆ‰ A` are equivalent.  We express this by saying that the"
" statement\n"
"`x âˆˆ Aá¶œ â†” x âˆ‰ A` is true.  (The symbol `â†”` means \"if and only if\", and you"
" can enter it\n"
"by typing `\\iff`.  You can enter the superscript `c` in the notation for the"
" complement\n"
"of a set by typing `\\compl` or `\\^c`.)\n"
"\n"
"In this level, we're going to prove that the statement `x âˆˆ Aá¶œ â†” x âˆ‰ A` is"
" true, and to do\n"
"it we'll use a new tactic: `rfl`.  The `rfl` tactic can prove any statement"
" of the form\n"
"`P â†” Q` if `P` and `Q` are statements that are equivalent by virtue of the"
" definitions of\n"
"the symbols occurring in them.  (We say in this case that `P` and `Q` are"
" *definitionally\n"
"equivalent*.)  The `rfl` tactic can also prove statements of the form `X ="
" Y`, if `X` and\n"
"`Y` are definitionally equal--that is, equal by virtue of definitions."
msgstr ""
"\n"
"Si tienes `A : Set U`, entonces `Aá¶œ` se define como el conjunto de todos los"
" objetos en el universo\n"
"`U` que no son elementos de `A`. Esto significa que si tambiÃ©n tienes `x :"
" U`, entonces las\n"
"afirmaciones `x âˆˆ Aá¶œ` y `x âˆ‰ A` son equivalentes. Expresamos esto diciendo"
" que la afirmaciÃ³n\n"
"`x âˆˆ Aá¶œ â†” x âˆ‰ A` es verdadera. (El sÃ­mbolo `â†”` significa \\\"si y solo"
" si\\\", y puedes introducirlo\n"
"escribiendo `\\iff`. Puedes ingresar el superÃ­ndice `c` en la notaciÃ³n para"
" el complemento de un\n"
"conjunto escribiendo `\\compl` o `\\^c`.)\n"
"\n"
"En este nivel, vamos a demostrar que la afirmaciÃ³n `x âˆˆ Aá¶œ â†” x âˆ‰ A` es"
" verdadera, y para hacerlo\n"
"usaremos una nueva tÃ¡ctica: `rfl`. La tÃ¡ctica `rfl` puede demostrar cualquier"
" afirmaciÃ³n de la forma\n"
"`P â†” Q` si `P` y `Q` son afirmaciones que son equivalentes por virtud de las"
" definiciones de los\n"
"sÃ­mbolos que aparecen en ellas. (Decimos en este caso que `P` y `Q` son"
" *equivalentes por definiciÃ³n*.)\n"
"La tÃ¡ctica `rfl` tambiÃ©n puede demostrar afirmaciones de la forma `X = Y`,\n"
"si `X` e `Y` son iguales por definiciÃ³n.\n"

#: Game.Levels.Comp.L02compdef
msgid ""
"If your goal is a statement of the form `P â†” Q`, and `P` and `Q` are"
" definitionally\n"
"equivalent (that is, equivalent by virtue of the definitions of the symbols"
" occurring in\n"
"them), then the `rfl` tactic will close the goal.  It will also close a goal"
" of the form\n"
"`X = Y`, if `X` and `Y` are definitionally equal (that is, equal by virtue of"
" definitions)."
msgstr ""
"Si tu objetivo es una afirmaciÃ³n de la forma `P â†” Q`, y `P` y `Q` son"
" equivalentes por definiciÃ³n\n"
"(es decir, equivalentes por virtud de las definiciones de los sÃ­mbolos que"
" aparecen en ellas),\n"
"entonces la tÃ¡ctica `rfl` cerrarÃ¡ el objetivo. TambiÃ©n cerrarÃ¡ un objetivo de"
" la forma\n"
"`X = Y`, si `X` e `Y` son iguales por definiciÃ³n.\n"

#: Game.Levels.Comp.L02compdef
msgid ""
"If `A` is a of objects from the universe `U`, then `Aá¶œ` is the complement of"
" `A`; that is,\n"
"`Aá¶œ` is the set of objects from `U` that are not elements of `A`.  You can"
" enter the symbol `á¶œ`\n"
"by typing `\\compl` or `\\^c`."
msgstr ""
"Si `A` es un conjunto de objetos del universo `U`, entonces `Aá¶œ` es el"
" complementario de `A`;\n"
"es decir, `Aá¶œ` es el conjunto de objetos de `U` que no son elementos de `A`."
" Puedes ingresar el\n"
"sÃ­mbolo `á¶œ` escribiendo `\\compl` o `\\^c`."

#: Game.Levels.Comp.L02compdef
msgid ""
"`P â†” Q` means \"P if and only if Q\".  You can enter the symbol `â†”` by "
"typing `\\iff`."
msgstr ""
"`P â†” Q` significa \\\"P si y solo si Q\\\".  Puedes introducir el sÃ­mbolo "
"`â†”` tecleando `\\iff`."

#: Game.Levels.Comp.L02compdef
msgid ""
"If you have `A : Set U` and `x : U`, then `mem_compl_iff A x` is a proof of"
" the statement\n"
"`x âˆˆ Aá¶œ â†” x âˆ‰ A`.  In Mathlib, the name of this theorem is"
" `Set.mem_compl_iff`."
msgstr ""
"Si tienes `x : U` y `A : Set U`, entonces `comp_def x A` es una prueba de la"
" afirmaciÃ³n\n"
"`x âˆˆ Aá¶œ â†” x âˆ‰ A`."

#: Game.Levels.Comp.L02compdef
msgid ""
"Let $x$ be an object in the universe $U$, and let $A$ be a set whose"
" elements\n"
"come from $U$.  Then $x \\in A^c \\leftrightarrow x \\notin A$."
msgstr ""
"Sea $x$ un objeto en el universo $U$, y sea $A$ un conjunto cuyos elementos\n"
"proceden de $U$.  Entonces $x \\in A^c \\leftrightarrow x \\notin A$."

#: Game.Levels.Comp.L02compdef
msgid ""
"The proof of the theorem in this level is very easy.\n"
"Since `x âˆˆ Aá¶œ` and `x âˆ‰ A` are definitionally equivalent, `rfl` will close"
" the goal."
msgstr ""
"La demostraciÃ³n en este nivel es muy fÃ¡cil.\n"
"  Como `x âˆˆ Aá¶œ` y `x âˆ‰ A` son iguales por definiciÃ³n, `rfl` cerrarÃ¡ el"
" objetivo."

#: Game.Levels.Comp.L02compdef
msgid ""
"The name of the tactic `rfl` is short for \"reflexivity\", which is the"
" property of\n"
"both `=` and `â†”` that is the basis for the tactic.\n"
"\n"
"We have given the theorem proven in this level the name `mem_compl_iff`.  In"
" the next level,\n"
"we will see how we can use it to prove theorems about complements."
msgstr ""
"Hemos llamado al teorema demostrado en este nivel `comp_def`, porque expresa"
" la definiciÃ³n\n"
"del complementario. En el siguiente nivel veremos cÃ³mo usarlo para demostrar"
" teoremas sobre\n"
"complementarios."

#: Game.Levels.Comp.L03compsub
msgid "Complement subsets from subsets"
msgstr "Conjuntos complementaros de subconjuntos"

#: Game.Levels.Comp.L03compsub
msgid ""
"In the last level, you proved the theorem `mem_compl_iff`.  If you have `A :"
" Set U` and `x : U`,\n"
"then `mem_compl_iff A x` is a proof of the statement `x âˆˆ Aá¶œ â†” x âˆ‰ A`.\n"
"\n"
"You could think of the statement `x âˆˆ Aá¶œ â†” x âˆ‰ A` as saying that if `x âˆˆ Aá¶œ`"
" occurs anywhere\n"
"in a proof, you can replace it with `x âˆ‰ A`.  There is a tactic called"
" `rewrite` that can be\n"
"used to perform such replacements.  You'll get to try out the `rewrite`"
" tactic in this level."
msgstr ""
"\n"
"En el Ãºltimo nivel, demostraste el teorema `comp_def`. Si tienes `x : U` y `A"
" : Set U`,\n"
"entonces `comp_def x A` es una prueba de la afirmaciÃ³n `x âˆˆ Aá¶œ â†” x âˆ‰ A`.\n"
"\n"
"PodrÃ­as pensar en la afirmaciÃ³n `x âˆˆ Aá¶œ â†” x âˆ‰ A` como decir que si `x âˆˆ Aá¶œ`"
" ocurre en cualquier\n"
"parte de una prueba, puedes reemplazarlo con `x âˆ‰ A`. Hay una tÃ¡ctica llamada"
" `rewrite` que se puede\n"
"usar para realizar tales reemplazos. TendrÃ¡s la oportunidad de probar la"
" tÃ¡ctica `rewrite` en este nivel.\n"

#: Game.Levels.Comp.L03compsub
msgid ""
"If the expression `t` is a proof of a statement of the form `P â†” Q`, then the"
" tactic\n"
"`rewrite [t]` will replace `P` anywhere that it occurs in the goal with `Q`. "
" If you want to\n"
"replace `Q` with `P`, use `rewrite [â† t]`.  (Type `\\l` to enter the symbol"
" `â†`.)  To do the\n"
"replacement in an assumption `h`, use `rewrite [t] at h`.\n"
"\n"
"The `rewrite` tactic can also be used with equations.  If `t` is a proof of"
" an equation\n"
"`p = q`, then `rewrite [t]` will replace `p` with `q` wherever it appears,"
" and `rewrite [â† t]`\n"
"will replace `q` with `p`.\n"
"\n"
"To do multiple replacements, one after another, put a list of proofs inside"
" the brackets, like\n"
"this:  `rewrite [t1, t2]`."
msgstr ""
"\"Si la expresiÃ³n `t` es una prueba de una afirmaciÃ³n de la forma `P â†” Q`,"
" entonces la tÃ¡ctica\n"
"`rewrite [t]` reemplazarÃ¡ `P` en cualquier lugar donde aparezca en la meta"
" con `Q`. Si deseas\n"
"reemplazar `Q` con `P`, usa `rewrite [â† t]`. (Escribe `\\l` para ingresar el"
" sÃ­mbolo `â†`.) Para\n"
"realizar el reemplazo en una suposiciÃ³n `h`, usa `rewrite [t] at h`.\n"
"\n"
"La tÃ¡ctica `rewrite` tambiÃ©n se puede usar con ecuaciones. Si `t` es una"
" prueba de una ecuaciÃ³n\n"
"`p = q`, entonces `rewrite [t]` reemplazarÃ¡ `p` con `q` dondequiera que"
" aparezca, y `rewrite [â† t]`\n"
"reemplazarÃ¡ `q` con `p`.\n"
"\n"
"Para realizar mÃºltiples reemplazos, uno despuÃ©s de otro, coloca una lista de"
" pruebas dentro de los corchetes, asÃ­:\n"
"`rewrite [t1, t2]`.\n"

#: Game.Levels.Comp.L03compsub
msgid ""
"If you have `h : A âŠ† B`, then `compl_subset_compl_of_subset h` is a proof of"
" `Bá¶œ âŠ† Aá¶œ`.\n"
"In Mathlib, the name of this theorem is `Set.compl_subset_compl_of_subset`."
msgstr ""
"Si tienes `h : A âŠ† B`, entonces `compl_subset_compl_of_subset h` es una"
" prueba de `Bá¶œ âŠ† Aá¶œ`.\n"
"En Mathlib, este teorema se llama `Set.compl_subset_compl_of_subset`."

#: Game.Levels.Comp.L03compsub
msgid "Suppose $A \\subseteq B$.  Then $B^c \\subseteq A^c$."
msgstr "Supongamos $A \\subseteq B$.  Entonces $B^c \\subseteq A^c$."

#: Game.Levels.Comp.L03compsub
msgid ""
"As usual, to prove a subset statement you need to introduce both a new object"
" `x` and\n"
"a new assumption `h2`.  You can do it in one step with `intro x h2`."
msgstr ""
"Como de costumbre, para demostrar un contenido, necesitas introducir un nuevo"
" objeto `x` y\n"
"  una nueva suposiciÃ³n `h2`.  Puedes hacerlo de golpe con `intro x h2`."

#: Game.Levels.Comp.L03compsub
msgid ""
"Now `mem_compl_iff A Â«{x}Â»` is a proof of the statement `Â«{x}Â» âˆˆ Aá¶œ â†” Â«{x}Â» âˆ‰"
" A`, which tells us\n"
"that we can reexpress the goal `Â«{x}Â» âˆˆ Aá¶œ` as `Â«{x}Â» âˆ‰ A`.  To do this"
" reexpression,\n"
"use the tactic `rewrite [mem_compl_iff A Â«{x}Â»]`."
msgstr ""
"ahora `mem_compl_iff A Â«{x}Â»` es una prueba de `Â«{x}Â» âˆˆ Aá¶œ â†” Â«{x}Â» âˆ‰ A`, lo"
" que viene a decir\n"
"que podemos reescribir el objetivo `Â«{x}Â» âˆˆ Aá¶œ` como `Â«{x}Â» âˆ‰ A`.  Para hacer"
" esta reescritura,\n"
"usa la tÃ¡ctica `rewrite [mem_compl_iff A Â«{x}Â»]`."

#: Game.Levels.Comp.L03compsub
msgid ""
"The `rewrite` tactic is smart enough to figure out some things on its own. "
" If you\n"
"had just written `rewrite [mem_compl_iff]`, then Lean would have figured out"
" how to apply the\n"
"theorem `mem_compl_iff` to get an equivalence that could be used to make a"
" replacement in the goal.\n"
"In other words, it would have figured out that the theorem `mem_compl_iff`"
" had to be applied to\n"
"`A` and `Â«{x}Â»`.\n"
"\n"
"Similarly, you can write `rewrite [mem_compl_iff] at Â«{h2}Â»` to write out the"
" meaning of `Â«{h2}Â»`.  Lean\n"
"will figure out that in this case, `mem_compl_iff` has to be applied to `B`"
" and `Â«{x}Â»`."
msgstr ""
"La tÃ¡ctica `rewrite` es suficientemente inteligente para deducir algunas"
" cosas por sÃ­ misma.\n"
"  Si hubieras escrito solamente `rewrite [mem_compl_iff]`, Lean habrÃ­a"
" deducido como aplicar el teorema\n"
"  `mem_compl_iff` para obtener una equivalencia que pueda usarse para hacer"
" una reescritura en el objetivo.\n"
"  En otras palabras, habrÃ­a deducido que el teorema `mem_compl_iff` tenÃ­a que"
" aplicarse a `A` y `Â«{x}Â»`.\n"
"\n"
"  AnÃ¡logamente, puedes escribir  `rewrite [mem_compl_iff] at Â«{h2}Â»` para"
" reescribir el significado deÂ«{h2}Â»`.\n"
"  Lean deducirÃ¡ que, en ese caso,  `mem_compl_iff`  se tiene que aplicar a"
" `B` y `Â«{x}Â»`."

#: Game.Levels.Comp.L03compsub
msgid "Now your goal is a negative statement, so try proof by contradiction."
msgstr ""
"Ahora tu objetivo es una negaciÃ³n, asÃ­ que intenta demostrarlo por "
"contradicciÃ³n."

#: Game.Levels.Comp.L03compsub
msgid ""
"This should remind you of the first level of this world.  To get a"
" contradiction,\n"
"try to contradict `Â«{h2}Â» : Â«{x}Â» âˆ‰ B`."
msgstr ""
"Esto deberÃ­a recordarte el primer nivel de este mundo. Para obtener una\n"
"  contradicciÃ³n, intenta contradecir `Â«{h2}Â» : Â«{x}Â» âˆ‰ B`."

#: Game.Levels.Comp.L03compsub
msgid ""
"The `rewrite` tactic is often useful for writing out definitions.  For more"
" information about\n"
"how it works, click on `rewrite` in the list of tactics on the right.  You"
" can also use `rw`\n"
"instead of `rewrite`.  (There is actually a small difference between the"
" tactics `rw` and\n"
"`rewrite`, but the difference won't concern us in this game.)\n"
"\n"
"You'll find the theorem you proved in this level listed as"
" `compl_subset_compl_of_subset` in the list of\n"
"theorems on the right.  This theorem will be useful in the last level of this"
" world."
msgstr ""
"\n"
"La tÃ¡ctica `rewrite` es Ãºtil a menudo para reescribir definiciones. Para"
" obtener mÃ¡s informaciÃ³n\n"
"sobre cÃ³mo funciona, pulsa en `rewrite` en la lista de tÃ¡cticas a la derecha."
" TambiÃ©n puedes usar\n"
"`rw` en lugar de `rewrite`. (De hecho, hay una pequeÃ±a diferencia entre las"
" tÃ¡cticas `rw` y `rewrite`,\n"
"pero esa diferencia no nos preocuparÃ¡ en este juego).\n"
"\n"
"EncontrarÃ¡s el teorema que demostraste en este nivel listado como "
" `compl_subset_compl_of_subset` en la lista de\n"
"teoremas a la derecha. Este teorema serÃ¡ Ãºtil en el Ãºltimo nivel de este"
" mundo.\n"

#: Game.Levels.Comp.L04compcomp
msgid "Complement of a complement"
msgstr "Complementario de un complementario"

#: Game.Levels.Comp.L04compcomp
msgid ""
"How do we prove that two sets `A` and `B` are equal?  One way to do it is to"
" use the theorem\n"
"`Subset.antisymm`.  This theorem is pre-defined in this game; you don't need"
" to prove it.\n"
"If you have `h1 : A âŠ† B` and `h2 : B âŠ† A`, then\n"
"`Subset.antisymm h1 h2` is a proof of `A = B`.  The theorem `Subset.antisymm`"
" says that the\n"
"subset relation has a property called *antisymmetry*.\n"
"\n"
"But what if you don't already know `A âŠ† B` and `B âŠ† A`?  In that case, you"
" can use a new\n"
"tactic, `apply`.  If your goal is `A = B` and you write `apply"
" Subset.antisymm`, then Lean will\n"
"figure out that the theorem `Subset.antisymm` could be applied to prove the"
" goal, if only you had\n"
"proofs of `A âŠ† B` and `B âŠ† A`.  So it will set those *two* statements as"
" goals.\n"
"\n"
"If your goal says that two sets are equal, a good way to begin is with\n"
"`apply Subset.antisymm`.  (Later we'll see a second approach to proving sets"
" are equal.)\n"
"\n"
"This level also introduces another new tactic, `push_neg`."
msgstr ""
"Â¿CÃ³mo demostramos que dos conjuntos `A` y `B` son iguales? Una manera de"
" hacerlo es utilizar el teorema\n"
"`Subset.antisymm`. Este teorema estÃ¡ predefinido en este juego; no necesitas"
" probarlo.\n"
"Si tienes `h1 : A âŠ† B` y `h2 : B âŠ† A`, entonces\n"
"`Subset.antisymm h1 h2` es una prueba de `A = B`. El teorema"
" `Subset.antisymm` dice que la\n"
"relaciÃ³n de subset tiene una propiedad llamada *antisimetrÃ­a*.\n"
"\n"
"Pero Â¿quÃ© pasa si aÃºn no sabes que `A âŠ† B` y `B âŠ† A`? En ese caso, puedes"
" usar una nueva\n"
"tÃ¡ctica, `apply`. Si tu objetivo es `A = B` y escribes `apply"
" Subset.antisymm`, entonces Lean\n"
"verÃ¡ que el teorema `Subset.antisymm` podrÃ­a aplicarse para probar el"
" objetivo, si tuvieras\n"
"pruebas de `A âŠ† B` y `B âŠ† A`. Entonces establecerÃ¡ esos *dos* enunciados como"
" objetivos a demostrar.\n"
"\n"
"Si tu objetivo dice que dos conjuntos son iguales, una buena manera de"
" empezar es con\n"
"`apply Subset.antisymm`. (MÃ¡s tarde veremos un segundo enfoque para probar"
" que los conjuntos son iguales.)\n"
"\n"
"Este nivel tambiÃ©n introduce otra nueva tÃ¡ctica, `push_neg`."

#: Game.Levels.Comp.L04compcomp
msgid ""
"You can use the `apply` tactic to work backwards from the goal.  Suppose you"
" think that you\n"
"will be able to use some theorem `t` to prove the goal.  In other words, you"
" think there\n"
"is a proof of the goal of the form `t ?`, where the question mark needs to be"
" replaced\n"
"with a proof of some statement `P` to which the theorem `t` must be applied. "
" The tactic\n"
"`apply t` will then set `P` as your goal.  If `t` must be applied to more"
" than one proof to\n"
"establish the goal, then `apply t` will set all of the needed proofs as goals."
msgstr ""
"Puedes usar la tÃ¡ctica `apply` para trabajar hacia atrÃ¡s desde el objetivo."
"Supongamos que piensas que podrÃ¡s utilizar algÃºn teorema `t` para probar el"
"objetivo. En otras palabras, crees que hay una prueba del objetivo de la "
"forma `t ?`, donde el signo de interrogaciÃ³n necesita ser reemplazado por "
"una prueba de algÃºn enunciado `P` a la que se le debe aplicar el teorema "
"`t`. La tÃ¡ctica `apply t` entonces establecerÃ¡ `P` como tu objetivo. Si `t` "
"debe aplicarse a mÃ¡s de una prueba para establecer el objetivo, entonces "
"`apply t` establecerÃ¡ todas las pruebas necesarias como objetivos."

#: Game.Levels.Comp.L04compcomp
msgid ""
"If your goal is a negative statement, then the tactic `push_neg` will try to"
" reexpress it as\n"
"an equivalent positive statement.  Similarly, if an assumption `h` is a"
" negative\n"
"statement, then `push_neg at h` will try to reexpress `h`.  Here are some"
" examples of\n"
"reexpressions performed by the `push_neg` tactic:\n"
"* `Â¬Â¬P` is converted to `P`.\n"
"* `Â¬(P âˆ¨ Q)` is converted to `Â¬P âˆ§ Â¬Q`.\n"
"* `Â¬(P âˆ§ Q)` is converted to `P â†’ Â¬Q`.\n"
"* `Â¬(P â†’ Q)` is converted to `P âˆ§ Â¬Q`.\n"
"* `Â¬âˆ€ x, P x` is converted to `âˆƒ x, Â¬P x`.\n"
"* `Â¬âˆƒ x, P x` is converted to `âˆ€ x, Â¬P x`."
msgstr ""
"Si tu objetivo es un enunciado negativo, entonces la tÃ¡ctica `push_neg`"
" intentarÃ¡ reexpresarlo como un enunciado equivalente positivo. De manera"
" similar, si una hipÃ³tesis `h` es un enunciado negativo, entonces `push_neg"
" at h` intentarÃ¡ reexpresar `h`. AquÃ­ hay algunos ejemplos de reexpresiones"
" realizadas por la tÃ¡ctica `push_neg`:\n"
"* `Â¬Â¬P` se convierte en `P`.\n"
"* `Â¬(P âˆ¨ Q)` se convierte en `Â¬P âˆ§ Â¬Q`.\n"
"* `Â¬(P âˆ§ Q)` se convierte en `P â†’ Â¬Q`.\n"
"* `Â¬(P â†’ Q)` se convierte en `P âˆ§ Â¬Q`.\n"
"* `Â¬âˆ€ x, P x` se convierte en `âˆƒ x, Â¬P x`.\n"
"* `Â¬âˆƒ x, P x` se convierte en `âˆ€ x, Â¬P x`."

#: Game.Levels.Comp.L04compcomp
msgid ""
"If you have `h1 : A âŠ† B` and `h2 : B âŠ† A`, then `Subset.antisymm h1 h2` is a"
" proof of `A = B`.\n"
"In Mathlib, the name of this theorem is `Set.Subset.antisymm`."
msgstr ""
"Si tienes `h1 : A âŠ† B` y `h2 : B âŠ† A`, entonces `Subset.antisymm h1 h2` es"
" una prueba de `A = B`.\n"
"En Mathlib, el nombre de este teorema es `Set.Subset.antisymm`."

#: Game.Levels.Comp.L04compcomp
msgid "If `A` is a set, then `compl_compl A` is a proof of `Aá¶œá¶œ = A`."
msgstr ""
"Si `A` es un conjunto, entonces `compl_compl A` es una prueba de `Aá¶œá¶œ = A`."

#: Game.Levels.Comp.L04compcomp
msgid "Suppose $A$ is a set.  Then $(A^c)^c = A$."
msgstr "Supongamos que $A$ es un conjunto. Entonces $(A^c)^c = A$."

#: Game.Levels.Comp.L04compcomp
msgid ""
"In this level, your goal is `Aá¶œá¶œ = A`--that is, the complement of `Aá¶œ` is"
" equal to `A`.\n"
"So `apply Subset.antisymm` is a good way to start."
msgstr ""
"En este nivel, tu objetivo es `Aá¶œá¶œ = A`--eso significa que el complementario"
" de `Aá¶œ` es igual a `A`--.\n"
"AsÃ­ que `apply Subset.antisymm` es una buena manera de empezar."

#: Game.Levels.Comp.L04compcomp
msgid ""
"Your immediate goal now is to prove that `Aá¶œá¶œ âŠ† A`.  Once you close that"
" goal,\n"
"you'll be asked to prove the second goal, `A âŠ† Aá¶œá¶œ`."
msgstr ""
"Tu objetivo inmediato ahora es probar que `Aá¶œá¶œ âŠ† A`. Una vez que cierres "
"ese objetivo, se te pedirÃ¡ probar el segundo objetivo, `A âŠ† Aá¶œá¶œ`."

#: Game.Levels.Comp.L04compcomp
msgid "Now write out the definition of complement in `Â«{h1}Â»`."
msgstr "Ahora escribe la definiciÃ³n de complementario en `Â«{h1}Â»`."

#: Game.Levels.Comp.L04compcomp
msgid ""
"The assumption `Â«{h1}Â»` now says `Â«{x}Â» âˆ‰ Aá¶œ`, which means `Â¬Â«{x}Â» âˆˆ Aá¶œ`.  It"
" will be helpful to\n"
"write out the definition of complement again in this assumption."
msgstr ""
"La suposiciÃ³n `Â«{h1}Â»` ahora dice `Â«{x}Â» âˆ‰ Aá¶œ`, lo que significa `Â¬Â«{x}Â» âˆˆ "
"Aá¶œ`. SerÃ­a Ãºtil escribir de nuevo la definiciÃ³n del complemento en esta "
"suposiciÃ³n."

#: Game.Levels.Comp.L04compcomp
msgid ""
"Now `Â«{h1}Â»` says `Â¬Â«{x}Â» âˆ‰ A`, which means `Â¬Â¬Â«{x}Â» âˆˆ A`.  Of course, this"
" can be simplified to\n"
"`Â«{x}Â» âˆˆ A`.  To perform this simplification, you'll need a new tactic,"
" `push_neg`.  To simplify\n"
"the assumption `Â«{h1}Â»`, write `push_neg at Â«{h1}Â»`."
msgstr ""
"Ahora `Â«{h1}Â»` dice `Â¬Â«{x}Â» âˆ‰ A`, lo que significa `Â¬Â¬Â«{x}Â» âˆˆ A`. Por"
" supuesto, esto se puede simplificar a\n"
"`Â«{x}Â» âˆˆ A`. Para realizar esta simplificaciÃ³n, necesitarÃ¡s una nueva"
" tÃ¡ctica, `push_neg`. Para simplificar la hipÃ³tesis `Â«{h1}Â»`, escribe"
" `push_neg at Â«{h1}Â»`."

#: Game.Levels.Comp.L04compcomp
msgid "The proof of the second goal is similar."
msgstr "La prueba del segundo objetivo es similar."

#: Game.Levels.Comp.L04compcomp
msgid ""
"There are two ways to complete the proof now.  Since your goal is a negative"
" statement,\n"
"one natural strategy to use would be proof by contradiction.  A second"
" possibility is to\n"
"imitate the approach in the first half: write out the meaning of complement"
" again in the goal,\n"
"and then use the `push_neg` tactic to simplify the resulting double-negative"
" goal.  Either\n"
"approach will work."
msgstr ""
"Hay dos formas de completar la prueba ahora. Dado que tu objetivo es un "
"enunciado negativo, una estrategia natural que puedes usar serÃ­a la prueba "
"por contradicciÃ³n. Una segunda posibilidad es imitar el enfoque en la "
"primera mitad: escribe de nuevo el significado del complementario en el "
"objetivo y luego utiliza la tÃ¡ctica `push_neg` para simplificar la doble"
" negaciÃ³n "
"resultante. Cualquiera de los dos enfoques funcionarÃ¡."

#: Game.Levels.Comp.L04compcomp
msgid ""
"The `push_neg` tactic can reexpress a number of different kinds of negative"
" statements as\n"
"equivalent positive statements; use\n"
"`push_neg` to reexpress a negative goal, and `push_neg at h` to reexpress a"
" negative assumption `h`.\n"
"We'll see many more uses of the `apply` tactic in this game.\n"
"For more details about the use of these tactics,\n"
"click on `push_neg` or `apply` under the list of tactics on the right.\n"
"\n"
"We have given this theorem the name `compl_compl`.  Both this theorem and the"
" one in the previous\n"
"level will be useful in the next level."
msgstr ""
"La tÃ¡ctica `push_neg` puede reexpresar distintas declaraciones negativas como"
" positivas; usa\n"
"`push_neg` para reexpresar un objetivo negativo, y `push_neg at h` para"
" reexpresar una suposiciÃ³n negativa `h`.\n"
"Veremos muchos mÃ¡s usos de la tÃ¡ctica `apply` en este juego.\n"
"Para obtener mÃ¡s detalles sobre el uso de estas tÃ¡cticas,\n"
"haz click en `push_neg` o `apply` bajo la lista de tÃ¡cticas a la derecha.\n"
"\n"
"Hemos dado a este teorema el nombre `compl_compl`. Tanto este teorema como el"
" del nivel anterior serÃ¡n Ãºtiles en el siguiente nivel."

#: Game.Levels.Comp.L05compsubiff
msgid "Complement subsets equivalence"
msgstr "Equivalencia de contenido de complementarios"

#: Game.Levels.Comp.L05compsubiff
msgid ""
"In this last level of Complement World, you'll prove a statement of the form"
" `P â†” Q`.  The most\n"
"useful theorem for this purpose is `Iff.intro`.  If you have `h1 : P â†’ Q` and"
" `h2 : Q â†’ P`, then\n"
"`Iff.intro h1 h2` is a proof of `P â†” Q`.  As we saw in the last level, that"
" means you can start your\n"
"proof with `apply Iff.intro`.  Lean will set `P â†’ Q` and `Q â†’ P` as the goals"
" that are needed\n"
"to complete the proof."
msgstr ""
"En este Ãºltimo nivel del mundo de complementarios, demostrarÃ¡s un enunciado "
"dela forma `P â†” Q`. El teorema mÃ¡s Ãºtil para este propÃ³sito es `Iff.intro`. "
"Si tienes `h1 : P â†’ Q` y `h2 : Q â†’ P`, entonces `Iff.intro h1 h2` es una "
"prueba de `P â†” Q`. Como vimos en el Ãºltimo nivel, eso significa que puedes "
"comenzar tu prueba con `apply Iff.intro`. Lean establecerÃ¡ `P â†’ Q` y `Q â†’ P`"
" como los objetivos que deben ser probados para completar la demostraciÃ³n."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"If you have `h1 : P â†’ Q` and `h2 : Q â†’ P`, then `Iff.intro h1 h2` is a proof"
" of `P â†” Q`."
msgstr ""
"Si tienes `h1 : P â†’ Q` y `h2 : Q â†’ P`, entonces `Iff.intro h1 h2` es una "
"prueba de `P â†” Q`."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"Suppose $A$ and $B$ are sets.  Then $A \\subseteq B$ if and only if $B^c "
"\\subseteq A^c$."
msgstr ""
"SupÃ³n que `A` y `B` son conjuntos. Entonces `A` âŠ† `B` si y solo si $B^c "
"\\subseteq A^c$."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"For the proof in this level, `apply Iff.intro` will create the goals `A âŠ† B â†’"
" Bá¶œ âŠ† Aá¶œ`\n"
"and `Bá¶œ âŠ† Aá¶œ â†’ A âŠ† B`."
msgstr ""
"Para la prueba en este nivel, `apply Iff.intro` crearÃ¡ los objetivos `A âŠ† B "
"â†’ Bá¶œ âŠ† Aá¶œ` y `Bá¶œ âŠ† Aá¶œ â†’ A âŠ† B`."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"Of course, you should begin by introducing the assumption\n"
"`h1 : A âŠ† B`."
msgstr ""
"Por supuesto, debes comenzar introduciendo la suposiciÃ³n\n"
"`h1 : A âŠ† B`."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"Fortunately, the theorem `compl_subset_compl_of_subset` can now be used to"
" prove the goal.\n"
"(Click on `compl_subset_compl_of_subset` in the list of theorems on the right"
" if you don't\n"
"remember what the theorem says.)"
msgstr ""
"Por suerte, el teorema `compl_subset_compl_of_subset` puede usarse ahora para"
" probar el objetivo.\n"
"(Haz click en `compl_subset_compl_of_subset` en la lista de teoremas a la"
" derecha si no recuerdas\n"
"quÃ© dice el teorema.)"

#: Game.Levels.Comp.L05compsubiff
msgid "`compl_subset_compl_of_subset Â«{h1}Â»` will prove the goal."
msgstr "`compl_subset_compl_of_subset Â«{h1}Â»` probarÃ¡ el objetivo."

#: Game.Levels.Comp.L05compsubiff
msgid "The second goal is similar, but a little trickier."
msgstr "El segundo objetivo es similar, pero un poquito mÃ¡s difÃ­cil."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"The theorem `compl_subset_compl_of_subset Â«{h1}Â»` doesn't prove the goal,\n"
"but it comes close.  Do you see what assertion it will justify?"
msgstr ""
"El enunciado `compl_subset_compl_of_subset Â«{h1}Â»` no demuestra el\n"
"objetivo, pero se acerca mucho. Â¿Ves quÃ© afirmaciÃ³n justificarÃ¡?"

#: Game.Levels.Comp.L05compsubiff
msgid ""
"You can use `compl_subset_compl_of_subset Â«{h1}Â»` to\n"
"justify the assertion `Aá¶œá¶œ âŠ† Bá¶œá¶œ`."
msgstr ""
"Puedes usar `compl_subset_compl_of_subset Â«{h1}Â»` para justificar "
"laafirmaciÃ³n `Aá¶œá¶œ âŠ† Bá¶œá¶œ`."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"Fortunately, we can use the theorem `compl_compl` to prove `Aá¶œá¶œ = A` and\n"
"`Bá¶œá¶œ = B`, and those statements should get us from `Â«{h2}Â»` to the goal.\n"
"We have seen in previous levels that the `rewrite` tactic can be applied to a"
" proof of a\n"
"statement of the form `P â†” Q` to replace `P` with `Q`.  The tactic can also"
" be applied to\n"
"equations: if `t` is a proof of an equation `p = q`, then `rewrite [t]` will\n"
"replace `p` with `q`."
msgstr ""
"Por suerte, podemos usar el teorema `compl_compl` para probar `Aá¶œá¶œ = A` y"
" `Bá¶œá¶œ = B`, y esos enunciados deberÃ­an llevarnos desde `Â«{h2}Â»` hasta el"
" objetivo.\n"
"Hemos visto en niveles anteriores que la `tÃ¡ctica rewrite` puede aplicarse a"
" una prueba de un enunciado de la forma `P â†” Q` para reemplazar `P` con `Q`."
" La tÃ¡ctica tambiÃ©n puede aplicarse a ecuaciones: si `t` es una prueba de una"
" ecuaciÃ³n `p = q`, entonces `rewrite [t]` reemplazarÃ¡ `p` por `q`."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"`rewrite [compl_compl A] at Â«{h2}Â»` will change `Aá¶œá¶œ` to\n"
"`A`, and `rewrite [compl_compl B] at Â«{h2}Â»` will change `Bá¶œá¶œ` to `B`.  In"
" fact, you can do both\n"
"rewrites in one step:  `rewrite [compl_compl A, compl_compl B] at Â«{h2}Â»`."
msgstr ""
"La tÃ¡ctica `rewrite [compl_compl A] at Â«{h2}Â»` cambiarÃ¡ `Aá¶œá¶œ` por\n"
"`A`, en la hipÃ³tesis `Â«{h2}Â»`, y el comando `rewrite [compl_compl B] at"
" Â«{h2}Â»` cambiarÃ¡ `Bá¶œá¶œ` por\n"
"`B`. De hecho, puedes realizar ambos cambios en un solo paso:\n"
"`rewrite [compl_compl A, compl_compl B] at Â«{h2}Â»`."

#: Game.Levels.Comp.L05compsubiff
msgid ""
"The proof in this level illustrates how previously proven theorems can be"
" used in proofs.\n"
"\n"
"There is another tactic you can use if your goal has the form `P â†” Q`.  In"
" this situation,\n"
"the tactic `constructor` will have the same effect as `apply Iff.intro`; that"
" is, it will\n"
"set `P â†’ Q` and `Q â†’ P` as goals to be proven."
msgstr ""
"La prueba en este nivel ilustra cÃ³mo se pueden utilizar en una prueba"
" teoremas previamente demostrados.\n"
"\n"
"Existe otra tÃ¡ctica que puedes usar si tu objetivo tiene la forma `P â†” Q`. En"
" esta situaciÃ³n,\n"
"la tÃ¡ctica `constructor` tendrÃ¡ el mismo efecto que `apply Iff.intro`; es"
" decir, establecerÃ¡ `P â†’ Q` y `Q â†’ P` como objetivos a ser probados."

#: Game.Levels.Comp
msgid "Complement World"
msgstr "Mundo de los complementarios"

#: Game.Levels.Comp
msgid ""
"If `A` is a set of objects from the universe `U`, then the *complement* of"
" `A`,\n"
"denoted `Aá¶œ`, is the set of all objects in the universe `U` that are *not*\n"
"elements of `A`.\n"
"\n"
"For example, if `U` consists of all people and `A` is the set of people who"
" are more than\n"
"6 feet tall, then `Aá¶œ` is the set of all people who are at most 6 feet tall.\n"
"\n"
"In this world, we'll see how to prove theorems about complements."
msgstr ""
"Si `A` es un conjunto de objetos del universo `U`, entonces el"
" *complementario* de `A`,\n"
"denotado `Aá¶œ`, es el conjunto de todos los objetos en el universo `U` que no"
" son\n"
"elementos de `A`.\n"
"\n"
"Por ejemplo, si `U` consiste en todas las personas y `A` es el conjunto de"
" personas que miden mÃ¡s de 2 metros, entonces `Aá¶œ` es el conjunto de todas"
" las personas que miden a lo sumo 2 metros.\n"
"\n"
"En este mundo, veremos cÃ³mo probar teoremas sobre complementarios."

#: Game.Levels.Inter.L01and
msgid "And"
msgstr "Y"

#: Game.Levels.Inter.L01and
msgid ""
"To work with intersections, we'll need to understand the word \"and\".\n"
"\n"
"If `P` and `Q` are statements, then `P âˆ§ Q` means \"P and Q\".  To enter the\n"
"symbol `âˆ§`, type `\\and`.  For the statement `P âˆ§ Q` to be true, `P` and `Q`"
" must\n"
"both be true.  If you have `h : P âˆ§ Q`--that is, `h` is a proof of\n"
"the statement `P âˆ§ Q`--then in Lean, `h.left` is a proof of `P` and `h.right`"
" is\n"
"a proof of `Q`.  That should be all you need to know to solve this level."
msgstr ""
" Para trabajar con intersecciones, necesitaremos entender la palabra \"y\".\n"
"\n"
"Si `P` y `Q` son enunciados, entonces `P âˆ§ Q` significa \"P y Q\". Para"
" escribir el sÃ­mbolo `âˆ§`, teclea `\\and`. Para que la declaraciÃ³n `P âˆ§ Q` sea"
" verdadera, tanto `P` como `Q` deben ser verdaderos. Si tienes `h : P âˆ§ Q`--"
" es decir, `h` es una prueba del enunciado `P âˆ§ Q`--entonces en Lean,"
" `h.left` es una prueba de `P` y `h.right` es una prueba de `Q`. Eso deberÃ­a"
" ser todo lo que necesitas saber para resolver este nivel."

#: Game.Levels.Inter.L01and
msgid "`P âˆ§ Q` means \"P and Q\".  To enter the symbol `âˆ§`, type `\\and`."
msgstr ""
"`P âˆ§ Q` significa \"P y Q\". Para escribir el sÃ­mbolo `âˆ§`, teclea `\\and`."

#: Game.Levels.Inter.L01and
msgid "Suppose $x \\in A$ and $x \\in B$.  Then $x \\in A$."
msgstr "Supongamos que $x \\in A$ y $x \\in B$. Entonces $x \\in A$."

#: Game.Levels.Inter.L01and
msgid "Now we're ready to start proving theorems about intersections."
msgstr ""
"Ahora estamos listos para comenzar a probar teoremas sobre intersecciones."

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Element of an intersection"
msgstr "Elementos de una intersecciÃ³n"

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid ""
"In this level, we'll need to use the definition of \"intersection\".  The"
" theorem that\n"
"expresses that definition is called `mem_inter_iff`.  If you have `x : U`, `A"
" : Set U`, and\n"
"`B : Set U`, then `mem_inter_iff x A B` is a proof of the statement `x âˆˆ A âˆ©"
" B â†” x âˆˆ A âˆ§ x âˆˆ B`.\n"
"As we saw in Complement World, that means that the tactic `rewrite"
" [mem_inter_iff x A B]` can be\n"
"used to replace `x âˆˆ A âˆ© B` in the goal with `x âˆˆ A âˆ§ x âˆˆ B`.  Usually Lean"
" can figure out\n"
"`x`, `A`, and `B` on its own, so you can just write `rewrite"
" [mem_inter_iff]`, and you can\n"
"use `rewrite [mem_inter_iff] at h` to do the replacement in an assumption `h`"
" rather than\n"
"the goal.\n"
"\n"
"Like `mem_compl_iff`, `mem_inter_iff` can be proven by using the `rfl`"
" tactic.  But we\n"
"won't ask you to prove it; it is pre-defined in this game.  To enter the"
" symbol `âˆ©`, you\n"
"can type `\\inter` or `\\cap`."
msgstr ""
"En este nivel, necesitaremos usar la definiciÃ³n de \"intersecciÃ³n\". El"
" teorema que expresa esa definiciÃ³n se llama `mem_inter_iff`. Si tienes `x :"
" U`, `A : Set U` y `B : Set U`, entonces `mem_inter_iff x A B` es una prueba"
" del enunciado `x âˆˆ A âˆ© B â†” x âˆˆ A âˆ§ x âˆˆ B`. Como vimos en el Mundo de los"
" complementarios, eso significa que la tÃ¡ctica `rewrite [mem_inter_iff x A"
" B]` puede utilizarse para reemplazar `x âˆˆ A âˆ© B` en el objetivo por `x âˆˆ A âˆ§"
" x âˆˆ B`. Por lo general, Lean puede averiguar por sÃ­ mismo `x`, `A` y `B`,"
" asÃ­ que puedes escribir simplemente `rewrite [mem_inter_iff]`, y puedes usar"
" `rewrite [mem_inter_iff] at h` para hacer lo mismo en una hipÃ³tesis `h` en"
" lugar del objetivo.\n"
"\n"
"Al igual que `mem_compl_iff`, `mem_inter_iff` puede probarse utilizando la"
" tÃ¡ctica `rfl`. Pero no te pediremos que lo pruebes; ya estÃ¡ predefinido en"
" este juego. Para escribir el sÃ­mbolo `âˆ©`, puedes teclear `\\inter` o `\\cap`."

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid ""
"If `A` and `B` are sets, then `A âˆ© B` is the intersection of `A` and `B`.\n"
"To enter the symbol `âˆ©`, type `\\inter` or `\\cap`."
msgstr ""
"Si `A` y `B` son conjuntos, entonces `A âˆ© B` es la intersecciÃ³n de `A` y"
" `B`.\n"
"Para escribir el sÃ­mbolo `âˆ©`, teclea `\\inter` o `\\cap`."

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid ""
"If you have `x : U`, `A : Set U`, and `B : Set U`, then `mem_inter_iff x A B`"
" is a proof of the\n"
"statement `x âˆˆ A âˆ© B â†” x âˆˆ A âˆ§ x âˆˆ B`.\n"
"In Mathlib, the name of this theorem is `Set.mem_inter_iff`."
msgstr ""
"Si tienes `x : U`, `A : Set U`, y `B : Set U`, entonces `mem_inter_iff x A B`"
" es una prueba del\n"
"enunciado `x âˆˆ A âˆ© B â†” x âˆˆ A âˆ§ x âˆˆ B`.\n"
"En Mathlib, el nombre de este teorema es `Set.mem_inter_iff`."

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Suppose $x \\in A âˆ© B$.  Then $x \\in B$."
msgstr "Supongamos que $x \\in A \\cap B$. Entonces $x \\in B$."

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid ""
"To start on this proof, try writing out the meaning of intersection in `h`."
msgstr ""
"Para empezar con esta prueba, intenta escribir el significado de "
"intersecciÃ³n en `h`."

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Now your situation is similar to the previous level."
msgstr "Ahora tu situaciÃ³n es similar al nivel anterior."

#: Game.Levels.Inter.L03inter_sub_left
msgid "Intersection is a subset"
msgstr "La intersecciÃ³n estÃ¡ contenida en los conjuntos intersecados."

#: Game.Levels.Inter.L03inter_sub_left
msgid ""
"You should be able to combine ideas from previous levels to solve this one."
msgstr ""
"DeberÃ­as ser capaz de combinar ideas de niveles anteriores para resolver "
"este."

#: Game.Levels.Inter.L03inter_sub_left
msgid "For any sets $A$ and $B$, $A \\cap B \\subseteq A$."
msgstr " Para cualesquiera conjuntos `A` y `B`, `A âˆ© B âŠ† A`."

#: Game.Levels.Inter.L03inter_sub_left
msgid ""
"Since the goal is a subset statement, you should start by\n"
"introducing an object `x` and the assumption that `x âˆˆ A âˆ© B`."
msgstr ""
"Como el objetivo es un enunciado de contenido, debes empezar introduciendoun"
" objeto `x` y la hipÃ³tesis de que `x âˆˆ A âˆ© B`."

#: Game.Levels.Inter.L03inter_sub_left
msgid ""
"You probably used a step like `rewrite [mem_inter_iff] at h` in this proof. "
" That step is\n"
"actually optional.  Writing out the definition of intersection probably helps"
" *you*\n"
"understand how to proceed with the proof, but *Lean* doesn't need to be told"
" to\n"
"write out the definition.  It will do that on its own.  In other words, if"
" you\n"
"have `h : x âˆˆ A âˆ© B`, Lean will accept `h.left` as a proof of `x âˆˆ A`."
msgstr ""
"Probablemente usaste un paso como `rewrite [mem_inter_iff] at h` en esta\n"
"prueba. Ese paso es, de hecho, opcional. Escribir la definiciÃ³n de\n"
"intersecciÃ³n probablemente te ayude a comprender cÃ³mo proceder con la\n"
"prueba, pero *Lean* no necesita saber que escriba la definiciÃ³n. Lo harÃ¡ por\n"
"sÃ­ mismo. En otras palabras, si tienes `h : x âˆˆ A âˆ© B`, Lean aceptarÃ¡`h.left`"
" como una prueba de `x âˆˆ A`."

#: Game.Levels.Inter.L04proveand
msgid "Proving a conjunction"
msgstr "Demostrar una conjunciÃ³n"

#: Game.Levels.Inter.L04proveand
msgid ""
"In this level we'll prove a statement of the form `P âˆ§ Q`.  To do this, we'll"
" need\n"
"another theorem: `And.intro`.  If you have `h1 : P` and `h2 : Q`, then\n"
"`And.intro h1 h2` is a proof of `P âˆ§ Q`."
msgstr ""
"En este nivel demostraremos un enunciado de la forma `P âˆ§ Q`. Para hacer\n"
"esto, necesitaremos otro teorema: `And.intro`. Si tienes `h1 : P` y `h2 :Q`,\n"
"entonces `And.intro h1 h2` es una prueba de `P âˆ§ Q`."

#: Game.Levels.Inter.L04proveand
msgid ""
"If you have `h1 : P` and `h2 : Q`, then `And.intro h1 h2` is a proof of `P âˆ§"
" Q`."
msgstr ""
"Si tienes `h1 : P` y `h2 : Q`, entonces `And.intro h1 h2` es una prueba de "
"`P âˆ§ Q`."

#: Game.Levels.Inter.L04proveand
msgid "Suppose $x \\in A$ and $x \\in B$.  Then $x \\in A \\cap B$."
msgstr "SupÃ³n que $x \\in A$ y $x \\in B$.  Entonces $x \\in A \\cap B$."

#: Game.Levels.Inter.L04proveand
msgid ""
"Writing out the meaning of intersection in the goal will help you see what to"
" do to\n"
"complete this level."
msgstr ""
"Escribir el significado de la intersecciÃ³n en el objetivo te ayudarÃ¡ a ver\n"
"lo que tienes que hacer para completar este nivel."

#: Game.Levels.Inter.L04proveand
msgid "Now you can use `And.intro` to prove the goal."
msgstr "Ahora puedes usar `And.intro` para probar el objetivo."

#: Game.Levels.Inter.L04proveand
msgid "`exact And.intro h1 h2` will close the goal."
msgstr " `exact And.intro h1 h2` cerrarÃ¡ el objetivo."

#: Game.Levels.Inter.L04proveand
msgid ""
"Once again, the use of `rewrite` was not really necessary.  You could prove"
" this\n"
"theorem with the single step `exact And.intro h1 h2`."
msgstr ""
"De nuevo, el uso de `rewrite` no era realmente necesario. Puedes probar\n"
"este teorema con un solo paso usando `exact And.intro h1 h2`."

#: Game.Levels.Inter.L05subint
msgid "Subset of an intersection"
msgstr "Subconjuntos de una intersecciÃ³n"

#: Game.Levels.Inter.L05subint
msgid ""
"Of course, you know by now how to start a proof that one set is a subset of "
"another."
msgstr ""
"Por supuesto, ahora ya sabes como empezar una demostraciÃ³n de que uno estÃ¡ "
"contenido en el otro."

#: Game.Levels.Inter.L05subint
msgid ""
"Suppose $A \\subseteq B$ and $A \\subseteq C$.  Then $A \\subseteq B \\cap C$."
msgstr ""
"SupÃ³n que $A \\subseteq B$ y $A \\subseteq C$. Entonces $A \\subseteq B\\cap"
" C$."

#: Game.Levels.Inter.L05subint
msgid "Writing out the definition of intersection in the goal will help."
msgstr "Escribir la definiciÃ³n de intersecciÃ³n en el objetivo ayudarÃ¡."

#: Game.Levels.Inter.L05subint
msgid ""
"If you had `hB : Â«{x}Â» âˆˆ B` and `hC : Â«{x}Â» âˆˆ C`, then `And.intro hB hC`\n"
"would prove the goal.  So there are two ways to proceed.  One possibility is"
" to use\n"
"`have` to introduce the assumptions `Â«{x}Â» âˆˆ B` and `Â«{x}Â» âˆˆ C`--that is, if"
" you can see\n"
"how to justify those statements!  Then you can use `And.intro` to prove the"
" goal.\n"
"\n"
"The second possibility is to use the `apply` tactic.  Recall that if you"
" write\n"
"`apply And.intro`, then Lean will figure out that the\n"
"theorem `And.intro` could be applied to prove the goal, if only you had"
" proofs of\n"
"`Â«{x}Â» âˆˆ B` and `Â«{x}Â» âˆˆ C`.  So it will set those two statements as goals,"
" to be proven\n"
"one after the other."
msgstr ""
"Si tuvieras `hB : Â«{x}Â» âˆˆ B` y `hC : Â«{x}Â» âˆˆ C`, entonces `And.intro hB hC`\n"
"probarÃ­a el objetivo. AsÃ­ que hay dos maneras de proceder. Una posibilidad es"
" usar\n"
"`have` para introducir las suposiciones `Â«{x}Â» âˆˆ B` y `Â«{x}Â» âˆˆ C` -- si"
" puedes ver\n"
"cÃ³mo justificar esas declaraciones-- Luego puedes usar `And.intro` para"
" probar el objetivo.\n"
"\n"
"La segunda posibilidad es usar la tÃ¡ctica `apply`. Recuerda que si escribes\n"
"`apply And.intro`, entonces Lean se darÃ¡ cuenta de que el\n"
"teorema `And.intro` podrÃ­a aplicarse para probar el objetivo, solo"
" necesitarÃ­as pruebas de\n"
"`Â«{x}Â» âˆˆ B` y `Â«{x}Â» âˆˆ C`. Entonces establecerÃ­a esas dos declaraciones como"
" objetivos, a ser probados uno tras otro."

#: Game.Levels.Inter.L05subint
msgid ""
"Your immediate goal now is to prove that `Â«{x}Â» âˆˆ B`.  Once you close that"
" goal,\n"
"you'll be asked to prove the second goal, `Â«{x}Â» âˆˆ C`."
msgstr ""
"Tu objetivo inmediato ahora es probar que `Â«{x}Â» âˆˆ B`. Una vez que cierres\n"
"ese objetivo, tendrÃ¡s que demostrar el segundo objetivo, `Â«{x}Â» âˆˆ C`."

#: Game.Levels.Inter.L05subint
msgid ""
"In general, if you think that some theorem `t` could be used to prove the"
" goal, the tactic\n"
"`apply t` will work backwards from the goal, setting as new goals any"
" hypotheses that are\n"
"needed for the application of the theorem `t`.\n"
"\n"
"If your goal has the form `P âˆ§ Q`, then the `constructor` tactic will have"
" the same\n"
"effect as `apply And.intro`; that is, it will set `P` and `Q` as goals to be"
" proven."
msgstr ""
"En general, si crees que algÃºn teorema `t` podrÃ­a usarse para probar el"
" objetivo, la tÃ¡ctica\n"
"`apply t` funcionarÃ¡ hacia atrÃ¡s desde el objetivo, estableciendo como nuevos"
" objetivos las hipÃ³tesis que sean necesarias para la aplicaciÃ³n del teorema"
" `t`.\n"
"\n"
"Si tu objetivo tiene la forma `P âˆ§ Q`, entonces la tÃ¡ctica `constructor`"
" tendrÃ¡ el mismo efecto que `apply And.intro`; es decir, establecerÃ¡ `P` y"
" `Q` como objetivos para ser probados."

#: Game.Levels.Inter.L06inter_sub_swap
msgid "Intersection subset of swap"
msgstr "La intersecciÃ³n es subconjunto de la intersecciÃ³n permutada"

#: Game.Levels.Inter.L06inter_sub_swap
msgid ""
"In the next level we're going to prove that intersection is commutative; that"
" is,\n"
"`A âˆ© B = B âˆ© A`.  As a warm-up, in this level we prove `A âˆ© B âŠ† B âˆ© A`."
msgstr ""
"En el siguiente nivel vamos a probar que la intersecciÃ³n es conmutativa; es"
" decir,\n"
"`A âˆ© B = B âˆ© A`. Como calentamiento, en este nivel probaremos `A âˆ© B âŠ† B âˆ© A`."

#: Game.Levels.Inter.L06inter_sub_swap
msgid ""
"For any sets `A` and `B`, `inter_subset_swap A B` is a proof of\n"
"`A âˆ© B âŠ† B âˆ© A`."
msgstr ""
"Para cualesquiera conjuntos `A` y `B`, `inter_subset_swap A B` es una prueba"
" de\n"
"`A âˆ© B âŠ† B âˆ© A`."

#: Game.Levels.Inter.L06inter_sub_swap
msgid "For any sets $A$ and $B$, $A \\cap B \\subseteq B \\cap A$."
msgstr ""
"Para cualesquiera conjuntos `$A$` y `$B$`, `$A \\cap B \\subseteq B \\cap "
"A$`."

#: Game.Levels.Inter.L06inter_sub_swap
msgid ""
"It will help you see how to proceed if you\n"
"write out the definition of intersection in both the assumption Â«{h}Â» and the"
" goal.\n"
"Using the `rewrite` tactic isn't necessary; you can just do the rewriting in\n"
"your head rather than asking Lean to do it.  But if it helps you to figure"
" out the\n"
"proof, go ahead and use the `rewrite` tactic."
msgstr ""
"Te ayudarÃ¡ a ver cÃ³mo proceder si escribes la definiciÃ³n de intersecciÃ³n\n"
"tanto en la hipÃ³tesis Â«{h}Â» como en el objetivo. Usar la tÃ¡ctica `rewrite`\n"
"no es necesario; puedes hacer las sustituciones en tu cabeza en lugar de\n"
"pedirle a Lean que lo haga. Pero si te ayuda a entender la prueba, adelante\n"
"y usa la tÃ¡ctica `rewrite`."

#: Game.Levels.Inter.L06inter_sub_swap
msgid "Now `And.intro Â«{h}Â».right Â«{h}Â».left` proves the goal."
msgstr "Ahora `And.intro Â«{h}Â».right Â«{h}Â».left` prueba el objetivo."

#: Game.Levels.Inter.L06inter_sub_swap
msgid ""
"We have given this theorem the name `inter_subset_swap`.  Thus, from now on,"
" for\n"
"any sets `A` and `B`, `inter_subset_swap A B` is a proof of `A âˆ© B âŠ† B âˆ© A`."
msgstr ""
"Le hemos dado a este teorema el nombre de `inter_subset_swap`. Por lo tanto,"
" desde ahora en adelante, para cualesquiera conjuntos `A` y `B`, "
"`inter_subset_swap A B` es una prueba de `A âˆ© B âŠ† B âˆ© A`."

#: Game.Levels.Inter.L07inter_comm
msgid "Intersection is commutative"
msgstr " La intersecciÃ³n es conmutativa."

#: Game.Levels.Inter.L07inter_comm
msgid ""
"As we saw in Complement World, a good first step when your goal is an"
" equation between\n"
"sets is `apply Subset.antisymm`.  For the theorem in this level, that will"
" leave you with\n"
"two goals: `A âˆ© B âŠ† B âˆ© A` and `B âˆ© A âŠ† A âˆ© B`.  Fortunately, you can prove"
" *both* of these\n"
"goals by using the theorem `inter_subset_swap` from the last level."
msgstr ""
" Como vimos en el Mundo de los complementarios, un buen primer paso cuando "
"tu objetivo es una igualdad entre conjuntos es `apply Subset.antisymm`.  "
"Para el teorema en este nivel, eso te dejarÃ¡ con dos objetivos: `A âˆ© B âŠ† B âˆ©"
" A` y `B âˆ© A âŠ† A âˆ© B`.  Afortunadamente, puedes probar *ambos* estos "
"enunciados utilizando el teorema `inter_subset_swap` del Ãºltimo nivel."

#: Game.Levels.Inter.L07inter_comm
msgid ""
"For any sets `A` and `B`, `inter_comm A B` is a proof of the\n"
"statement `A âˆ© B = B âˆ© A`.  In Mathlib, the name of this theorem is"
" `Set.inter_comm`."
msgstr ""
"Para cualesquiera conjuntos `A` y `B`, `inter_comm A B` es una prueba de\n"
"`A âˆ© B = B âˆ© A`. En Mathlib, el nombre de este teorema es  `Set.inter_comm`."

#: Game.Levels.Inter.L07inter_comm
msgid "For any sets $A$ and $B$, $A \\cap B = B \\cap A$."
msgstr "Para cualesquiera conjuntos `A` y `B`, `A âˆ© B = B âˆ© A`."

#: Game.Levels.Inter.L07inter_comm
msgid "We'll prove one more property of intersections in the next level."
msgstr ""
"Probaremos una propiedad mÃ¡s de las intersecciones en el siguiente nivel."

#: Game.Levels.Inter.L08inter_assoc
msgid "Intersection is associative"
msgstr "La intersecciÃ³n es asociativa"

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"Our goal in this level is again an equation between sets.  In previous proofs"
" of this kind,\n"
"we've started with the tactic `apply Subset.antisymm`, and that would work"
" here as well.\n"
"But we're going to try out an alternative: the tactic `ext`.  This tactic"
" applies the principle\n"
"of *extensionality* for sets, which says that if\n"
"two sets have exactly the same elements, then they are equal."
msgstr ""
"Nuestro objetivo en este nivel es, de nuevo, una ecuaciÃ³n entre conjuntos. En"
" pruebas anteriores de este tipo,\n"
"hemos empezado con la tÃ¡ctica `apply Subset.antisymm`, y eso funcionarÃ­a aquÃ­"
" igual.\n"
"Pero vamos a probar algo diferente: la tÃ¡ctica `ext`. Esta tÃ¡ctica aplica el"
" principio de *extensionalidad* para conjuntos, que dice que si\n"
"dos conjuntos tienen exactamente los mismos elementos, entonces son iguales."

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"For any sets `A`, `B`, and `C`, `inter_assoc A B C` is a proof of the\n"
"statement `(A âˆ© B) âˆ© C = A âˆ© (B âˆ© C)`.  Im Mathlib, the name of this theorem"
" is `Set.inter_assoc`."
msgstr ""
"Para cualesquiera conjuntos `A`, `B` y `C`, `inter_assoc A B C` es una "
"prueba de `(A âˆ© B) âˆ© C = A âˆ© (B âˆ© C)`. En Mathlib, el nombre de este teorema"
" es `Set.inter_assoc`."

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"If your goal is `A = B`, where `A` and `B` are sets, then the tactic `ext x`"
" will introduce\n"
"a new arbitrary object `x` into the proof and set the goal to be `x âˆˆ A â†” x âˆˆ"
" B`."
msgstr ""
"Si tu objetivo es `A = B`, donde `A` y `B` son conjuntos, entonces la tÃ¡ctica"
" `ext x` introducirÃ¡\n"
"un nuevo objeto `x` arbitrario en la prueba y `x âˆˆ A â†” x âˆˆ B` como nuevo"
" objetivo."

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"For any sets $A$, $B$, and $C$, $(A \\cap B) \\cap C = A \\cap (B \\cap C)$."
msgstr ""
" Para cualesquiera conjuntos $A$, $B$ y $C$, $(A \\cap B) \\cap C = A \\cap "
"(B \\cap C)$."

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"Notice that Lean has written the goal as `A âˆ© B âˆ© C = A âˆ© (B âˆ© C)`, with no\n"
"parentheses on the left.  When an intersection of more than two sets is"
" written\n"
"without parentheses, Lean groups the intersections to the left, so this"
" means\n"
"`(A âˆ© B) âˆ© C = A âˆ© (B âˆ© C)`.\n"
"\n"
"To start this proof, use the tactic `ext x`."
msgstr ""
"FÃ­jate en que Lean ha escrito el objetivo como `A âˆ© B âˆ© C = A âˆ© (B âˆ© C)`,"
" sin\n"
"parÃ©ntesis a la izquierda. Cuando se escribe una intersecciÃ³n de mÃ¡s de dos"
" conjuntos\n"
"sin parÃ©ntesis, Lean agrupa las intersecciones hacia la izquierda, asÃ­ que"
" esto significa\n"
"`(A âˆ© B) âˆ© C = A âˆ© (B âˆ© C)`.\n"
"\n"
"Para iniciar esta prueba, use la tÃ¡ctica `ext x`."

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"Notice that Lean has introduced the new object `Â«{x}Â» : U` into the proof,"
" and\n"
"your goal is now `Â«{x}Â» âˆˆ A âˆ© B âˆ© C â†” Â«{x}Â» âˆˆ A âˆ© (B âˆ© C)`.  Proving this"
" goal will show that\n"
"`A âˆ© B âˆ© C` and `A âˆ© (B âˆ© C)` have exactly the same elements, and by the"
" principle of\n"
"extensionality, that will show that the sets are equal."
msgstr ""
"Ten en cuenta que Lean ha introducido el nuevo objeto `Â«{x}Â» : U` en la "
"prueba, y su objetivo ahora es: `Â«{x}Â» âˆˆ A âˆ© B âˆ© C â†” Â«{x}Â» âˆˆ A âˆ© (B âˆ© C)`. "
"Probar este objetivo demostrarÃ¡ que `A âˆ© B âˆ© C` y `A âˆ© (B âˆ© C)` tienen "
"exactamente los mismos elementos, y por el principio de extensionalidad, eso"
" demostrarÃ¡ que los conjuntos son iguales."

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"Since your goal is an \"if and only if\" statement, a good next step\n"
"is `apply Iff.intro`."
msgstr ""
"Dado que tu objetivo es un enunciado \"si y solo si\", un buen siguientepaso"
" es `apply Iff.intro`."

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"Since your goal is an \"if-then\" statement, a good next step\n"
"is `intro h1`."
msgstr ""
" Como tu objetivo es un enunciado  de tipo \"si-entonces\", un buen "
"siguiente paso es `intro h1`."

#: Game.Levels.Inter.L08inter_assoc
msgid ""
"If you're stuck at this point,\n"
"it may help you see how to proceed if you separate\n"
"out the first half of `Â«{h1}Â»` as a separate assumption.\n"
"You can do this with `have hAB : Â«{x}Â» âˆˆ A âˆ© B := Â«{h1}Â».left`."
msgstr ""
"Si te atascas en este punto,\n"
"te puede ser Ãºtil si separar\n"
"la primera mitad de `Â«{h1}Â»` como una suposiciÃ³n separada.\n"
"Puedes hacer esto con `have hAB : Â«{x}Â» âˆˆ A âˆ© B := Â«{h1}Â».left`."

#: Game.Levels.Inter.L08inter_assoc
msgid "Well done!  You're ready to move on to Union World."
msgstr "Â¡Bien hecho! EstÃ¡s listo para pasar al mundo de la uniones."

#: Game.Levels.Inter
msgid "Intersection World"
msgstr "Mundo de las intersecciones"

#: Game.Levels.Inter
msgid ""
"If `A` and `B` are sets, then the *intersection* of `A` and `B`, denoted\n"
"`A âˆ© B`, is the set of elements that the two sets have in common.  In other"
" words,\n"
"for an object to be an element of `A âˆ© B`, it must be an element of both `A`"
" and `B`.\n"
"\n"
"For example, if `A` is the set of all round things, and `B` is the set of all"
" red things,\n"
"then `A âˆ© B` is the set of all round red things.\n"
"\n"
"In this world you'll prove some basic properties of intersections of sets."
msgstr ""
" Si `A` y `B` son conjuntos, entonces la *intersecciÃ³n* de `A` y `B`,"
" denotada por\n"
"`A âˆ© B`, es el conjunto de elementos que los dos conjuntos tienen en comÃºn."
" En otras palabras,\n"
"para que un objeto sea un elemento de `A âˆ© B`, debe ser un elemento tanto de"
" `A` como de `B`.\n"
"\n"
"Por ejemplo, si `A` es el conjunto de todas las cosas redondas y `B` es el"
" conjunto de todas las cosas rojas,\n"
"entonces `A âˆ© B` es el conjunto de todas las cosas redondas rojas.\n"
"\n"
"En este mundo demostrarÃ¡s algunas propiedades bÃ¡sicas de las intersecciones"
" de conjuntos."

#: Game.Levels.Union.L01or
msgid "Or"
msgstr "O"

#: Game.Levels.Union.L01or
msgid ""
"For working with unions, the important logical word is \"or\".\n"
"\n"
"If `P` and `Q` are statements, then `P âˆ¨ Q` means \"P or Q or both\".  To"
" enter the\n"
"symbol `âˆ¨`, type `\\or`.  For the statement `P âˆ¨ Q` to be true, either `P` or"
" `Q` must\n"
"be true.  This gives us two ways to prove a statement of this form.  If you"
" have\n"
"`h : P`, then `Or.inl h` can be used to prove `P âˆ¨ Q`.  If you have `h : Q`,"
" then\n"
"`Or.inr h` proves `P âˆ¨ Q`."
msgstr ""
" Para trabajar con uniones, la palabra lÃ³gica importante es \"o\".\n"
"\n"
"Si `P` y `Q` son enunciados, entonces `P âˆ¨ Q` significa \"P o Q o ambos\". "
" Para escribir el sÃ­mbolo `âˆ¨`, teclea `\\or`.  Para que la declaraciÃ³n `P âˆ¨"
" Q` sea verdadera, se debe cumplir al menos una de las siguientes"
" condiciones: `P` o `Q`.  Esto nos da dos maneras de probar un enunciado de"
" esta forma.  Si tienes `h : P`, entonces `Or.inl h` puede utilizarse para"
" probar `P âˆ¨ Q`.  Si tienes `h : Q`, entonces `Or.inr h` demuestra `P âˆ¨ Q`."

#: Game.Levels.Union.L01or
msgid ""
"`P âˆ¨ Q` means \"P or Q or both\".  To enter the symbol `âˆ¨`, type `\\or`."
msgstr ""
"`P âˆ¨ Q` significa \"P o Q o ambos\". Para escribir el sÃ­mbolo `âˆ¨`, teclea "
"`\\or`."

#: Game.Levels.Union.L01or
msgid ""
"If you have `h : P`, then `Or.inl h` can be used as a proof of `P âˆ¨ Q`, for\n"
"any statement `Q`."
msgstr ""
"Si tienes `h : P`, entonces `Or.inl h` se puede usar como prueba de `P âˆ¨ Q`,"
" para cualquier enunciado `Q`."

#: Game.Levels.Union.L01or
msgid ""
"If you have `h : Q`, then `Or.inr h` can be used as a proof of `P âˆ¨ Q`, for\n"
"any statement `P`."
msgstr ""
"Si tienes `h : Q`, entonces `Or.inr h` puede usarse como una prueba de `P "
"âˆ¨Q`, para cualquier enunciado `P`."

#: Game.Levels.Union.L01or
msgid "Suppose $x \\in A$, and $B$ is any set.  Then $x \\in A âˆ¨ x âˆˆ B$."
msgstr ""
"Supongamos que $x \\in A$, y $B$ es cualquier conjunto. Entonces, $x \\in A "
"âˆ¨ x \\in B$."

#: Game.Levels.Union.L01or
msgid "`Or.inl h` is a proof of the goal."
msgstr "`Or.inl h` es una prueba del objetivo."

#: Game.Levels.Union.L01or
msgid "Now we're ready to start proving theorems about unions."
msgstr "Ahora estamos listos para empezar a probar teoremas sobre uniones."

#: Game.Levels.Union.L02subunion
msgid "Subset of a union"
msgstr "Subconjunto de una uniÃ³n"

#: Game.Levels.Union.L02subunion
msgid ""
"As with complements and intersections, one of the key tools for proving"
" theorems about unions\n"
"is a theorem stating the definition.  If you have `x : U`, `A : Set U`, and"
" `B : Set U`,\n"
"then `mem_union x A B` is a proof of the statement `x âˆˆ A âˆª B â†” x âˆˆ A âˆ¨ x âˆˆ"
" B`.\n"
"That means you can use `rewrite [mem_union]` to write out the definition of\n"
"`x âˆˆ A âˆª B` if it appears in any assumption or the goal.  (The similar"
" theorem about intersections\n"
"was called `mem_inter_iff`.  Why isn't this one called `mem_union_iff`?  I"
" don't know.  The\n"
"naming of theorems in Lean is systematic, but there are occasional surprises.)"
msgstr ""
"Como con los complementarios e intersecciones, una de las herramientas clave"
" para probar los teoremas sobre uniones\n"
"es un teorema que establece la definiciÃ³n. Si tienes `x : U`, `A : Set U` y"
" `B : Set U`,\n"
"entonces `mem_union x A B` es una prueba del enunciado `x âˆˆ A âˆª B â†” x âˆˆ A âˆ¨ x"
" âˆˆ B`.\n"
"Eso significa que puedes usar `rewrite [mem_union]` para escribir la"
" definiciÃ³n de\n"
"`x âˆˆ A âˆª B` si aparece en alguna suposiciÃ³n o el objetivo. (El teorema"
" similar sobre intersecciones\n"
"se llamaba `mem_inter_iff`. Â¿Por quÃ© no se llama a este `mem_union_iff`? No"
" lo sÃ©. La denominaciÃ³n de los teoremas en Lean es sistemÃ¡tica, pero de  vez"
" en cuando hay sorpresas.)"

#: Game.Levels.Union.L02subunion
msgid ""
"If `A` and `B` are sets, then `A âˆª B` is the union of `A` and `B`.\n"
"To enter the symbol `âˆª`, type `\\union`."
msgstr ""
"Si `A` y `B` son conjuntos, entonces `A âˆª B` es la uniÃ³n de `A` y `B`.\n"
"Para escribir el sÃ­mbolo `âˆª`, teclea `\\union`."

#: Game.Levels.Union.L02subunion
msgid ""
"If you have `x : U`, `A : Set U`, and `B : Set U`, then `mem_union x A B` is"
" a proof of the\n"
"statement `x âˆˆ A âˆª B â†” x âˆˆ A âˆ¨ x âˆˆ B`.  In Mathlib, the name of this theorem"
" is `Set.mem_union`."
msgstr ""
"Si tienes `x : U`, `A : Set U`, y `B : Set U`, entonces `mem_union x A B` es"
" una prueba del enunciado `x âˆˆ A âˆª B â†” x âˆˆ A âˆ¨ x âˆˆ B`. En Mathlib, el nombre"
" de este teorema es `Set.mem_union`."

#: Game.Levels.Union.L02subunion
msgid "Suppose $A$ and $B$ are sets.  Then $B \\subseteq A \\cup B$."
msgstr ""
"Supongamos que $A$ y $B$ son conjuntos. Entonces $B \\subseteq A \\cup B$."

#: Game.Levels.Union.L02subunion
msgid ""
"Your goal is a subset statement.\n"
"That should tell you how to get started."
msgstr "Tu objetivo es ver un contenido. Eso deberÃ­a decirte cÃ³mo empezar."

#: Game.Levels.Union.L02subunion
msgid ""
"Writing out the definition of union in the goal should help you see how to "
"proceed."
msgstr ""
"Escribir la definiciÃ³n de uniÃ³n en el objetivo deberÃ­a ayudarte a ver cÃ³mo "
"seguir."

#: Game.Levels.Union.L02subunion
msgid "Next, we'll see how to prove that a union is a subset of another set."
msgstr ""
" A continuaciÃ³n, veremos cÃ³mo probar que una uniÃ³n es un subconjunto de otro"
" conjunto."

#: Game.Levels.Union.L03cases
msgid "Proof by cases"
msgstr "DemostraciÃ³n por casos"

#: Game.Levels.Union.L03cases
msgid ""
"In this proof, we'll need a new proof technique: proof by cases.  And we'll"
" need a new\n"
"tactic to implement that technique in Lean: `cases'`."
msgstr ""
" En esta prueba, necesitaremos una nueva tÃ©cnica de demostraciÃ³n: "
"demostraciÃ³n por casos. Y necesitaremos una nueva tÃ¡ctica para implementar "
"esa tÃ©cnica en Lean: `cases'`."

#: Game.Levels.Union.L03cases
msgid ""
"If `h` is a proof of a statement of the form `P âˆ¨ Q`, then the tactic\n"
"`cases' h with h1 h2` will break your proof into cases.  In case 1, you'll"
" have the new\n"
"assumption `h1 : P`, and in case 2 you'll have `h2 : Q`.  In both cases you"
" have to prove\n"
"the original goal.\n"
"\n"
"The `cases'` tactic has other uses.  In particular, it can be applied to"
" proofs of statements\n"
"that do not have the form `P âˆ¨ Q`.  However, we will not discuss these other"
" uses of the\n"
"`cases'` tactic in this game."
msgstr ""
" Si `h` es una prueba de un enunciado de la forma `P âˆ¨ Q`, entonces la"
" tÃ¡ctica\n"
"`cases' h with h1 h2` dividirÃ¡ tu prueba en casos. En el caso 1, tendrÃ¡s la"
" nueva\n"
"suposiciÃ³n `h1 : P`, y en el caso 2 tendrÃ¡s `h2 : Q`. En ambos casos tienes"
" que probar\n"
"el objetivo original.\n"
"\n"
"La tÃ¡ctica `cases'` tiene otros usos. En particular, puede aplicarse a"
" pruebas de enunciados\n"
"que no tienen la forma `P âˆ¨ Q`. Sin embargo, no discutiremos estos otros usos"
" de la\n"
"tÃ¡ctica `cases'` en este juego."

#: Game.Levels.Union.L03cases
msgid ""
"Suppose $A \\subseteq C$ and $B \\subseteq C$.  Then $A \\cup B \\subseteq C$."
msgstr ""
" Supongamos que $A \\subseteq C$ y $B \\subseteq C$.  Entonces $A \\cup B "
"\\subseteq C$."

#: Game.Levels.Union.L03cases
msgid ""
"Of course, to start a subset proof you need to introduce an object `x` and"
" an\n"
"assumption `h3`."
msgstr ""
"Por supuesto, para empezar una prueba de un contenido necesitas introducir un"
" objeto `x` y una\n"
"hipÃ³tesis `h3`."

#: Game.Levels.Union.L03cases
msgid ""
"To understand the logic of this proof, it will help to write out the"
" definition\n"
"of union in `Â«{h3}Â»`."
msgstr ""
"Para entender la lÃ³gica de esta prueba, ayudarÃ¡ escribir la definiciÃ³n de "
"uniÃ³n en Â«{h3}Â»."

#: Game.Levels.Union.L03cases
msgid ""
"Now the assumption `Â«{h3}Â»` is an \"or\" statement.  The easiest way to use"
" such an\n"
"assumption is to break your proof into cases.  To do this in Lean, use the"
" tactic\n"
"`cases' Â«{h3}Â» with Â«{h3}Â»A Â«{h3}Â»B`."
msgstr ""
"Ahora la hipÃ³tesis `Â«{h3}Â»` es una afirmaciÃ³n de tipo \"o\". La forma mÃ¡s"
" fÃ¡cil de usar tal suposiciÃ³n es dividir tu prueba en casos. Para hacer esto"
" en Lean, usa la tÃ¡ctica\n"
"`cases' Â«{h3}Â» with Â«{h3}Â»A Â«{h3}Â»B`."

#: Game.Levels.Union.L03cases
msgid ""
"Now you have *two* goals.  For the first, the assumption `Â«{x}Â» âˆˆ A âˆ¨ Â«{x}Â» âˆˆ"
" B` has been\n"
"replaced with `Â«{x}Â» âˆˆ A`, and for the second it has been replaced with"
" `Â«{x}Â» âˆˆ B`.  In both\n"
"cases, you must prove `Â«{x}Â» âˆˆ C`.  The two identifiers after `with` in the"
" `cases'` tactic\n"
"are used as the identifiers of the new assumptions in the two cases."
msgstr ""
" Ahora tienes *dos* objetivos. Para el primero, la hipÃ³tesis `Â«{x}Â» âˆˆ A âˆ¨ "
"Â«{x}Â» âˆˆ B` ha sido reemplazada con `Â«{x}Â» âˆˆ A`, y para el segundo ha sido "
"reemplazada con `Â«{x}Â» âˆˆ B`. En ambos casos, debes probar `Â«{x}Â» âˆˆ C`. Los "
"dos identificadores despuÃ©s de `with` en la tÃ¡ctica `cases'` se usan como "
"los identificadores de las nuevas hipÃ³tesis en los dos casos."

#: Game.Levels.Union.L03cases
msgid ""
"Note that Lean also has a `cases` tactic, but the syntax is a little more"
" complicated.\n"
"That's why we have chosen to use the `cases'` tactic.\n"
"\n"
"The `cases'` tactic has other uses.  However, in this game we will be using"
" it only with\n"
"assumptions that are \"or\" statements, to break the proof into cases."
msgstr ""
" Ten en cuenta que Lean tambiÃ©n tiene una tÃ¡ctica `cases`, pero la sintaxis"
" es un poco mÃ¡s complicada. Por eso hemos decidido utilizar la tÃ¡ctica"
" `cases'`.\n"
"La tÃ¡ctica `cases'` tiene otros usos, pero en este juego solo lo utilizaremos"
" con\n"
"hipÃ³tesis de tipo \"o\", para dividir la prueba en casos."

#: Game.Levels.Union.L04union_sub_swap
msgid "Union subset of swap"
msgstr "La uniÃ³n es un subconjunto de la uniÃ³n conmutada"

#: Game.Levels.Union.L04union_sub_swap
msgid ""
"In the next level we're going to prove that union is commutative; that is,\n"
"`A âˆª B = B âˆª A`.  We're going to imitate the approach we used in Intersection"
" World\n"
"to prove that intersection is commutative.  We begin by proving `A âˆª B âŠ† B âˆª"
" A`."
msgstr ""
" En el siguiente nivel vamos a probar que la uniÃ³n es conmutativa; es decir,\n"
"`A âˆª B = B âˆª A`. Vamos a imitar el enfoque que utilizamos en el Mundo de las"
" Intersecciones\n"
"para probar que la intersecciÃ³n es conmutativa. Comenzamos demostrando `A âˆª B"
" âŠ† B âˆª A`."

#: Game.Levels.Union.L04union_sub_swap
msgid ""
"For any sets `A` and `B`, `union_sub_swap A B` is a proof of\n"
"`A âˆª B âŠ† B âˆª A`."
msgstr ""
" Para cualesquiera conjuntos `A` y `B`, `union_sub_swap A B` es una prueba"
" de\n"
"`A âˆª B âŠ† B âˆª A`."

#: Game.Levels.Union.L04union_sub_swap
msgid "For any sets $A$ and $B$, $A \\cup B \\subseteq B \\cup A$."
msgstr " Para cualesquiera conjuntos `A` y `B`, `A âˆª B âŠ† B âˆª A`."

#: Game.Levels.Union.L04union_sub_swap
msgid ""
"It will help you see how to proceed if you\n"
"write out the definition of union in both the assumption `Â«{h}Â»` and the goal."
msgstr ""
"Te puede ser Ãºtil escribir la definiciÃ³n de uniÃ³n tanto en la hipÃ³tesis "
"`Â«{h}Â»` como en el objetivo."

#: Game.Levels.Union.L04union_sub_swap
msgid "The form of the assumption `Â«{h}Â»` now suggests proof by cases."
msgstr "El aspecto de la hipÃ³tesis `Â«{h}Â»` ahora sugiere prueba por casos."

#: Game.Levels.Union.L04union_sub_swap
msgid ""
"You'll be able to use the theorem `union_subset_swap` in the next level to"
" prove\n"
"that union is commutative."
msgstr ""
"En el siguiente nivel podrÃ¡s utilizar el teorema `union_subset_swap` para "
"probar que la uniÃ³n es conmutativa."

#: Game.Levels.Union.L05union_comm
msgid "Union is commutative"
msgstr " La uniÃ³n es conmutativa."

#: Game.Levels.Union.L05union_comm
msgid ""
"If you start your proof with `apply Subset.antisymm`, then you'll be able to"
" use\n"
"the theorem `union_subset_swap` that you proved in the last level."
msgstr ""
" Si comienzas tu prueba con `apply Subset.antisymm`, podrÃ¡s usar\n"
"el teorema `union_subset_swap` que demostraste en el Ãºltimo nivel."

#: Game.Levels.Union.L05union_comm
msgid ""
"For any sets `A` and `B`, `union_comm A B` is a proof of the\n"
"statement `A âˆª B = B âˆª A`.  In Mathlib, the name of this theorem is"
" `Set.union_comm`."
msgstr ""
" Para cualesquiera conjuntos `A` y `B`, `union_comm A B` es una prueba de\n"
"`A âˆª B = B âˆª A`. En Mathlib, el nombre de este teorema es `Set.union_comm`."

#: Game.Levels.Union.L05union_comm
msgid "For any sets $A$ and $B$, $A \\cup B = B \\cup A$."
msgstr " Para cualesquiera conjuntos `A` y `B`, `A âˆª B = B âˆª A`."

#: Game.Levels.Union.L05union_comm
msgid "Next we'll prove the associative law for unions."
msgstr " A continuaciÃ³n probaremos la ley asociativa para las uniones."

#: Game.Levels.Union.L06union_assoc
msgid "Union is associative"
msgstr "La uniÃ³n es asociativa"

#: Game.Levels.Union.L06union_assoc
msgid ""
"Here's an idea that you may find helpful for this proof:\n"
"If you're proving an \"or\" statement and you think you'll be\n"
"able to prove either the left or right side of the statement, then `apply"
" Or.inl` or\n"
"`apply Or.inr` will set the goal to be the left or right side. "
" Alternatively, the tactic\n"
"`left` has the same effect as `apply Or.inl`, and `right` has the same effect"
" as\n"
"`apply Or.inr`.\n"
"\n"
"You can start this proof with either `ext x` or `apply Subset.antisymm`."
msgstr ""
" AquÃ­ tienes una idea que tal vez te sea Ãºtil para esta prueba:\n"
"Si estÃ¡s probando una declaraciÃ³n \"o\" y crees que podrÃ¡s probar\n"
"el lado izquierdo o derecho de la declaraciÃ³n, entonces `apply Or.inl` o\n"
"`apply Or.inr` establecerÃ¡ el lado izquierdo o derecho como objetivo."
" Alternativamente, la tÃ¡ctica\n"
"`left` tiene el mismo efecto que `apply Or.inl`, y `right` tiene el mismo"
" efecto que\n"
"`apply Or.inr`.\n"
"\n"
"Puedes empezar esta prueba con  `ext x` o `apply Subset.antisymm`."

#: Game.Levels.Union.L06union_assoc
msgid ""
"For any sets `A`, `B`, and `C`, `union_assoc A B C` is a proof of the\n"
"statement `(A âˆª B) âˆª C = A âˆª (B âˆª C)`.  In Mathlib, the name of this theorem"
" is `Set.union_assoc`."
msgstr ""
" Para cualesquiera conjuntos `A`, `B` y `C`, `union_assoc A B C` es una "
"prueba del enunciado `(A âˆª B) âˆª C = A âˆª (B âˆª C)`. En Mathlib, el nombre de "
"este teorema es `Set.union_assoc`."

#: Game.Levels.Union.L06union_assoc
msgid ""
"For any sets $A$, $B$, and $C$, $(A \\cup B) \\cup C = A \\cup (B \\cup C)$."
msgstr ""
" Para cualesquiera conjuntos $A$, $B$ y $C$, $(A \\cup B) \\cup C = A \\cup "
"(B \\cup C)$."

#: Game.Levels.Union.L06union_assoc
msgid ""
"Notice that, as with intersections, Lean groups unions to the left, so\n"
"`A âˆª B âˆª C` means `(A âˆª B) âˆª C`."
msgstr ""
" Ten en cuenta que, al igual que con las intersecciones, Lean agrupa uniones"
" a la izquierda, por lo que\n"
"`A âˆª B âˆª C` significa `(A âˆª B) âˆª C`."

#: Game.Levels.Union.L06union_assoc
msgid "Do you know which half of the goal you're going to prove now?"
msgstr " Â¿Sabes quÃ© mitad del objetivo vas a probar ahora?"

#: Game.Levels.Union.L06union_assoc
msgid ""
"You've mastered reasoning about complements, intersections, and unions.  In"
" the next world,\n"
"we'll start mixing them up!"
msgstr ""
" Dominaste el razonamiento sobre complementarios, intersecciones y uniones. "
"Â¡En el prÃ³ximo mundo, empezaremos a combinarlos!"

#: Game.Levels.Union
msgid "Union World"
msgstr "Mundo de las uniones"

#: Game.Levels.Union
msgid ""
"If `A` and `B` are sets, then the *union* of `A` and `B`, denoted\n"
"`A âˆª B`, is the set you get by throwing all the elements of `A` and `B`\n"
"together into one set.  In other words, for an object to be an element of\n"
"`A âˆª B`, it must be an element of either `A` or `B`, or both.\n"
"\n"
"For example, if `A` is the set of all people under 30, and `B` is the set of\n"
"all people over 20, then `A âˆª B` is the set of all people.\n"
"\n"
"In this world you'll prove some basic properties of unions of sets."
msgstr ""
" Si `A` y `B` son conjuntos, entonces la *uniÃ³n* de `A` y `B`, denotada\n"
"`A âˆª B`, es el conjunto que se obtiene al poner todos los elementos de `A` y"
" `B`\n"
"juntos en un solo conjunto. En otras palabras, para que un objeto sea un"
" elemento de\n"
"`A âˆª B`, debe ser un elemento de `A` o de `B`, o de ambos.\n"
"\n"
"Por ejemplo, si `A` es el conjunto de todas las personas menores de 30, y `B`"
" es\n"
"el conjunto de todas las personas mayores de 20, entonces `A âˆª B` es el"
" conjunto de\n"
"todas las personas.\n"
"\n"
"En este mundo demostrarÃ¡s algunas propiedades bÃ¡sicas de uniones de conjuntos."

#: Game.Levels.Combo.L01compunion
msgid "Complement of a union"
msgstr "Complementario de una uniÃ³n"

#: Game.Levels.Combo.L01compunion
msgid ""
"There is more than one way to do the proof in this level.  Since the proof"
" involves complements of\n"
"sets, negative statements will arise in the course of the proof.  This"
" suggests two possible techniques.\n"
"You may be able to use the `push_neg` tactic to reexpress some negative"
" statements as equivalent\n"
"positive statements.  And you may find proof by contradiction useful."
msgstr ""
" Existe mÃ¡s de una forma de realizar la prueba en este nivel. Dado que la"
" prueba implica\n"
"complementarios de conjuntos, aparecerÃ¡n enunciados negativos durante el"
" curso de la prueba.\n"
"Esto sugiere dos posibles tÃ©cnicas.\n"
"Se puede usar la tÃ¡ctica `push_neg` para reexpresar algunos enunciados"
" negativos como equivalentes positivos.\n"
"O se puede usar encontrar la prueba por contradicciÃ³n."

#: Game.Levels.Combo.L01compunion
msgid ""
"For any sets `A` and `B`, `compl_union A B` is a proof of the\n"
"statement `(A âˆª B)á¶œ = Aá¶œ âˆ© Bá¶œ`.  In Mathlib, the name of this theorem is"
" `Set.compl_union`."
msgstr ""
" Para cualesquiera conjuntos `A` y `B`, `compl_union A B` es una prueba de\n"
" `(A âˆª B)á¶œ = Aá¶œ âˆ© Bá¶œ`. En Mathlib, el nombre de este teorema es"
" `Set.compl_union`."

#: Game.Levels.Combo.L01compunion
msgid "For any sets $A$ and $B$, $(A \\cup B)^c = A^c \\cap B^c$."
msgstr ""
" Para cualesquiera conjuntos $A$ y $B$, $(A \\cup B)^c = A^c \\cap B^c$."

#: Game.Levels.Combo.L02compint
msgid "Complement of an intersection"
msgstr "Complementario de una intersecciÃ³n"

#: Game.Levels.Combo.L02compint
msgid ""
"Of course, you could start the proof in this level with either `ext x` or"
" `apply Subset.antisymm`.\n"
"But there is a shorter solution: you can use\n"
"the theorem from the previous level (`compl_union`) to prove the\n"
"theorem in this level.\n"
"\n"
"The trick to get started on this proof is to rewrite `Aá¶œ âˆª Bá¶œ` as `(Aá¶œ âˆª"
" Bá¶œ)á¶œá¶œ`.  As you\n"
"know, `compl_compl (Aá¶œ âˆª Bá¶œ)` is a proof of the theorem `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ = Aá¶œ âˆª"
" Bá¶œ`, and therefore\n"
"`rewrite [compl_compl (Aá¶œ âˆª Bá¶œ)]` could be used to rewrite `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ` as"
" `Aá¶œ âˆª Bá¶œ`; but we\n"
"want to go in the opposite direction, rewriting `Aá¶œ âˆª Bá¶œ` as `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ`."
" To do that, use\n"
"`rewrite [â† compl_compl (Aá¶œ âˆª Bá¶œ)]`. (To enter the left-pointing arrow, type"
" `\\l`.)"
msgstr ""
"Por supuesto, podrÃ­as empezar la prueba en este nivel con `ext x` o `apply"
" Subset.antisymm`.\n"
"Pero hay una soluciÃ³n mÃ¡s corta: puedes utilizar el teorema del nivel"
" anterior (`compl_union`) para probar el\n"
"teorema en este nivel.\n"
"\n"
"El truco para empezar esta prueba es reescribir `Aá¶œ âˆª Bá¶œ` como `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ`."
" Como sabes, `compl_compl (Aá¶œ âˆª Bá¶œ)` es una prueba del teorema `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ ="
" Aá¶œ âˆª Bá¶œ`, y por lo tanto\n"
"`rewrite [compl_compl (Aá¶œ âˆª Bá¶œ)]` podrÃ­a usarse para rewriting `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ`"
" como `Aá¶œ âˆª Bá¶œ`; pero queremos ir en la direcciÃ³n opuesta: reescribir `Aá¶œ âˆª"
" Bá¶œ` como `(Aá¶œ âˆª Bá¶œ)á¶œá¶œ`. Para hacer eso, utiliza\n"
"`rewrite [â† compl_compl (Aá¶œ âˆª Bá¶œ)]`. (Para introducir la flecha hacia la"
" izquierda, escribe `\\l`)."

#: Game.Levels.Combo.L02compint
msgid ""
"For any sets `A` and `B`, `compl_inter A B` is a proof of the\n"
"statement `(A âˆ© B)á¶œ = Aá¶œ âˆª Bá¶œ`.  In Mathlib, the name of this theorem is"
" `Set.compl_inter`."
msgstr ""
"Para cualesquiera conjuntos `A` y `B`, `compl_inter A B` es una prueba del "
"enunciado `(A âˆ© B)á¶œ = Aá¶œ âˆª Bá¶œ`.  En Mathlib, el nombre de este teorema es "
"`Set.compl_inter`."

#: Game.Levels.Combo.L02compint
msgid "For any sets $A$ and $B$, $(A \\cap B)^c = A^c \\cup B^c$."
msgstr ""
"Para cualesquiera conjuntos $A$ y $B$, $(A \\cap B)^c = A^c \\cup B^c$."

#: Game.Levels.Combo.L02compint
msgid "Do you see how you can now use the theorem from the previous level?"
msgstr " Â¿Ves cÃ³mo ahora puedes usar el teorema del nivel anterior?"

#: Game.Levels.Combo.L03inter_distrib_union
msgid "Intersection distributes over union"
msgstr "Distributividad de la intersecciÃ³n sobre la uniÃ³n"

#: Game.Levels.Combo.L03inter_distrib_union
msgid ""
"This proof is longer than previous ones, but it doesn't require any new"
" tactics or theorems.\n"
"Just stick with it and keep applying the ideas from previous levels!"
msgstr ""
"Esta comprobaciÃ³n es mÃ¡s larga que las anteriores, pero no requiere ninguna "
"nueva tÃ¡ctica o teorema. Solo sigue adelante y sigue aplicando las ideas de "
"niveles anteriores."

#: Game.Levels.Combo.L03inter_distrib_union
msgid ""
"For any sets `A`, `B`, and `C`, `inter_distrib_left A B C` is a proof of the\n"
"statement `A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C)`.  In Mathlib, the name of this"
" theorem\n"
"is `Set.inter_distrib_left`."
msgstr ""
"Para cualesquiera conjuntos `A`, `B` y `C`, `inter_distrib_left A B C` es "
"una prueba de `A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© C)`. En Mathlib, el nombre de "
"este teorema es `Set.inter_distrib_left`."

#: Game.Levels.Combo.L03inter_distrib_union
msgid ""
"For any sets $A$, $B$, and $C$, $A \\cap (B \\cup C) = (A \\cap B) \\cup (A "
"\\cap C)$."
msgstr ""
"Para cualesquiera conjuntos `A`, `B`, y `C`, `A âˆ© (B âˆª C) = (A âˆ© B) âˆª (A âˆ© "
"C)`."

#: Game.Levels.Combo.L03inter_distrib_union
msgid ""
"Once again, Lean has left out some parentheses that it regards as"
" unnecessary.\n"
"Lean gives intersection higher precedence than union, so it interprets\n"
"`A âˆ© B âˆª A âˆ© C` as `(A âˆ© B) âˆª (A âˆ© C)`."
msgstr ""
"De nuevo, Lean ha omitido algunos parÃ©ntesis que considera innecesarios.\n"
"Lean da preferencia a la intersecciÃ³n sobre la uniÃ³n, asÃ­ que interpreta\n"
"`A âˆ© B âˆª A âˆ© C` como `(A âˆ© B) âˆª (A âˆ© C)`."

#: Game.Levels.Combo.L03inter_distrib_union
msgid ""
"It may help you see how to proceed if you separate\n"
"out the second half of `Â«{h}Â»` as a separate assumption.\n"
"You can do this with `have Â«{h}Â»BC : Â«{x}Â» âˆˆ B âˆª C := Â«{h}Â».right`."
msgstr ""
"Para ver cÃ³mo proceder, puede ser Ãºtil tener la segunda mitad de `Â«{h}Â»` como"
" una suposiciÃ³n separada.\n"
"Puedes hacer esto con `have Â«{h}Â»BC : Â«{x}Â» âˆˆ B âˆª C := Â«{h}Â».right`."

#: Game.Levels.Combo.L03inter_distrib_union
msgid "Whew!"
msgstr "Â¡Uf!"

#: Game.Levels.Combo.L04union_distrib_inter
msgid "Union distributes over intersection"
msgstr "Distributividad de la uniÃ³n sobre la intersecciÃ³n"

#: Game.Levels.Combo.L04union_distrib_inter
msgid ""
"This is different from the previous theorem--the roles of union and"
" intersection have\n"
"been swapped.\n"
"\n"
"Once again, there is a tricky shortcut: there is a way to use the theorem"
" from the\n"
"previous level to prove this theorem.\n"
"\n"
"But if you don't see the shortcut, you can use a straightforward approach.\n"
"If you made it through the last one, you can do this one too!"
msgstr ""
"Esto es diferente del teorema anterior, se han intercambiado los papeles de"
" la uniÃ³n y la intersecciÃ³n.\n"
"\n"
"De nuevo, hay un truco: hay una manera de usar el teorema del nivel anterior"
" para probar este teorema.\n"
"\n"
"Pero si no ves el atajo, puedes usar un enfoque directo. Si lograste hacerlo"
" con el Ãºltimo, tambiÃ©n puedes hacerlo con este."

#: Game.Levels.Combo.L04union_distrib_inter
msgid ""
"For any sets `A`, `B`, and `C`, `union_distrib_left A B C` is a proof of the\n"
"statement `A âˆª (B âˆ© C) = (A âˆª B) âˆ© (A âˆª C)`.  In Mathlib, the name of this"
" theorem\n"
"is `Set.union_distrib_left`."
msgstr ""
"Para cualesquiera conjuntos `A`, `B` y `C`, `union_distrib_left A B C` es "
"una prueba del enunciado `A âˆª (B âˆ© C) = (A âˆª B) âˆ© (A âˆª C)`. En Mathlib, el "
"nombre de este teorema es `Set.union_distrib_left`."

#: Game.Levels.Combo.L04union_distrib_inter
msgid ""
"For any sets $A$, $B$, and $C$, $A \\cup (B \\cap C) = (A \\cup B) \\cap (A "
"\\cup C)$."
msgstr ""
"Dados tres conjuntos $A$, $B$, y $C$, $A \\cup (B \\cap C) = (A \\cup B) "
"\\cap (A \\cup C)$."

#: Game.Levels.Combo.L04union_distrib_inter
msgid ""
"You might be tempted to use `rewrite [compl_inter]` as your next step.  But\n"
"in this situation, `rewrite [compl_inter]` is ambiguous, because there are\n"
"two ways that the theorem `compl_inter` could be applied to rewrite the goal:"
" `compl_inter B C`\n"
"is a proof of `(B âˆ© C)á¶œ = Bá¶œ âˆª Cá¶œ` and `compl_inter Aá¶œ (B âˆ© C)á¶œ` is a proof"
" of\n"
"`(Aá¶œ âˆ© (B âˆ© C)á¶œ)á¶œ = Aá¶á¶œ âˆª (B âˆ© C)á¶œá¶œ`, and either one of those equations could"
" be used to\n"
"rewrite the goal.  If you say `rewrite [compl_inter]`, then Lean will pick"
" one of those two\n"
"rewriting steps, and it might not pick the one you wanted.  So you'd better"
" say explicitly\n"
"what you want Lean to apply the theorem `compl_inter` to."
msgstr ""
" QuizÃ¡s puedas estar tentado a usar `rewrite [compl_inter]` como tu siguiente"
" paso. Pero en esta situaciÃ³n, `rewrite [compl_inter]` es ambiguo, ya que hay"
" dos maneras en que el teorema `compl_inter` podrÃ­a ser aplicado para"
" reescribir el objetivo: `compl_inter B C` es una prueba de `(B âˆ© C)á¶œ = Bá¶œ âˆª"
" Cá¶œ` y `compl_inter Aá¶œ (B âˆ© C)á¶œ` es una prueba de\n"
"`(Aá¶œ âˆ© (B âˆ© C)á¶œ)á¶œ = Aá¶á¶œ âˆª (B âˆ© C)á¶œá¶œ`, y cualquiera de esas ecuaciones podrÃ­a"
" ser utilizada para\n"
"reescribir el objetivo. Si usas `rewrite [compl_inter]`, entonces Lean"
" elegirÃ¡ uno de esos dos\n"
"pasos de reescritura, y puede que no elija el que querÃ­as. AsÃ­ que es mejor"
" decir explÃ­citamente a que quieres que Lean aplique el teorema `compl_inter`."

#: Game.Levels.Combo.L04union_distrib_inter
msgid "To finish off Combination World, we'll do one more tricky theorem."
msgstr ""
" Para terminar el mundo combinado, haremos un Ãºltimo teorema algo mÃ¡s "
"difÃ­cil."

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "A tricky subset proof"
msgstr "Una prueba mÃ¡s difÃ­cil"

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "This proof is a bit tricky.  But you should know how to get started."
msgstr "Esta prueba es un poco difÃ­cil. Pero deberÃ­as saber como empezar."

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid ""
"Suppose $A \\cup C \\subseteq B \\cup C$ and $A \\cap C \\subseteq B \\cap "
"C$.  Then $A \\subseteq B$."
msgstr "Suponga que `A âˆª C âŠ† B âˆª C` y `A âˆ© C âŠ† B âˆ© C`. Entonces `A âŠ† B`."

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid ""
"Now use `have` to assert that `Â«{x}Â» âˆˆ A âˆª C`.  If you don't see right\n"
"away how to justify this assertion, you can just write `have hAC : Â«{x}Â» âˆˆ A"
" âˆª C` and Lean will\n"
"set `Â«{x}Â» âˆˆ A âˆª C` as your immediate goal.  Once you achieve that goal, Lean"
" will add\n"
"`hAC : Â«{x}Â» âˆˆ A âˆª C` to your list of assumptions, and you can continue with\n"
"the proof of your original goal.  For further details, click on `have` in the"
" list of tactics\n"
"on the right."
msgstr ""
"Ahora usa `have` para afirmar que `Â«{x}Â» âˆˆ A âˆª C`. Si no ves de inmediato "
"cÃ³mo justificar esta afirmaciÃ³n, puedes escribir simplemente `have hAC : "
"Â«{x}Â» âˆˆ A âˆª C` y Lean establecerÃ¡ `Â«{x}Â» âˆˆ A âˆª C` como tu objetivo "
"inmediato. Una vez que hayas logrado ese objetivo, Lean agregarÃ¡ `hAC : "
"Â«{x}Â» âˆˆ A âˆª C` a tu lista de hipÃ³tesis y podrÃ¡s continuar con la prueba de "
"tu objetivo original. Para obtener mÃ¡s detalles, haz clic en `have` en la "
"lista de tÃ¡cticas a la derecha."

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "Use `h1`."
msgstr "Usa `h1`."

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid ""
"Now that you know `Â«{x}Â» âˆˆ B âˆª C`, you can use that\n"
"statement as the basis for breaking your proof into cases."
msgstr ""
"Ahora que sabes `Â«{x}Â» âˆˆ B âˆª C`, puedes usar ese\n"
"enunciado como base para dividir tu prueba en casos."

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "Notice that you haven't used `h2` yet..."
msgstr "FÃ­jate que aÃºn no has utilizado `h2`..."

#: Game.Levels.Combo.L05union_sub_inter_sub
msgid "You've finished Combination World!"
msgstr " Â¡Terminaste el mundo Combinado!"

#: Game.Levels.Combo
msgid "Combination World"
msgstr "Mundo combinado"

#: Game.Levels.Combo
msgid ""
"In this world you'll prove theorems combining complements, intersections, and"
" unions.  For\n"
"the most part, we'll leave you on your own to figure out these proofs."
msgstr ""
"En este mundo tendrÃ¡s que demostrar teoremas combinando complementarios, "
"intersecciones y uniones. Por lo general, te dejaremos solo para que "
"descubras estas pruebas por ti mismo."

#: Game.Levels.FamInter.L01intersub
msgid "Family intersection is subset"
msgstr "La intersecciÃ³n de una familia es un subconjunto"

#: Game.Levels.FamInter.L01intersub
msgid ""
"In mathematical writing, the intersection of the family $F$ is usually"
" denoted $\\bigcap F$.\n"
"In Lean, the intersection of a family `F` is denoted `â‹‚â‚€ F`.  (You can enter"
" the symbol\n"
"`â‹‚â‚€` by typing `\\I0`.)\n"
"\n"
"Suppose we have `F : Set (Set U)` and `x : U`.  Then `x âˆˆ â‹‚â‚€ F` means that"
" for every set `t`, if\n"
"`t` is in `F`, then `x âˆˆ t`.  To write this statement in Lean, we write `âˆ€ t,"
" t âˆˆ F â†’ x âˆˆ t`.\n"
"Lean abbreviates this statement as `âˆ€ t âˆˆ F, x âˆˆ t`.\n"
"The symbol `âˆ€` is called the *universal quantifier*, and you can enter it in"
" Lean by typing\n"
"`\\forall`.  Note that `âˆ€ t, t âˆˆ F â†’ x âˆˆ t` means `âˆ€ t, (t âˆˆ F â†’ x âˆˆ t)`,"
" not\n"
"`(âˆ€ t, t âˆˆ F) â†’ x âˆˆ t`.  In other words, Lean interprets the universal"
" quantifier as applying\n"
"to the entire rest of the statement.  If you want it to apply to less, you"
" have to\n"
"use parentheses to indicate that.\n"
"\n"
"As with other set theory operations, we have a theorem that expresses this"
" definition.  Lean will\n"
"recognize `mem_sInter` as a proof of any statement of the form `x âˆˆ â‹‚â‚€ F â†” âˆ€"
" t âˆˆ F, x âˆˆ t`.\n"
"\n"
"In this level, you'll try out these ideas."
msgstr ""
"En notaciÃ³n matemÃ¡tica, la intersecciÃ³n de la familia $F$ suele denotarse"
" como $\\bigcap F$.\n"
"En Lean, la intersecciÃ³n de una familia `F` se denota `â‹‚â‚€ F`. (Puedes"
" ingresar el sÃ­mbolo\n"
"`â‹‚â‚€` escribiendo `\\I0`.)\n"
"\n"
"Supongamos que tenemos `F : Set (Set U)` y `x : U`. Entonces `x âˆˆ â‹‚â‚€ F`"
" significa que para cada conjunto `t`, si\n"
"`t` estÃ¡ en `F`, entonces `x âˆˆ t`. Para escribir esta declaraciÃ³n en Lean,"
" escribimos `âˆ€ t, t âˆˆ F â†’ x âˆˆ t`.\n"
"Lean abrevia esta declaraciÃ³n como `âˆ€ t âˆˆ F, x âˆˆ t`.\n"
"El sÃ­mbolo `âˆ€` se llama el *cuantificador universal*, y puedes introducirlo"
" en Lean escribiendo\n"
"`\\forall`. Note que `âˆ€ t, t âˆˆ F â†’ x âˆˆ t` significa `âˆ€ t, (t âˆˆ F â†’ x âˆˆ t)`, no\n"
"`(âˆ€ t, t âˆˆ F) â†’ x âˆˆ t`. En otras palabras, Lean interpreta el cuantificador"
" universal como aplicÃ¡ndose al resto de la declaraciÃ³n. Si quieres que se"
" aplique a menos, debes utilizar parÃ©ntesis para indicarlo.\n"
"\n"
"Como con otras operaciones de teorÃ­a de conjuntos, tenemos un teorema que"
" expresa esta definiciÃ³n. Lean reconocerÃ¡ `mem_sInter` como una prueba de"
" cualquier enunciado de la forma `x âˆˆ â‹‚â‚€ F â†” âˆ€ t âˆˆ F, x âˆˆ t`.\n"
"\n"
"En este nivel, trabajaremos estas ideas."

#: Game.Levels.FamInter.L01intersub
msgid ""
"`â‹‚â‚€ F` is the intersection of the family of sets `F`.  To enter the symbol "
"`â‹‚â‚€`, type `\\I0`."
msgstr ""
" `â‹‚â‚€ F` es la intersecciÃ³n de la familia de conjuntos `F`. Para ingresar el "
"sÃ­mbolo `â‹‚â‚€`, escribe `\\I0`."

#: Game.Levels.FamInter.L01intersub
msgid ""
"If `P x` represents a statement about an unspecified object `x`, then `âˆ€ x, P"
" x` means\n"
"\"for all `x`, `P x` is true\".  To enter the symbol `âˆ€`, type `\\forall`."
msgstr ""
"Si `P x` representa un enunciado sobre un objeto no especificado `x`,"
" entonces `âˆ€ x, P x` significa\n"
"\"para todos los `x`, `P x` es verdadero\". Para ingresar el sÃ­mbolo `âˆ€`,"
" teclee `\\forall`."

#: Game.Levels.FamInter.L01intersub
msgid ""
"Lean will recognize `mem_sInter` as a proof of any statement of the form\n"
"`x âˆˆ â‹‚â‚€ F â†” âˆ€ t âˆˆ F, x âˆˆ t`.  In Mathlib, the name of this theorem is"
" `Set.mem_sInter`."
msgstr ""
" Lean reconocerÃ¡ `mem_sInter` como una prueba de cualquier enunciado de la"
" forma\n"
"`x âˆˆ â‹‚â‚€ F â†” âˆ€ t âˆˆ F, x âˆˆ t`. En Mathlib, el nombre de este teorema es"
" `Set.mem_sInter`."

#: Game.Levels.FamInter.L01intersub
msgid ""
"Suppose $F$ is a family of sets and $A \\in F$.  Then $\\bigcap F \\subseteq"
" A$."
msgstr ""
"Supongamos que $F$ es una familia de conjuntos y $A \\in F$. Entonces "
"$\\bigcap F \\subseteq A$."

#: Game.Levels.FamInter.L01intersub
msgid ""
"As usual, you may find it helpful to use the `rewrite` tactic to write out"
" the\n"
"definition of `Â«{x}Â» âˆˆ â‹‚â‚€ F`, using the theorem `mem_sInter`."
msgstr ""
"Como de costumbre, puede que resultar Ãºtil utilizar la tÃ¡ctica `rewrite` "
"para escribir la definiciÃ³n de `Â«{x}Â» âˆˆ â‹‚â‚€ F`, utilizando el teorema "
"`mem_sInter`."

#: Game.Levels.FamInter.L01intersub
msgid ""
"Remember that `Â«{h2}Â» : âˆ€ t âˆˆ F, Â«{x}Â» âˆˆ t` is an abbreviation for\n"
"`Â«{h2}Â» : âˆ€ t, t âˆˆ F â†’ Â«{x}Â» âˆˆ t`.  Since `âˆ€` means \"for all\", `Â«{h2}Â»` can"
" be applied to any\n"
"set--that is, we can plug in any set for `t` in `Â«{h2}Â»`.\n"
"In particular, applying it to the set `A`, we can conclude that `A âˆˆ F â†’"
" Â«{x}Â» âˆˆ A`.\n"
"To apply `Â«{h2}Â»` to `A`, we just write `Â«{h2}Â»` followed by `A`, with a"
" space between them.\n"
"Thus, your next step can be `have Â«{h2}Â»A : A âˆˆ F â†’ Â«{x}Â» âˆˆ A := Â«{h2}Â» A`. "
" You can save yourself\n"
"a little typing by writing `have Â«{h2}Â»A := Â«{h2}Â» A`; Lean will figure out"
" what statement is\n"
"proven by `Â«{h2}Â» A`."
msgstr ""
" Recuerda que `Â«{h2}Â» : âˆ€ t âˆˆ F, Â«{x}Â» âˆˆ t` es una abreviatura de\n"
"`Â«{h2}Â» : âˆ€ t, t âˆˆ F â†’ Â«{x}Â» âˆˆ t`. Dado que `âˆ€` significa \"para todo\","
" `Â«{h2}Â»` puede aplicarse a cualquier\n"
"conjunto, es decir, podemos sustituir cualquier conjunto por `t` en"
" `Â«{h2}Â»`.\n"
"En particular, al aplicarlo al conjunto `A`, podemos concluir que `A âˆˆ F â†’"
" Â«{x}Â» âˆˆ A`.\n"
"Para aplicar `Â«{h2}Â»` a `A`, simplemente escribimos `Â«{h2}Â»` seguido de `A`,"
" con un espacio entre ellos.\n"
"AsÃ­, tu siguiente paso puede ser `have Â«{h2}Â»A : A âˆˆ F â†’ Â«{x}Â» âˆˆ A := Â«{h2}Â»"
" A`. Puedes ahorrarte\n"
"un poco de tecleo escribiendo `have Â«{h2}Â»A := Â«{h2}Â» A`; Lean entenderÃ¡ quÃ©"
" enunciado se prueba con `Â«{h2}Â» A`."

#: Game.Levels.FamInter.L01intersub
msgid ""
"Since we also have `h1 : A âˆˆ F`, you can apply `Â«{h2A}Â»` to `h1` to prove"
" that `Â«{x}Â» âˆˆ A`.\n"
"This means that `Â«{h2A}Â» h1` is a proof of the goal."
msgstr ""
"Como tambiÃ©n tenemos `h1 : A âˆˆ F`, puedes aplicar `Â«{h2A}Â»` a `h1` para "
"probar que `Â«{x}Â» âˆˆ A`. Esto significa que `Â«{h2A}Â» h1` es una prueba del "
"objetivo."

#: Game.Levels.FamInter.L01intersub
msgid ""
"The last two steps could have been combined into one step.  In general, if"
" you have\n"
"`h1 : A âˆˆ F` and `h2 : âˆ€ t âˆˆ F, P t`, where `P t` is some statement about"
" `t`, then `h2 A`\n"
"is a proof of `A âˆˆ F â†’ P A`, and\n"
"applying that proof to `h1` we conclude that `h2 A h1` is a proof of `P A`. "
" For example,\n"
"if you have `h1 : A âˆˆ F` and `h2 : âˆ€ t âˆˆ F, x âˆˆ t`, then `h2 A h1` is a proof"
" of `x âˆˆ A`."
msgstr ""
" Los Ãºltimos dos pasos podrÃ­an haberse combinado en un solo paso. En general,"
" si tienes\n"
"`h1 : A âˆˆ F` y `h2 : âˆ€ t âˆˆ F, P t`, donde `P t` es algÃºn enunciado sobre `t`,"
" entonces `h2 A`\n"
"es una prueba de `A âˆˆ F â†’ P A`, y\n"
"aplicando esa prueba a `h1` concluimos que `h2 A h1` es una prueba de `P A`."
" Por ejemplo,\n"
"si tienes `h1 : A âˆˆ F` y `h2 : âˆ€ t âˆˆ F, x âˆˆ t`, entonces `h2 A h1` es una"
" prueba de `x âˆˆ A`."

#: Game.Levels.FamInter.L02intersubinter
msgid "Intersection of larger family is smaller"
msgstr "La intersecciÃ³n de una familia mÃ¡s grande, es mÃ¡s pequeÃ±a"

#: Game.Levels.FamInter.L02intersubinter
msgid ""
"In this level we have two families of sets, `F` and `G`, with `F âŠ† G`.  That"
" means that\n"
"`â‹‚â‚€ G` is the intersection of a family of sets that includes all the sets in"
" `F`, plus\n"
"perhaps more sets.  You're going to prove that intersecting this larger"
" collection of sets\n"
"leads to a smaller result; more precisely, you're going to prove that `â‹‚â‚€ G âŠ†"
" â‹‚â‚€ F`.\n"
"\n"
"Of course, by now you know how to start a proof that one set is a subset of"
" another."
msgstr ""
" En este nivel tenemos dos familias de conjuntos, `F` y `G`, con `F âŠ† G`."
" Esto significa que\n"
"`â‹‚â‚€ G` es la intersecciÃ³n de una familia de conjuntos que incluye todos los"
" conjuntos en `F`, mÃ¡s\n"
"quizÃ¡s mÃ¡s conjuntos. Vas a probar que intersecar esta colecciÃ³n mÃ¡s grande"
" de conjuntos\n"
"lleva a un resultado mÃ¡s pequeÃ±o; mÃ¡s precisamente, vas a probar que `â‹‚â‚€ G âŠ†"
" â‹‚â‚€ F`.\n"
"\n"
"Por supuesto, ya sabes cÃ³mo empezar una prueba de que un conjunto es un"
" subconjunto de otro."

#: Game.Levels.FamInter.L02intersubinter
msgid ""
"Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\n"
"Then $\\bigcap G \\subseteq \\bigcap F$."
msgstr ""
" Supongamos que $F$ y $G$ son familias de conjuntos y $F \\subseteq G$.\n"
"Entonces $\\bigcap G \\subseteq \\bigcap F $."

#: Game.Levels.FamInter.L02intersubinter
msgid ""
"As usual, if you're not sure how to proceed then writing\n"
"out definitions can help."
msgstr ""
"Como de costumbre, si no sabes cÃ³mo seguir; escribir las definiciones puede "
"ser Ãºtil."

#: Game.Levels.FamInter.L02intersubinter
msgid ""
"Now your goal starts with `âˆ€ t`.  To prove it, you'll need to introduce\n"
"a set `t` into the proof, using the tactic `intro t`.  Recall that the set"
" `t` is\n"
"*arbitrary*--that is, `t` could stand for any set--so whatever we prove about"
" `t` will\n"
"be true for *all* sets `t`."
msgstr ""
" Ahora tu objetivo empieza con `âˆ€ t`.  Para probarlo, necesitarÃ¡s introducir"
" un conjunto `t` en la prueba, utilizando la tÃ¡ctica `intro t`. Recuerda que"
" el conjunto `t` es *arbitrario*--es decir, `t` podrÃ­a representar cualquier"
" conjunto--asÃ­ que lo que demostremos sobre `t` serÃ¡ verdadero para *todos* "
"los conjuntos `t`."

#: Game.Levels.FamInter.L02intersubinter
msgid ""
"Now your goal is an if-then statement; that means `intro` is\n"
"appropriate again, to introduce `Â«{t}Â» âˆˆ F` as a new assumption."
msgstr ""
" Ahora tu objetivo es un enunciado si-entonces; eso significa que `intro` "
"vuelve a ser apropiado para introducir `Â«{t}Â» âˆˆ F` como una nueva hipÃ³tesis."

#: Game.Levels.FamInter.L02intersubinter
msgid ""
"It looks like `Â«{h2}Â»` could get you to the goal, if only\n"
"you knew that `Â«{t}Â» âˆˆ G`.  Can you prove that?"
msgstr ""
"Parece que `Â«{h2}Â»` podrÃ­a llevarte al objetivo si supieras que `Â«{t}Â» âˆˆ G`."
" Â¿Puedes probarlo?"

#: Game.Levels.FamInter.L02intersubinter
msgid ""
"You can now combine `Â«{h2}Â»` and `Â«{h4}Â»` to reach the goal in one step."
msgstr ""
" Ahora puedes combinar `Â«{h2}Â»` y `Â«{h4}Â»` para alcanzar el objetivo en un "
"solo paso."

#: Game.Levels.FamInter.L02intersubinter
msgid "`Â«{h2}Â» Â«{t}Â» Â«{h4}Â»` is now a proof of the goal."
msgstr "`Â«{h2}Â» Â«{t}Â» Â«{h4}Â»` es ahora una prueba del objetivo."

#: Game.Levels.FamInter.L02intersubinter
msgid ""
"You probably used `intro` several times in this proof.  Recall that two"
" `intro` steps in a row\n"
"can be combined into one step.  Click on `intro` in the list of tactics on"
" the right for\n"
"further details."
msgstr ""
" Probablemente usaste `intro` varias veces en esta prueba. Recuerda que dos "
"pasos de `intro` consecutivos pueden combinarse en un solo paso. Haz clic en"
" `intro` en la lista de tÃ¡cticas a la derecha para obtener mÃ¡s detalles."

#: Game.Levels.FamInter.L03interpair
msgid "Intersection of a pair"
msgstr "IntersecciÃ³n de un par"

#: Game.Levels.FamInter.L03interpair
msgid ""
"This level shows that family intersections are a generalization of the"
" intersections\n"
"we studied in Intersection World.  You'll prove that if `A` and `B` are sets,"
" then\n"
"`A âˆ© B` is equal to the intersection of the family of sets that contains just"
" `A` and\n"
"`B` and nothing else.\n"
"\n"
"We'll need notation for the family of sets consisting of just `A` and `B`;"
" we'll denote\n"
"this family by `{A, B}`.  And, as usual, we'll need a theorem stating the"
" definition of\n"
"this notation.  For any `t`, `A`, and `B`, `mem_pair t A B` is a proof of"
" the\n"
"statement `t âˆˆ {A, B} â†” t = A âˆ¨ t = B`."
msgstr ""
" Este nivel muestra que las intersecciones de familias son una generalizaciÃ³n"
" de las intersecciones\n"
"que estudiamos en el mundo de las intersecciones. Vas a probar que si `A` y"
" `B` son conjuntos, entonces\n"
"`A âˆ© B` es igual a la intersecciÃ³n de la familia de conjuntos que contiene"
" solo `A` y\n"
"`B` y nada mÃ¡s.\n"
"\n"
"Necesitaremos notaciÃ³n para la familia de conjuntos consistente solo en `A` y"
" `B`; denotaremos\n"
"a esta familia por `{A, B}`. Y, como de costumbre, necesitaremos un teorema"
" que establezca\n"
"la definiciÃ³n de esta notaciÃ³n. Para cualquier `t`, `A`, y `B`, `mem_pair t A"
" B` es una\n"
"demostraciÃ³n del enunciado `t âˆˆ {A, B} â†” t = A âˆ¨ t = B`."

#: Game.Levels.FamInter.L03interpair
msgid ""
"For any `t`, `A`, and `B`, `mem_pair t A B` is a proof of the statement\n"
"`t âˆˆ {A, B} â†” t = A âˆ¨ t = B`."
msgstr ""
" Para cualquier `t`, `A`, y `B`, `mem_pair t A B` es una prueba del"
" enunciado\n"
"`t âˆˆ {A, B} â†” t = A âˆ¨ t = B`."

#: Game.Levels.FamInter.L03interpair
msgid "Suppose $A$ and $B$ are sets.  Then $A \\cap B = \\bigcap \\{A, B\\}$."
msgstr ""
" Supongamos que $A$ y $B$ son conjuntos. Entonces $A \\cap B = \\bigcap "
"\\{A, B\\}$."

#: Game.Levels.FamInter.L03interpair
msgid ""
"Now that you have `Â«{hA}Â» : Â«{t}Â» = A`, you can use `rewrite [Â«{hA}Â»]` to"
" replace `Â«{t}Â»` with\n"
"`A` in the goal."
msgstr ""
" Ahora que tienes `Â«{hA}Â» : Â«{t}Â» = A`, puedes utilizar `rewrite [Â«{hA}Â»]` "
"para reemplazar `Â«{t}Â»` con `A` en el objetivo."

#: Game.Levels.FamInter.L03interpair
msgid ""
"It would be helpful if you knew that `A âˆˆ {A, B}`.\n"
"You can use `have` to assert it."
msgstr ""
" SerÃ­a Ãºtil tener que `A âˆˆ {A, B}`.\n"
"Puedes utilizar `have` para afirmarlo."

#: Game.Levels.FamInter.L04interunion
msgid "Intersection of a union of families"
msgstr "IntersecciÃ³n de una uniÃ³n de familias"

#: Game.Levels.FamInter.L04interunion
msgid ""
"If `F` and `G` are families of sets, what is `â‹‚â‚€ (F âˆª G)`?  In this level, "
"you'll find out!"
msgstr ""
"Si `F` y `G` son familias de conjuntos, Â¿quÃ© es `â‹‚â‚€ (F âˆª G)`? En este nivel,"
" lo veremos."

#: Game.Levels.FamInter.L04interunion
msgid ""
"Suppose $F$ and $G$ are families of sets.  Then\n"
"$\\bigcap (F \\cup G) = (\\bigcap F) \\cap (\\bigcap G)$."
msgstr ""
"Supongamos que $F$ y $G$ son familias de conjuntos. Entonces\n"
"$\\bigcap (F \\cup G) = (\\bigcap F) \\cap (\\bigcap G)$."

#: Game.Levels.FamInter.L04interunion
msgid ""
"Here's an approach you might try:  If only you had `hFG : Â«{t}Â» âˆˆ F âˆª G`,"
" then\n"
"`Â«{h1}Â» Â«{t}Â» hFG` would prove the goal.  So if you use the tactic `apply"
" Â«{h1}Â» Â«{t}Â»`, Lean\n"
"will figure out that `Â«{h1}Â» Â«{t}Â»` could be applied to a proof of `Â«{t}Â» âˆˆ F"
" âˆª G` to prove\n"
"the goal, and it will therefore set `Â«{t}Â» âˆˆ F âˆª G` as your goal."
msgstr ""
"Este es un enfoque que podrÃ­as probar: si tuvieras `hFG : Â«{t}Â» âˆˆ F âˆª G`,"
" entonces `Â«{h1}Â» Â«{t}Â» hFG` probarÃ­a el objetivo. Entonces, si usas la"
" tÃ¡ctica `apply Â«{h1}Â» Â«{t}Â»`, Lean\n"
"verÃ¡ que `Â«{h1}Â» Â«{t}Â»` podrÃ­a aplicarse a una prueba de `Â«{t}Â» âˆˆ F âˆª G` para"
" probar el objetivo, y por lo tanto establecerÃ¡ `Â«{t}Â» âˆˆ F âˆª G` como su"
" objetivo."

#: Game.Levels.FamInter.L05subinter
msgid "Subset of an intersection"
msgstr "Subconjuntos de una intersecciÃ³n"

#: Game.Levels.FamInter.L05subinter
msgid ""
"If `A` is a set and `F` is a family of sets, under what circumstances is it"
" the case\n"
"that `A âŠ† â‹‚â‚€ F`?  In this level you'll discover the answer to that question."
msgstr ""
" Si `A` es un conjunto y `F` es una familia de conjuntos, Â¿bajo quÃ© "
"circunstancias es cierto que `A âŠ† â‹‚â‚€ F`? En este nivel descubrirÃ¡s la "
"respuesta a esa pregunta."

#: Game.Levels.FamInter.L05subinter
msgid ""
"Suppose $A$ is a set and $F$ is a family of sets.  Then $A$ is a subset of"
" $\\bigcap F$ if\n"
"and only if $A$ is a subset of every element of $F$."
msgstr ""
" Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos. "
"Entonces, $A$ es un subconjunto de $\\bigcap F$ si y solo si $A$ es un "
"subconjunto de cada elemento de $F$."

#: Game.Levels.FamInter.L05subinter
msgid ""
"Notice that the parentheses in the next goal are necessary, to indicate that"
" the universal\n"
"quantifier applies only to the subset statement.  Without the parentheses,"
" Lean would interpret\n"
"the universal quantifier as applying to the entire rest of the statement."
msgstr ""
"FÃ­jate en que los parÃ©ntesis en el siguiente objetivo son necesarios, para "
"indicar que el cuantificador universal aplica solo al enunciado del "
"subconjunto. Sin los parÃ©ntesis, Lean interpretarÃ­a el cuantificador "
"universal como aplicÃ¡ndose al resto de la declaraciÃ³n."

#: Game.Levels.FamInter.L06eltwiseunion
msgid "Intersection of a family of unions"
msgstr "IntersecciÃ³n de una familia de uniones."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"In this level you'll need a new kind of proof by cases.  For any statement"
" `P`, the\n"
"tactic `by_cases h : P` will break the proof into two cases.  In the first"
" case, the new\n"
"assumption `h : P` is added to the list of assumptions, and in second, the"
" new\n"
"assumption `h : Â¬P` is added.  Since `P` must be either true or false, these"
" two cases cover\n"
"all possibilities."
msgstr ""
"En este nivel necesitarÃ¡s un nuevo tipo de prueba por casos. Para cualquier "
"enunciado `P`, la tÃ¡ctica `by_cases h : P` dividirÃ¡ la prueba en dos "
"casos.En el primer caso, se aÃ±ade la nueva suposiciÃ³n `h : P` a la lista de "
"suposiciones y en segundo lugar, se aÃ±ade la nueva suposiciÃ³n `h : Â¬P`. Dado"
" que `P` debe ser verdadero o falso, estos dos casos cubren todas las "
"posibilidades."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"The tactic `by_cases h : P` breaks the proof into two cases.  In the first"
" case, the\n"
"assumption `h : P` is added to the list of assumptions, and in the second"
" case, the\n"
"assumption `h : Â¬P` is added."
msgstr ""
"La tÃ¡ctica `by_cases h : P` divide la prueba en dos casos. En el primer "
"caso, se aÃ±ade la suposiciÃ³n `h : P` a la lista de suposiciones y en el "
"segundo caso, se aÃ±ade la suposiciÃ³n `h : Â¬P`."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"Suppose $A$ is a set, $F$ and $G$ are families of sets, and for every set $s$"
" in $F$,\n"
"$A \\cup s \\in G$.  Then $\\bigcap G \\subseteq A \\cup (\\bigcap F)$."
msgstr ""
" Supongamos que $A$ es un conjunto, y $F$ y $G$ son familias de conjuntos, y"
" para cada conjunto $s$ en $F$,\n"
"$A \\cup s \\in G$.  Entonces $\\bigcap G \\subseteq A \\cup (\\bigcap F)$."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"Writing out the meaning of the goal will make the proof easier to "
"understand."
msgstr ""
"Escribir el significado del objetivo facilitarÃ¡ la comprensiÃ³n de la prueba."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"If `Â«{x}Â» âˆˆ A`, then the goal is easy to prove.  This suggests breaking\n"
"the proof into cases depending on whether or not `Â«{x}Â» âˆˆ A`.  You can do"
" this with the tactic\n"
"`by_cases hA : Â«{x}Â» âˆˆ A`."
msgstr ""
" Si `Â«{x}Â» âˆˆ A`, entonces es fÃ¡cil probar el objetivo. Esto sugiere dividir "
"la prueba en casos segÃºn si `Â«{x}Â» âˆˆ A` o no. Puedes hacerlo con la tÃ¡ctica "
"`by_cases hA : Â«{x}Â» âˆˆ A`."

#: Game.Levels.FamInter.L06eltwiseunion
msgid "The first case is the easy one."
msgstr " El primer caso es el fÃ¡cil."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"For the second case, which half of the goal do you think you should try to"
" prove?\n"
"You can use `apply Or.inl` or `apply Or.inr` (or the equivalent tactics"
" `left` or `right`)\n"
"to specify what goal you're going to prove."
msgstr ""
" Para el segundo caso, Â¿quÃ© mitad del objetivo crees que deberÃ­as intentar"
" probar?\n"
"Puedes usar `apply Or.inl` o `apply Or.inr` (o las tÃ¡cticas equivalentes"
" `left` o `right`)\n"
"para especificar quÃ© objetivo vas a probar."

#: Game.Levels.FamInter.L06eltwiseunion
msgid "Now use `h1`."
msgstr " Ahora usa `h1."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"You haven't used `Â«{h2}Â»` yet.  If you don't see how to use it,\n"
"write out its definition."
msgstr ""
" No has utilizado `Â«{h2}Â»` aÃºn. Si no ves cÃ³mo usarlo,\n"
"escribe su definiciÃ³n."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"Note that you can apply `Â«{h2}Â»` to `(A âˆª Â«{t}Â»)`.\n"
"You'll need to include the parentheses around `A âˆª Â«{t}Â»` when you do that."
msgstr ""
"Ten en cuenta que se puede aplicar `Â«{h2}Â»` a `(A âˆª Â«{t}Â»)`.\n"
"Para ello, debes incluir los parÃ©ntesis alrededor de `A âˆª Â«{t}Â»` cuando lo"
" hagas."

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"Notice that you have contradictory assumptions.  You can prove anything\n"
"from contradictory assumptions.  Do you see how?"
msgstr ""
"FÃ­jate en que tienes suposiciones contradictorias. Puedes probar cualquier "
"cosa a partir de suposiciones contradictorias. Â¿Ves cÃ³mo?"

#: Game.Levels.FamInter.L06eltwiseunion
msgid ""
"You've finished Family Intersection World!  As you might guess, you can also"
" take the union of\n"
"a family of sets.  Can you guess how to define it?  Continue on to Family"
" Union World to see\n"
"if your guess is right."
msgstr ""
"Â¡Terminaste el mundo de las intersecciones de familias! Como probablemente "
"hayas adivinado, tambiÃ©n puedes tomar la uniÃ³n de una familia de conjuntos. "
"Â¿Puedes adivinar cÃ³mo definirla? ContinÃºa en el mundo de la uniÃ³n familiar "
"para ver si aciertas."

#: Game.Levels.FamInter
msgid "Family Intersection World"
msgstr "Mundo de las intersecciones de familias"

#: Game.Levels.FamInter
msgid ""
"So far the elements of all of our sets have been objects in the universe `U`."
"  But\n"
"sets can contain other kinds of objects!  In the next two worlds, we will"
" work with sets whose\n"
"elements are *sets of objects from `U`*.  We will call these *families of"
" sets* from `U`.  To\n"
"indicate that `F` is a family of sets from `U`, we write `F : Set (Set U)`.\n"
"\n"
"For example, suppose `U` contains the people in a certain club, and we want"
" to form a committee\n"
"consisting of five members of the club.  The set of all possible committees"
" is a family\n"
"of sets from `U`.  Each element of this family is a set containing five club"
" members.\n"
"\n"
"Families of sets are sets, and everything you've learned about sets applies"
" to families of sets.\n"
"For example, if you have `F G : Set (Set U)` and `S : Set U`, then"
" `mem_inter_iff S F G` is a proof\n"
"of the statement `S âˆˆ F âˆ© G â†” S âˆˆ F âˆ§ S âˆˆ G`.  Similarly, `mem_union S F G`"
" is a proof of\n"
"`S âˆˆ F âˆª G â†” S âˆˆ F âˆ¨ S âˆˆ G`, and `mem_compl_iff F S` is a proof of `S âˆˆ Fá¶œ â†”"
" S âˆ‰ F`.\n"
"\n"
"In this world we extend the idea of intersections to families of sets.  If"
" `F` is a family of\n"
"sets from `U`, then the *intersection* of the family `F` is the set of all"
" objects from `U`\n"
"that belong to every element of `F`."
msgstr ""
" Hasta ahora, los elementos de todos nuestros conjuntos han sido objetos del"
" universo `U`.  Pero\n"
"los conjuntos pueden contener otros tipos de objetos.  En los dos mundos"
" siguientes, trabajaremos con conjuntos cuyos\n"
"elementos son *conjuntos de objetos de `U`*.  Llamaremos a estos *familias de"
" conjuntos* de `U`.  Para\n"
"indicar que `F` es una familia de conjuntos de `U`, escribimos `F : Set (Set"
" U)`.\n"
"\n"
"Por ejemplo, supongamos que `U` contiene las personas de un cierto club, y"
" queremos formar un comitÃ©\n"
"de cinco miembros del club.  El conjunto de todos los posibles comitÃ©s es una"
" familia\n"
"de conjuntos de `U`.  Cada elemento de esta familia es un conjunto que"
" contiene cinco miembros del club.\n"
"\n"
"Las familias de conjuntos son conjuntos, y todo lo que has aprendido sobre"
" conjuntos se aplica a las familias de conjuntos.\n"
"Por ejemplo, si tienes `F G : Set (Set U)` y `S : Set U`, entonces"
" `mem_inter_iff S F G` es una prueba\n"
"del enunciado `S âˆˆ F âˆ© G â†” S âˆˆ F âˆ§ S âˆˆ G`.  Similarmente, `mem_union S F G`"
" es una prueba de\n"
"`S âˆˆ F âˆª G â†” S âˆˆ F âˆ¨ S âˆˆ G`, y `mem_compl_iff F S` es una prueba de `S âˆˆ Fá¶œ â†”"
" S âˆ‰ F`.\n"
"\n"
"En este mundo extendemos la idea de intersecciones a familias de conjuntos. "
" Si `F` es una familia de\n"
"conjuntos de `U`, entonces la *intersecciÃ³n* de la familia `F` es el conjunto"
" de todos los objetos de `U`\n"
"que pertenecen a cada elemento de `F`."

#: Game.Levels.FamUnion.L01proveexists
msgid "Proving existential statements"
msgstr "Probar enunciados existenciales"

#: Game.Levels.FamUnion.L01proveexists
msgid ""
"To work with unions of families, we'll need to know how to work with"
" existential statements.\n"
"If `P x` is a statement about an unspecified object `x`, then `âˆƒ x, P x`"
" means \"there is\n"
"at least one `x` such that `P x` is true\".  The symbol `âˆƒ` is called the\n"
"*existential quantifier*, and you can enter it in Lean by typing `\\exists`.\n"
"\n"
"The easiest way to prove the statement `âˆƒ x, P x` is to specify a value of"
" `x`, and give a\n"
"proof of `P x` for that value of `x`.  The theorem that allows you to do that"
" is called\n"
"`Exists.intro`.  If you have `h : P a`, for some object `a`, then"
" `Exists.intro a h` is a\n"
"proof of the statement `âˆƒ x, P x`.  (The object `a` is sometimes called a"
" *witness* for\n"
"the existential statement.)  In this level, you'll try out this theorem."
msgstr ""
" Para trabajar con uniones de familias, necesitaremos saber cÃ³mo trabajar con"
" enunciados existenciales.\n"
"Si `P x` es un enunciado acerca de un objeto no especificado `x`, entonces `âˆƒ"
" x, P x` significa \"existe al menos un `x` tal que `P x` es verdadero\". El"
" sÃ­mbolo `âˆƒ` se llama el *cuantificador existencial*, y puedes ingresarlo en"
" Lean escribiendo `\\exists`.\n"
"\n"
"La forma mÃ¡s fÃ¡cil de probar el enunciado `âˆƒ x, P x` es especificar un valor"
" para `x`, y dar una prueba de `P x` para ese valor de `x`. El teorema que"
" permite hacer esto se llama `Exists.intro`. Si tienes `h : P a`, para algÃºn"
" objeto `a`, entonces `Exists.intro a h` es una prueba del enunciado `âˆƒ x, P"
" x`. (El objeto `a` a veces se llama un *testigo* para el enunciado"
" existencial.) En este nivel, intentarÃ¡s probar este teorema."

#: Game.Levels.FamUnion.L01proveexists
msgid ""
"If `P x` represents a statement about `x`, then `âˆƒ x, P x` means \"there is"
" at least one\n"
"`x` such that `P x` is true\".  To enter the symbol `âˆƒ`, type `\\exists`."
msgstr ""
" Si `P x` representa un enunciado sobre `x`, entonces `âˆƒ x, P x` significa"
" \"existe al menos un\n"
"`x` tal que `P x` es verdadero\".  Para ingresar el sÃ­mbolo `âˆƒ`, escribe"
" `\\exists`."

#: Game.Levels.FamUnion.L01proveexists
msgid ""
"If `P x` represents a statement about `x` and you have `h : P a`, for some"
" object `a`, then\n"
"`Exists.intro a h` is a proof of `âˆƒ x, P x`."
msgstr ""
" Si `P x` representa un enunciado sobre `x` y tienes `h : P a`, para algÃºn"
" objeto `a`, entonces\n"
"`Exists.intro a h` es una prueba de `âˆƒ x, P x`."

#: Game.Levels.FamUnion.L01proveexists
msgid ""
"Suppose $A$ is a set.  Then there is some set $S$ such that $S \\subseteq "
"A$."
msgstr ""
" Supongamos que $A$ es un conjunto. Entonces hay algÃºn conjunto $S$ tal que "
"$S \\subseteq A$."

#: Game.Levels.FamUnion.L01proveexists
msgid ""
"Your goal says that there is a set that is a subset of `A`.\n"
"The theorem `Subset.refl` suggests such a set."
msgstr ""
" Tu objetivo indica que hay un conjunto que es un subconjunto de `A`.\n"
"El teorema `Subset.refl` sugiere tal conjunto."

#: Game.Levels.FamUnion.L01proveexists
msgid ""
"Recall that `Subset.refl A` is a proof of `A âŠ† A`.\n"
"So start your proof with `have h : A âŠ† A := Subset.refl A`."
msgstr ""
" Recuerda que `Subset.refl A` es una prueba de `A âŠ† A`.\n"
"AsÃ­ que puedes empezar tu prueba con `have h : A âŠ† A := Subset.refl A`."

#: Game.Levels.FamUnion.L01proveexists
msgid ""
"Although `âˆ…` is a reasonable choice for a set that is a subset of `A`, it is"
" difficult\n"
"to complete the proof with this choice using only methods developed so far in"
" this game.\n"
"Go back and try a different choice."
msgstr ""
" A pesar de que `âˆ…` es una opciÃ³n razonable para un conjunto que es "
"subconjunto de `A`, es difÃ­cil completar la prueba con esta elecciÃ³n usando "
"solo los mÃ©todos desarrollados hasta ahora en este juego. Vuelve atrÃ¡s e "
"intenta una elecciÃ³n diferente."

#: Game.Levels.FamUnion.L01proveexists
msgid "Now you can use `Exists.intro` to complete the proof."
msgstr " Ahora puedes usar `Exists.intro` para completar la prueba."

#: Game.Levels.FamUnion.L01proveexists
msgid "`Exists.intro A Â«{h}Â»` proves the goal."
msgstr "`Exists.intro A Â«{h}Â»` demuestra el objetivo"

#: Game.Levels.FamUnion.L01proveexists
msgid ""
"By the way, another set that would have worked as a witness for the"
" existential goal in this\n"
"theorem is the empty set, denoted `âˆ…`.  However, to justify the use of that"
" witness you would\n"
"have had to prove `âˆ… âŠ† A`.  Since we already have the theorem `Subset.refl`,"
" it was easier to use\n"
"`A` as the witness.\n"
"\n"
"Now that you know how to prove existential statements, you're ready to start"
" working with\n"
"unions of families."
msgstr ""
" Por cierto, otro conjunto que habrÃ­a funcionado como testigo para el"
" objetivo existencial en este\n"
"teorema es el conjunto vacÃ­o, denotado `âˆ…`. Sin embargo, para justificar el"
" uso de ese testigo\n"
"habrÃ­as tenido que probar `âˆ… âŠ† A`. Dado que ya tenemos el teorema"
" `Subset.refl`, fue mÃ¡s fÃ¡cil\n"
"usar `A` como testigo.\n"
"\n"
"Ahora que sabes cÃ³mo probar enunciados existenciales, estÃ¡s listo para"
" comenzar a trabajar con\n"
"uniones de familias."

#: Game.Levels.FamUnion.L02subunion
msgid "Subset of family union"
msgstr "Subconjuntos de la intersecciÃ³n de una familia"

#: Game.Levels.FamUnion.L02subunion
msgid ""
"In mathematical writing, the union of the family $F$ is usually denoted"
" $\\bigcup F$.\n"
"In Lean, the union of a family `F` is denoted `â‹ƒâ‚€ F`.  (You can enter the"
" symbol\n"
"`â‹ƒâ‚€` by typing `\\U0`.)\n"
"\n"
"Suppose we have `F : Set (Set U)` and `x : U`.  Then `x âˆˆ â‹ƒâ‚€ F` means that"
" there is at least\n"
"one set `t` such that `t âˆˆ F` and `x âˆˆ t`.  To write this statement in Lean,"
" we write\n"
"`âˆƒ t, t âˆˆ F âˆ§ x âˆˆ t`.  Lean abbreviates this statement as `âˆƒ t âˆˆ F, x âˆˆ t`.\n"
"\n"
"As with other set theory operations, we have a theorem that expresses this"
" definition.  Lean will\n"
"recognize `mem_sUnion` as a proof of any statement of the form `x âˆˆ â‹ƒâ‚€ F â†” âˆƒ"
" t âˆˆ F, x âˆˆ t`.\n"
"\n"
"In this level, you'll try out these ideas."
msgstr ""
" En la notaciÃ³n matemÃ¡tica, la uniÃ³n de la familia $F$ suele denotarse como $"
" \\bigcup F$.\n"
"En Lean, la uniÃ³n de una familia `F` se denota con `â‹ƒâ‚€ F`. (Puedes ingresar"
" el sÃ­mbolo\n"
"`â‹ƒâ‚€` escribiendo `\\U0`.)\n"
"\n"
"Supongamos que tenemos `F : Set (Set U)` y `x : U`. Entonces, `x âˆˆ â‹ƒâ‚€ F`"
" significa que hay al menos\n"
"un conjunto `t` tal que `t âˆˆ F` y `x âˆˆ t`. Para escribir este enunciado en"
" Lean, escribimos\n"
"`âˆƒ t, t âˆˆ F âˆ§ x âˆˆ t`. Lean abrevia este enunciado como `âˆƒ t âˆˆ F, x âˆˆ t`.\n"
"\n"
"Como con otras operaciones de la teorÃ­a de conjuntos, tenemos un teorema que"
" expresa esta definiciÃ³n. Lean reconocerÃ¡ `mem_sUnion` como una prueba de"
" cualquier declaraciÃ³n del tipo `x âˆˆ â‹ƒâ‚€ F â†” âˆƒ t âˆˆ F, x âˆˆ t`.\n"
"\n"
"En este nivel, probarÃ¡s estas ideas."

#: Game.Levels.FamUnion.L02subunion
msgid ""
"`â‹ƒâ‚€ F` is the union of the family of sets `F`.  To enter the symbol `â‹ƒâ‚€`, "
"type `\\U0`."
msgstr ""
" La expresiÃ³n `â‹ƒâ‚€ F` representa la uniÃ³n de la familia de conjuntos `F`. "
"Para ingresar el sÃ­mbolo `â‹ƒâ‚€`, escribe `\\U0`."

#: Game.Levels.FamUnion.L02subunion
msgid ""
"Lean will recognize `mem_sUnion` as a proof of any statement of the form\n"
"`x âˆˆ â‹ƒâ‚€ F â†” âˆƒ t âˆˆ F, x âˆˆ t`.  In Mathlib, the name of this theorem is"
" `Set.mem_sUnion`."
msgstr ""
" Lean reconocerÃ¡ `mem_sUnion` como una prueba de cualquier enunciado de la "
"forma `x âˆˆ â‹ƒâ‚€ F â†” âˆƒ t âˆˆ F, x âˆˆ t`. En Mathlib, el nombre de este teorema es "
"`Set.mem_sUnion`."

#: Game.Levels.FamUnion.L02subunion
msgid ""
"If your goal is `âˆƒ x, P x`, where `P x` represents some statement about `x`,"
" and `a` is a\n"
"value that could be assigned to `x`, then the tactic `use a` will\n"
"set `P a` to be the goal.  It will then see if this new goal follows easily"
" from your\n"
"assumptions, and if so it will close the goal."
msgstr ""
" Si tu objetivo es `âˆƒ x, P x`, donde `P x` representa alguna afirmaciÃ³n sobre"
" `x`, y `a` es un\n"
"valor que podrÃ­a asignarse a `x`, entonces la tÃ¡ctica `use a` establecerÃ¡ `P"
" a` como objetivo.  Luego verÃ¡ si este nuevo objetivo se sigue fÃ¡cilmente de"
" sus suposiciones, y si es asÃ­, cerrarÃ¡ el objetivo."

#: Game.Levels.FamUnion.L02subunion
msgid ""
"Suppose $F$ is a family of sets and $A \\in F$.  Then $A \\subseteq \\bigcup"
" F$."
msgstr ""
" Supongamos que $F$ es una familia de conjuntos y $A \\in F$. Entonces, $A "
"\\subseteq \\bigcup F$."

#: Game.Levels.FamUnion.L02subunion
msgid ""
"Remember that the goal `âˆƒ t âˆˆ F, Â«{x}Â» âˆˆ t` is an abbreviation for\n"
"`âˆƒ t, t âˆˆ F âˆ§ Â«{x}Â» âˆˆ t`.  As we saw in the last level, we can prove this by"
" coming up with\n"
"a witness--that is, a value for `t` that will make the statement `t âˆˆ F âˆ§"
" Â«{x}Â» âˆˆ t` come out\n"
"true.  Looking at\n"
"`h1` and `Â«{h2}Â»`, it looks like `t = A` would work.  That suggests a way to"
" proceed:\n"
"`Exists.intro A hA` would prove the goal, if `hA` were a proof of `A âˆˆ F âˆ§"
" Â«{x}Â» âˆˆ A`.  In\n"
"other words, if `Exists.intro A` is applied to a proof of `A âˆˆ F âˆ§ Â«{x}Â» âˆˆ"
" A`, then it will\n"
"prove the goal.  So if you use the tactic `apply Exists.intro A`, then Lean"
" will\n"
"set `A âˆˆ F âˆ§ Â«{x}Â» âˆˆ A` as your new goal."
msgstr ""
" Recuerda que el objetivo `âˆƒ t âˆˆ F, Â«{x}Â» âˆˆ t` es una abreviatura para\n"
"`âˆƒ t, t âˆˆ F âˆ§ Â«{x}Â» âˆˆ t`. Como vimos en el Ãºltimo nivel, podemos probar esto"
" creando\n"
"un testigo, es decir, un valor para `t` que haga verdadera la declaraciÃ³n `t"
" âˆˆ F âˆ§ Â«{x}Â» âˆˆ t`.\n"
"Si miramos\n"
"`h1` y `Â«{h2}Â»`, parece que `t = A` funcionarÃ­a. Esto sugiere una forma de"
" proceder:\n"
"`Exists.intro A hA` probarÃ­a el objetivo, si `hA` fuera una prueba de `A âˆˆ F"
" âˆ§ Â«{x}Â» âˆˆ A`. En\n"
"otros tÃ©rminos, si se aplica `Exists.intro A` a una prueba de `A âˆˆ F âˆ§ Â«{x}Â»"
" âˆˆ A`, entonces probarÃ¡\n"
"el objetivo. Por lo tanto, si utilizas la tÃ¡ctica `apply Exists.intro A`,"
" entonces Lean establecerÃ¡\n"
"`A âˆˆ F âˆ§ Â«{x}Â» âˆˆ A` como tu nuevo objetivo."

#: Game.Levels.FamUnion.L02subunion
msgid ""
"There is another tactic you could have used to complete this proof.  Instead"
" of\n"
"`apply Exists.intro A`, you could write `use A`.  The `use` tactic is"
" actually a powerful\n"
"tactic.  Not only does it fill in `A` for `t` in the existential goal, it"
" then tries to\n"
"complete the proof on its own--and in this case, it would have succeeded!"
msgstr ""
" Hay otra tÃ¡ctica que podrÃ­as haber utilizado para completar esta prueba. En"
" lugar de\n"
"`apply Exists.intro A`, podrÃ­as escribir `use A`. La tÃ¡ctica `use` es una"
" tÃ¡ctica muy potente. No solo sustituye `A` como `t` en el objetivo"
" existencial, sino que luego intenta completar la prueba por su cuenta y, en"
" este caso, habrÃ­a tenido Ã©xito!"

#: Game.Levels.FamUnion.L03unionsubunion
msgid "Union of larger family is larger"
msgstr "La uniÃ³n de una familia mÃ¡s grande es mÃ¡s grande."

#: Game.Levels.FamUnion.L03unionsubunion
msgid ""
"In this level we have two families of sets, `F` and `G`, with `F âŠ† G`.  In"
" Family Intersection\n"
"World, you proved that in this situation, `â‹‚â‚€ G âŠ† â‹‚â‚€ F`.  In this level,"
" you'll prove that\n"
"with family unions, it works the other way: `â‹ƒâ‚€ F âŠ† â‹ƒâ‚€ G`.\n"
"\n"
"We'll need a new tactic for this proof.  An assumption of the form `h : âˆƒ x,"
" P x` tells you that\n"
"an object with a certain property exists.  If you have such an assumption,"
" then it is usually\n"
"helpful to introduce a name for such an object.  You can do this with the"
" `obtain` tactic.  If\n"
"you write `obtain âŸ¨w, hwâŸ© := h`, then Lean will introduce a new object `w`"
" and a new assumption\n"
"`hw : P w`.  Thus, the object `w` is a witness for the existential assumption"
" `h`.  Note that\n"
"in the `obtain` tactic, `w` and `hw` must be enclosed in angle brackets: `âŸ¨"
" âŸ©`.  You can\n"
"enter these by typing either `\\<` and `\\>` or `\\langle` and `\\rangle`."
msgstr ""
" En este nivel tenemos dos familias de conjuntos, `F` y `G`, con `F âŠ† G`. En"
" el Mundo de la intersecciÃ³n de familias, demostraste que en esta situaciÃ³n,"
" `â‹‚â‚€ G âŠ† â‹‚â‚€ F`. En este nivel, probarÃ¡s que con uniones de familias, funciona"
" al revÃ©s: `â‹ƒâ‚€ F âŠ† â‹ƒâ‚€ G`.\n"
"\n"
"Necesitaremos una nueva tÃ¡ctica para esta prueba. Una suposiciÃ³n de la forma"
" `h : âˆƒ x, P x` te dice que existe un objeto con cierta propiedad. Si tienes"
" una hipÃ³tesis asÃ­, entonces suele ser Ãºtil introducir un nombre para tal"
" objeto. Lo puedes hacer con la tÃ¡ctica `obtain`. Si escribes `obtain âŸ¨w, hwâŸ©"
" := h`, entonces Lean introducirÃ¡ un nuevo objeto `w` y una nueva suposiciÃ³n"
" `hw : P w`. Por lo tanto, el objeto `w` es un testigo para la suposiciÃ³n"
" existencial `h`. Ten en cuenta que en la tÃ¡ctica `obtain`, `w` y `hw` deben"
" estar encerrados en corchetes angulares: `âŸ¨ âŸ©`. Puedes escribirlos tecleando"
" `\\<` y `\\>` o `\\langle` y `\\rangle`."

#: Game.Levels.FamUnion.L03unionsubunion
msgid ""
"If you have an assumption `h : âˆƒ x, P x`, then the tactic `obtain âŸ¨w, hwâŸ© :="
" h` will\n"
"introduce a new object `w` and a new assumption `hw : P w` into the proof. "
" To enter the\n"
"angle brackets `âŸ¨ âŸ©`, type either `\\<` and `\\>` or `\\langle` and"
" `\\rangle`."
msgstr ""
" Si tienes una suposiciÃ³n `h : âˆƒ x, P x`, entonces la tÃ¡ctica `obtain âŸ¨w, "
"hwâŸ© := h` introducirÃ¡ un nuevo objeto `w` y una nueva suposiciÃ³n `hw : P w` "
"en la prueba. Para ingresar los corchetes angulares `âŸ¨ âŸ©`, teclea  `\\<` y "
"`\\>` o `\\langle` y `\\rangle`."

#: Game.Levels.FamUnion.L03unionsubunion
msgid ""
"Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\n"
"Then $\\bigcup F \\subseteq \\bigcup G$."
msgstr ""
" Supongamos que $F$ y $G$ son familias de conjuntos y $F \\subseteq G$.\n"
"Entonces $\\bigcup F \\subseteq \\bigcup G$."

#: Game.Levels.FamUnion.L03unionsubunion
msgid ""
"The assumption `Â«{h2}Â»` is now an existential statement.  Thus, `obtain âŸ¨s,"
" hsâŸ© := Â«{h2}Â»`\n"
"will introduce a new object `s` and a new assumption `hs : s âˆˆ F âˆ§ Â«{x}Â» âˆˆ s`"
" into the proof.\n"
"Once the witness `s` has been introduced, the assumption `Â«{h2}Â»` becomes"
" redundant, so it is\n"
"deleted."
msgstr ""
" La suposiciÃ³n Â«{h2}Â» ahora es un enunciado existencial. Por lo tanto,"
" `obtain âŸ¨s, hsâŸ© := Â«{h2}Â»`\n"
"introducirÃ¡ un nuevo objeto `s` y una nueva hipÃ³tesis `hs : s âˆˆ F âˆ§ Â«{x}Â» âˆˆ"
" s` en la prueba.\n"
"Una vez que se ha introducido el testigo `s`, la suposiciÃ³n Â«{h2}Â» se vuelve"
" redundante, por lo que se elimina."

#: Game.Levels.FamUnion.L03unionsubunion
msgid ""
"Do you see why `Â«{s}Â»` is the value to use as a witness for `t` in the goal?\n"
"Your next step can be either `apply Exists.intro Â«{s}Â»` or `use Â«{s}Â»`."
msgstr ""
" Â¿Ves por quÃ© `Â«{s}Â»` es el valor que se debe usar como testigo para `t` en"
" el objetivo?\n"
"Tu siguiente paso puede ser `apply Exists.intro Â«{s}Â»` o `use Â«{s}Â»`."

#: Game.Levels.FamUnion.L04unionpair
msgid "Union of a pair"
msgstr "UniÃ³n de un par"

#: Game.Levels.FamUnion.L04unionpair
msgid ""
"In this level, you'll show that, as with intersections, family unions"
" generalize the\n"
"unions we studied in Union World."
msgstr ""
" En este nivel, demostrarÃ¡s que, al igual que con las intersecciones, las "
"uniones de familias generalizan las uniones que estudiamos en el mundo de "
"las uniones."

#: Game.Levels.FamUnion.L04unionpair
msgid "Suppose $A$ and $B$ are sets.  Then $A \\cup B = \\bigcup \\{A, B\\}$."
msgstr ""
" Supongamos que $A$ y $B$ son conjuntos. Entonces $A \\cup B = \\bigcup "
"\\{A, B\\}$."

#: Game.Levels.FamUnion.L04unionpair
msgid ""
"Remember, you can use `obtain` to introduce a name for the set that is"
" asserted to\n"
"exist in `Â«{h1}Â»`."
msgstr ""
" Recuerda que puedes usar `obtain` para introducir un nombre para el "
"conjunto que `Â«{h1}Â»` afirma que existe."

#: Game.Levels.FamUnion.L05unionunion
msgid "Union of a union"
msgstr "UniÃ³n de una uniÃ³n"

#: Game.Levels.FamUnion.L05unionunion
msgid ""
"In this level, `F` and `G` are families of sets, and you'll work out how `â‹ƒâ‚€"
" (F âˆª G)` is related\n"
"to `â‹ƒâ‚€ F` and `â‹ƒâ‚€ G`."
msgstr ""
" En este nivel, `F` y `G` son familias de conjuntos, y tendrÃ¡s que averiguar"
" cÃ³mo se relaciona `â‹ƒâ‚€ (F âˆª G)` con `â‹ƒâ‚€ F` y `â‹ƒâ‚€ G`."

#: Game.Levels.FamUnion.L05unionunion
msgid ""
"Suppose $F$ and $G$ are families of sets.  Then $\\bigcup (F \\cup G) =\n"
"(\\bigcup F) \\cup (\\bigcup G)$."
msgstr ""
" Supongamos que $F$ y $G$ son familias de conjuntos. Entonces, $ \\bigcup (F"
" \\cup G) = (\\bigcup F) \\cup (\\bigcup G)$."

#: Game.Levels.FamUnion.L06unionsub
msgid "Union subset of a set"
msgstr "La uniÃ³n como subconjunto de un conjunto"

#: Game.Levels.FamUnion.L06unionsub
msgid ""
"Suppose `A` is a set and `F` is a family of sets.  In this level you'll"
" determine the conditions\n"
"under which `â‹ƒâ‚€ F` is a subset of `A`."
msgstr ""
" Supongamos que `A` es un conjunto y que `F` es una familia de conjuntos. En"
" este nivel, determinarÃ¡s las condiciones bajo las cuales `â‹ƒâ‚€ F` es un "
"subconjunto de `A`."

#: Game.Levels.FamUnion.L06unionsub
msgid ""
"Suppose $A$ is a set and $F$ is a family of sets.  Then $\\bigcup F$ is a"
" subset of $A$\n"
"if and only if every element of $F$ is a subset of $A$."
msgstr ""
" Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos."
" Entonces $bigcup F$ es un subconjunto de $A$\n"
"si y solo si cada elemento de $F$ es un subconjunto de $A$."

#: Game.Levels.FamUnion.L06unionsub
msgid ""
"Notice that `Â«{h1}Â»` could be applied to a proof of `Â«{x}Â» âˆˆ â‹ƒâ‚€ F` to\n"
"prove the goal.  That means that `apply Â«{h1}Â»` will set `Â«{x}Â» âˆˆ â‹ƒâ‚€ F` as"
" the goal."
msgstr ""
" FÃ­jese que `Â«{h1}Â»` se puede aplicar a una prueba de `Â«{x}Â» âˆˆ â‹ƒâ‚€ F` para "
"probar el objetivo. Eso significa que `apply Â«{h1}Â»` establecerÃ¡ `Â«{x}Â» âˆˆ â‹ƒâ‚€"
" F` como el objetivo."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Union of a family of intersections"
msgstr "UniÃ³n de una familia de intersecciones"

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"In this level, we introduce another way to define sets.  If `P x` is a"
" statement about an\n"
"unspecified object `x`, then `{x | P x}` denotes the set of all values of `x`"
" that make `P x`\n"
"come out true.  This is often called *set-builder notation*.  For example,\n"
"`{x | x âˆˆ A âˆ§ x âˆˆ B}` is another way to write `A âˆ© B`.\n"
"\n"
"As usual, we have a theorem that states the meaning of set-builder notation. "
" Lean will\n"
"recognize `mem_setOf` as a proof of any statement of the form `a âˆˆ {x | P x}"
" â†” P a`.\n"
"And that means that `rewrite [mem_setOf]` will rewrite `a âˆˆ {x | P x}` as `P"
" a`."
msgstr ""
" En este nivel, introducimos otra forma de definir conjuntos. Si `P x` es un"
" enunciado sobre un objeto no especificado `x`, entonces `{x | P x}` denota"
" el conjunto de todos los valores de `x` que hacen que `P x` sea verdadero."
" Esto a menudo se llama *notaciÃ³n constructora de conjuntos*. Por ejemplo,\n"
"`{x | x âˆˆ A âˆ§ x âˆˆ B}` es otra forma de escribir `A âˆ© B`.\n"
"\n"
"Como de costumbre, tenemos un teorema que establece el significado de la"
" notaciÃ³n constructora de conjuntos. Lean reconocerÃ¡ `mem_setOf` como una"
" prueba de cualquier enunciado de la forma `a âˆˆ {x | P x} â†” P a`. Y eso"
" significa que `rewrite [mem_setOf]` reescribirÃ¡ `a âˆˆ {x | P x}` como `P a`."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"Lean will recognize `mem_setOf` as a proof of any statement of the form\n"
"`a âˆˆ {x | P x} â†” P a`.  In Mathlib, the name of this theorem is"
" `Set.mem_setOf`."
msgstr ""
" Lean reconocerÃ¡ `mem_setOf` como una prueba de cualquier enunciado de la"
" forma\n"
"`a âˆˆ {x | P x} â†” P a`. En Mathlib, el nombre de este teorema es"
" `Set.mem_setOf`."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"Suppose $A$ is a set and $F$ is a family of sets.  Then $A \\cap (\\bigcup F)"
" =\n"
"\\bigcup\\{s \\mid \\exists u \\in F, s = A \\cap u\\}$."
msgstr ""
" Supongamos que $A$ es un conjunto y $F$ es una familia de conjuntos."
" Entonces $A \\cap (\\bigcup F) =\n"
"\\bigcup\\{s \\mid \\exists u \\in F, s = A \\cap u\\}$."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"It will help to get as much information as you can out of `Â«{h1}Â»`\n"
"before addressing the goal."
msgstr ""
"Te serÃ¡ Ãºtil obtener tanta informaciÃ³n como puedas de `Â«{h1}Â»` antes de "
"abordar el objetivo."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"You may find it useful to separate out the right half of `Â«{h1}Â»`.\n"
"You can do that with `have Â«{h1}Â»r := Â«{h1}Â».right`."
msgstr ""
" Puede que le resulte Ãºtil separar la mitad derecha de `Â«{h1}Â»`.\n"
"Puede hacerlo con `have Â«{h1}Â»r := Â«{h1}Â».derecha`."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"Your goal is an existential statement.  Do you see what value to use as a "
"witness?"
msgstr ""
" Tu objetivo es un enunciado existencial. Â¿Ves quÃ© valor usar como testigo?"

#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Try `apply Exists.intro (A âˆ© Â«{t}Â»)` or `use A âˆ© Â«{t}Â»`."
msgstr " Intenta `apply Exists.intro (A âˆ© Â«{t}Â»)` o `use A âˆ© Â«{t}Â»`."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"Your goal is an existential statement.  Do you see what value to use as a "
"witness?"
msgstr ""
" Tu objetivo es un enunciado existencial. Â¿Ves quÃ© valor usar como testigo?"

#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Try `apply Exists.intro (A âˆ© Â«{t}Â»)` or `use A âˆ© Â«{t}Â»`."
msgstr " Intenta `apply Exists.intro (A âˆ© Â«{t}Â»)` o `use A âˆ© Â«{t}Â»`."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid "You can use `rewrite [mem_setOf]` to write out the meaning of the goal."
msgstr ""
" Puedes usar `rewrite [mem_setOf]` para escribir el significado del "
"objetivo."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid "Again, work out the consequences of `Â«{h1}Â»` first."
msgstr " En primer lugar, trabaja en las consecuencias de `Â«{h1}Â»`."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"You can separate out the first half of `Â«{ht}Â»` with `have Â«{ht}Â»l := "
"Â«{ht}Â».left`."
msgstr ""
" Puedes separar la primera mitad de `Â«{ht}Â»` con `have Â«{ht}Â»l := "
"Â«{ht}Â».left`."

#: Game.Levels.FamUnion.L07eltwiseinter
msgid ""
"You know `Â«{x}Â» âˆˆ Â«{t}Â»` and `Â«{t}Â» = A âˆ© Â«{u}Â»`.  So you can use `rewrite`\n"
"to get `Â«{x}Â» âˆˆ A âˆ© Â«{u}Â»`."
msgstr ""
" Sabes que `Â«{x}Â» âˆˆ Â«{t}Â»` y que `Â«{t}Â» = A âˆ© Â«{u}Â»`. AsÃ­ que puedes usar "
"`rewrite` para obtener `Â«{x}Â» âˆˆ A âˆ© Â«{u}Â»`."

#: Game.Levels.FamUnion
msgid "Family Union World"
msgstr "Mundo de la uniÃ³n de familias"

#: Game.Levels.FamUnion
msgid ""
"If `F` is a family of sets from `U`, then the *union* of `F` is the set of"
" all objects from\n"
"`U` that belong to at least one element of `F`.  We'll investigate unions of"
" families in this\n"
"world."
msgstr ""
" Si `F` es una familia de conjuntos de `U`, entonces la *uniÃ³n* de `F` es el"
" conjunto de todos los objetos\n"
"de `U` que pertenecen al menos a un elemento de `F`. Investigaremos uniones"
" de familias en este\n"
"mundo."

#: Game.Levels.FamCombo.L01compunion
msgid "Complement of a family union"
msgstr "Complementario de la uniÃ³n de una familia"

#: Game.Levels.FamCombo.L01compunion
msgid ""
"In this level you'll prove a generalization of the theorem `compl_union` that"
" you proved\n"
"in Combination World.  That theorem was about the complement of a union of"
" two sets; the\n"
"theorem in this level is about the complement of a union of a family of"
" sets.\n"
"\n"
"As in the case of `compl_union`, you have a choice about how to deal with the"
" negations that\n"
"arise when you write out the meaning of complement.  You can use the"
" `push_neg` tactic to\n"
"reexpress negative statements, or you can use proof by contradiction."
msgstr ""
" En este nivel, demostrarÃ¡s una generalizaciÃ³n del teorema `compl_union` que"
" probaste en el mundo combinado. Ese teorema trataba sobre el complemento de"
" la uniÃ³n de dos conjuntos; el teorema en este nivel trata sobre el"
" complemento de la uniÃ³n de una familia de conjuntos.\n"
"\n"
"Como en el caso de `compl_union`, puedes elegir cÃ³mo lidiar con las"
" negaciones que surgen cuando escribes el significado del complemento. Puedes"
" usar la tÃ¡ctica `push_neg` para re-expresar declaraciones negativas, o"
" puedes hacer una prueba por contradicciÃ³n."

#: Game.Levels.FamCombo.L01compunion
msgid ""
"For any family of sets $F$, $(\\bigcup F)^c = \\bigcap \\{s \\mid s^c \\in"
" F\\}$."
msgstr ""
" Para cualquier familia de conjuntos $F$, $(\\bigcup F)^c = \\bigcap \\{s "
"\\mid s^c \\in F\\}$."

#: Game.Levels.FamCombo.L01compunion
msgid ""
"Since `Â«{h1}Â»` is a negative statement, a good way to reach a contradiction\n"
"would be to contradict it.  In other words, `Â«{h1}Â» _` would prove the goal"
" `False` if you can\n"
"fill in the blank with a proof of `Â«{x}Â» âˆˆ â‹ƒâ‚€ F`.  That means the tactic"
" `apply Â«{h1}Â»` will\n"
"set your goal to be `Â«{x}Â» âˆˆ â‹ƒâ‚€ F`."
msgstr ""
" Como `Â«{h1}Â»` es una declaraciÃ³n negativa, una buena manera de llegar a una"
" contradicciÃ³n\n"
"serÃ­a contradecirla. En otras palabras, `Â«{h1}Â» _` probarÃ­a el objetivo"
" `False` si puedes\n"
"rellenar el espacio en blanco con una prueba de `Â«{x}Â» âˆˆ â‹ƒâ‚€ F`. Eso significa"
" que la tÃ¡ctica\n"
"`apply Â«{h1}Â»` establecerÃ¡ tu objetivo como `Â«{x}Â» âˆˆ â‹ƒâ‚€ F`."

#: Game.Levels.FamCombo.L01compunion
msgid "What set can you apply `Â«{h1}Â»` to?"
msgstr " Â¿A quÃ© conjunto puedes aplicar Â«{h1}Â»?"

#: Game.Levels.FamCombo.L01compunion
msgid ""
"To make use of `Â«{h2}Â»`, you'll need to assert `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`.  If"
" you don't see\n"
"right away how to justify this assertion, you can just write `have Â«{h2}Â»a :"
" Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`\n"
"and Lean will set `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` as your immediate goal.  Once you"
" achieve that goal,\n"
"Lean will add `Â«{h2}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` to your list of assumptions,"
" and you can continue\n"
"with the proof of your original goal.  For further details, click on `have`"
" in the list of tactics\n"
"on the right."
msgstr ""
" Para usar `Â«{h2}Â»`, necesitarÃ¡s probar `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`. Si no ves de"
" inmediato cÃ³mo justificar esta afirmaciÃ³n, puedes escribir `have Â«{h2}Â»a :"
" Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`\n"
"y Lean establecerÃ¡ `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` como tu objetivo inmediato. Una"
" vez que hayas logrado ese objetivo,\n"
"Lean agregarÃ¡ `Â«{h2}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` a tu lista de suposiciones y"
" podrÃ¡s continuar\n"
"con la prueba de tu objetivo original. Para obtener mÃ¡s detalles, haz clic en"
" `have` en la lista de tÃ¡cticas\n"
"a la derecha."

#: Game.Levels.FamCombo.L01compunion
msgid "What set can you apply `Â«{h1}Â»` to?"
msgstr " Â¿A quÃ© conjunto puedes aplicar Â«{h1}Â»?"

#: Game.Levels.FamCombo.L01compunion
msgid ""
"To make use of `Â«{h3}Â»`, you'll need to assert `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`.  If"
" you don't see\n"
"right away how to justify this assertion, you can just write `have Â«{h3}Â»a :"
" Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`\n"
"and Lean will set `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` as your immediate goal.  Once you"
" achieve that goal,\n"
"Lean will add `Â«{h3}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` to your list of assumptions,"
" and you can continue\n"
"with the proof of your original goal.  For further details, click on `have`"
" in the list of tactics\n"
"on the right."
msgstr ""
" Para usar `Â«{h3}Â»`, necesitarÃ¡s afirmar `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}`. Si no ves "
"de inmediato cÃ³mo justificar esta afirmaciÃ³n, puedes simplemente escribir "
"`have Â«{h3}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` y Lean establecerÃ¡ `Â«{t}Â»á¶œ âˆˆ {s | sá¶œ "
"âˆˆ F}` como tu objetivo inmediato. Una vez que logres ese objetivo, Lean "
"agregarÃ¡ `Â«{h3}Â»a : Â«{t}Â»á¶œ âˆˆ {s | sá¶œ âˆˆ F}` a tu lista de suposiciones y "
"podrÃ¡s continuar con la prueba de tu objetivo original. Para obtener mÃ¡s "
"detalles, haz clic en `have` en la lista de tÃ¡cticas a la derecha."

#: Game.Levels.FamCombo.L02compinter
msgid "Complement of a family intersection"
msgstr "Complementario de la intersecciÃ³n de una familia"

#: Game.Levels.FamCombo.L02compinter
msgid ""
"Perhaps you have already guessed that there is a theorem about the"
" complement\n"
"of an intersection of a family that is similar to the theorem in the last"
" level."
msgstr ""
" QuizÃ¡s ya adivinaste que hay un teorema sobre el complemento de una "
"intersecciÃ³n de una familia que es similar al teorema en el Ãºltimo nivel."

#: Game.Levels.FamCombo.L02compinter
msgid ""
"For any family of sets $F$, $(\\bigcap F)^c = \\bigcup \\{s \\mid s^c \\in"
" F\\}$."
msgstr ""
" Para cualquier familia de conjuntos $F$, $( \\bigcap F )^c = \\bigcup \\{s "
"\\mid s^c \\in F\\}$."

#: Game.Levels.FamCombo.L02compinter
msgid "What statement would you like to contradict to complete the proof?"
msgstr ""
" Â¿CuÃ¡l es el enunciado que deseas contradecir para completar la prueba?"

#: Game.Levels.FamCombo.L02compinter
msgid "Now what statement would you like to contradict to complete the proof?"
msgstr ""
" Ahora, Â¿quÃ© enunciado te gustarÃ­a contradecir para completar la prueba?"

#: Game.Levels.FamCombo.L02compinter
msgid "What statement would you like to contradict to complete the proof?"
msgstr ""
" Â¿CuÃ¡l es el enunciado que deseas contradecir para completar la prueba?"

#: Game.Levels.FamCombo.L02compinter
msgid "Now what statement would you like to contradict to complete the proof?"
msgstr ""
" Ahora, Â¿quÃ© enunciado te gustarÃ­a contradecir para completar la prueba?"

#: Game.Levels.FamCombo.L03commonelt
msgid "Two families with an element in common"
msgstr "Dos familias con un elemento en comÃºn"

#: Game.Levels.FamCombo.L03commonelt
msgid ""
"This level is an exercise in handling sequences of quantifiers that alternate"
" between\n"
"`âˆ€` and `âˆƒ`.  A good way to start is to decide which assumption to use first."
msgstr ""
" Este nivel es un ejercicio para manejar secuencias de cantidades que"
" alternan entre\n"
"`âˆ€` y `âˆƒ`. Una buena forma de empezar es decidir quÃ© suposiciÃ³n utilizar"
" primero."

#: Game.Levels.FamCombo.L03commonelt
msgid ""
"Suppose $F$ and $G$ are families of sets such that for every $s \\in F$ there"
" is some $t \\in G$\n"
"such that $s \\subseteq t$, and also there is some $s \\in F$ such that for"
" every $t \\in G$,\n"
"$t \\subseteq s$.  Then $F$ and $G$ have an element in common."
msgstr ""
" Supongamos que $F$ y $G$ son familias de conjuntos tal que para cada $s \\in"
" F$ hay algÃºn $t \\in G$\n"
"tal que $s \\subseteq t$, y tambiÃ©n hay algÃºn $s \\in F$ tal que para cada $t"
" \\in G$,\n"
"$t \\subseteq s$. Entonces, $F$ y $G$ tienen un elemento en comÃºn."

#: Game.Levels.FamCombo.L03commonelt
msgid "Look at what you know about `Â«{s}Â»` and `Â«{t}Â»`."
msgstr " Mira lo que sabes sobre `Â«{s}Â»` y `Â«{t}Â»`."

#: Game.Levels.FamCombo.L04threefam
msgid "A theorem about three families"
msgstr "Un teorema sobre tres familias"

#: Game.Levels.FamCombo.L04threefam
msgid "Here's a theorem about three related families of sets."
msgstr " AquÃ­ hay un teorema sobre tres familias de conjuntos relacionadas."

#: Game.Levels.FamCombo.L04threefam
msgid ""
"Suppose that for every $s \\in F$ there is some $u \\in G$ such that $s \\cap"
" u \\in H$.\n"
"Then $(\\bigcup F) \\cap (\\bigcap G) \\subseteq \\bigcup H$."
msgstr ""
" Supongamos que para cada $s \\in F$ hay algÃºn $u \\in G$ tal que $s \\cap u"
" \\in H$.\n"
"Entonces $(\\bigcup F) \\cap (\\bigcap G) \\subseteq \\bigcup H$."

#: Game.Levels.FamCombo.L05unionintcompunion
msgid "A union intersected with the complement of another is a subset"
msgstr " Una uniÃ³n intersecada con el complemento de otra es un subconjunto."

#: Game.Levels.FamCombo.L05unionintcompunion
msgid ""
"What happens if you intersect `â‹ƒâ‚€ F` with `(â‹ƒâ‚€ G)á¶œ`, for two families `F` "
"and `G`?"
msgstr ""
" Â¿QuÃ© sucede si intersecas `â‹ƒâ‚€ F` con `(â‹ƒâ‚€ G)á¶œ`, para dos familias `F` y "
"`G`?"

#: Game.Levels.FamCombo.L05unionintcompunion
msgid ""
"Suppose $F$ and $G$ are families of sets.  Then $(\\bigcup F) \\cap (\\bigcup"
" G)^c \\subseteq\n"
"\\bigcup (F \\cap G^c)$."
msgstr ""
" Supongamos que $F$ y $G$ son familias de conjuntos. Entonces $(\\bigcup F)"
" \\cap (\\bigcup G)^c \\subseteq\n"
"\\bigcup (F \\cap G^c)$."

#: Game.Levels.FamCombo.L06unionintunion
msgid "A subset of a union intersected with the complement of another"
msgstr " Un subconjunto de la uniÃ³n intersecada con el complemento de otra"

#: Game.Levels.FamCombo.L06unionintunion
msgid "What happens if the subset statement in the last level is reversed?"
msgstr ""
" Â¿QuÃ© sucede si se invierte la relaciÃ³n de contenido en el Ãºltimo nivel?"

#: Game.Levels.FamCombo.L06unionintunion
msgid ""
"Suppose $F$ and $G$ are families of sets and $\\bigcup (F \\cap G^c)"
" \\subseteq (\\bigcup F)\n"
"\\cap (\\bigcup G)^c$.  Then $(\\bigcup F) \\cap (\\bigcup G) \\subseteq"
" \\bigcup (F \\cap G)$."
msgstr ""
" Supongamos que $F$ y $G$ son familias de conjuntos y $\\bigcup (F \\cap "
"G^c) \\subseteq (\\bigcup F) \\cap (\\bigcup G)^c$. Entonces $(\\bigcup F) "
"\\cap (\\bigcup G) \\subseteq \\bigcup (F \\cap G)$."

#: Game.Levels.FamCombo.L07unionintcompint
msgid "A union intersected with the complement of an intersection"
msgstr " Una uniÃ³n intersecada con el complemento de una intersecciÃ³n."

#: Game.Levels.FamCombo.L07unionintcompint
msgid "This time we'll study the intersection of `(â‹ƒâ‚€ F)` and `(â‹‚â‚€ G)á¶œ`."
msgstr " Esta vez estudiaremos la intersecciÃ³n de `(â‹ƒâ‚€ F)` y `(â‹‚â‚€ G)á¶œ`."

#: Game.Levels.FamCombo.L07unionintcompint
msgid ""
"Suppose $F$ and $G$ are families of sets.  Then $(\\bigcup F) \\cap (\\bigcap"
" G)^c \\subseteq\n"
"\\bigcup \\{s \\mid \\exists u \\in F, \\exists v \\in G, s = u \\cap v^c\\}$."
msgstr ""
" Supongamos que $F$ y $G$ son familias de conjuntos. Entonces $(\\bigcup F )"
" \\cap ( \\bigcap G )^c \\subseteq \\bigcup \\{s \\mid \\exists u \\in F, "
"\\exists v \\in G, s = u \\cap v^c\\}$."

#: Game.Levels.FamCombo.L08singleton
msgid "A set that must be a singleton"
msgstr " Un conjunto que debe ser un elemento Ãºnico"

#: Game.Levels.FamCombo.L08singleton
msgid ""
"The notation `{a}` denotes a set whose only element is `a`; such a set is"
" called a *singleton*\n"
"set.  The theorem `mem_singleton_iff` expresses the definition of singleton"
" sets: `mem_singleton_iff` is\n"
"a proof of any statement of the form `x âˆˆ {a} â†” x = a`."
msgstr ""
" La notaciÃ³n `{a}` denota un conjunto cuyo Ãºnico elemento es `a`; un conjunto"
" de este tipo se llama *singleton*. El teorema `mem_singleton_iff` expresa la"
" definiciÃ³n de conjuntos singleton: `mem_singleton_iff` es\n"
"una prueba de cualquier enunciado de la forma `x âˆˆ {a} â†” x = a`."

#: Game.Levels.FamCombo.L08singleton
msgid ""
"Lean will recognize `mem_singleton_iff` is a proof of any statement of the"
" form\n"
"`x âˆˆ {a} â†” x = a`.  In Mathlib, the name of this theorem is"
" `Set.mem_singleton_iff`."
msgstr ""
" Lean reconocerÃ¡ que `mem_singleton_iff` es una prueba de cualquier enunciado"
" de la forma\n"
"`x âˆˆ {a} â†” x = a`. En Mathlib, el nombre de este teorema es"
" `Set.mem_singleton_iff`."

#: Game.Levels.FamCombo.L08singleton
msgid ""
"Suppose $A$ is a set, and for every family of sets $F$, if $\\bigcup F = A$"
" then $A \\in F$.\n"
"Then $A$ must be a singleton set."
msgstr ""
" Supongamos que $A$ es un conjunto y para cada familia de conjuntos $F$, si"
" $\\bigcup F = A$ entonces $A \\in F$.\n"
"Entonces, $A$ debe ser un conjunto de un solo elemento."

#: Game.Levels.FamCombo.L08singleton
msgid ""
"Start with `have h2 := h1 {s | ...}`.  The hard part is figuring out\n"
"how to fill in the `...`."
msgstr ""
" Comienza con `h2 := h1 {s | ...}`. La parte difÃ­cil es descubrir cÃ³mo "
"llenar el `...`."

#: Game.Levels.FamCombo.L08singleton
msgid ""
"You need to apply `h1` to a family of sets with two\n"
"properties: the union of the family must be `A`, and knowing that `A` belongs"
" to the\n"
"family must help you prove that `A` is a singleton."
msgstr ""
" Debes aplicar `h1` a una familia de conjuntos con dos\n"
"propiedades: la uniÃ³n de la familia debe ser `A`, y saber que `A` pertenece a"
" la familia debe ayudarte a probar que `A` es un singleton."

#: Game.Levels.FamCombo.L08singleton
msgid ""
"Congratulations!  You have completed the Set Theory Game!\n"
"\n"
"If you want to learn more about Lean, check out the [Lean"
" Community](https://leanprover-community.github.io)."
msgstr ""
" Enhorabuena! Has completado el Juego de TeorÃ­a de Conjuntos.\n"
"\n"
"Si quieres aprender mÃ¡s sobre Lean, visita la [Comunidad"
" Lean](https://leanprover-community.github.io)."

#: Game.Levels.FamCombo
msgid "Family Combination World"
msgstr "Mundo combinado de familias."

#: Game.Levels.FamCombo
msgid ""
"In this world we combine family unions and intersections with each other, and"
" with complements.\n"
"This level contains some of the hardest proofs in the game!"
msgstr ""
" En este mundo combinamos uniones e intersecciones de familias entre sÃ­ y con"
" complementos.\n"
"Este nivel contiene algunas de las pruebas mÃ¡s difÃ­ciles del juego!"

#: Game
msgid "Set Theory Game"
msgstr ""
"Juego de TeorÃ­a de Conjuntos\n"
"\n"

#: Game
msgid ""
"# Welcome to the Set Theory Game\n"
"#### An introduction to mathematical proof.\n"
"\n"
"In this game, you will solve a sequence of levels by proving theorems.  The"
" game\n"
"is based on an interactive theorem prover called *Lean*.\n"
"\n"
"The theorems in this game will be about sets.\n"
"A *set* is a collection of objects; the objects in the collection are\n"
"called *elements* of the set.  For example, the set of planets in our\n"
"solar system has eight elements:\n"
"Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, and Neptune.\n"
"\n"
"# Read this.\n"
"\n"
"Learning how to use an interactive theorem prover takes time.\n"
"You will get the most out of this game if you\n"
"read the help texts like this one.\n"
"\n"
"To start, click on \"Subset World\".\n"
"\n"
"## More\n"
"\n"
"Open \"Game Info\" in the \"â‰¡\" menu on the top right for resources,\n"
"links, and ways to interact with the Lean community."
msgstr ""
" # Bienvenido al Juego de TeorÃ­a de Conjuntos\n"
"#### Una introducciÃ³n a la prueba matemÃ¡tica.\n"
"\n"
"En este juego, resolverÃ¡s una secuencia de niveles demostrando teoremas. El"
" juego se basa en un verificador de teoremas interactivo llamado *Lean*.\n"
"\n"
"Los teoremas de este juego serÃ¡n sobre conjuntos. Un *conjunto* es una"
" colecciÃ³n de objetos; los objetos en la colecciÃ³n se denominan *elementos*"
" del conjunto. Por ejemplo, el conjunto de planetas en nuestro sistema solar"
" tiene ocho elementos:\n"
"Mercurio, Venus, Tierra, Marte, JÃºpiter, Saturno, Urano y Neptuno.\n"
"\n"
"# Importante.\n"
"\n"
"Aprender a usar un verificador de teoremas interactivo toma tiempo. ObtendrÃ¡s"
" el mÃ¡ximo beneficio de este juego si lees los textos de ayuda como este.\n"
"\n"
"Para comenzar, haga clic en \"Subset World\".\n"
"\n"
"## MÃ¡s\n"
"\n"
"Abra \"InformaciÃ³n del juego\" en el menÃº \"â‰¡\" en la esquina superior"
" derecha para recursos, enlaces y formas de interactuar con la comunidad de"
" Lean."

#: Game
msgid ""
"*Game version: 4.4*\n"
"\n"
"## Progress saving\n"
"\n"
"The game stores your progress in your local browser storage.\n"
"If you delete it, your progress will be lost!\n"
"\n"
"Warning: In most browsers, deleting cookies will also clear the local"
" storage\n"
"(or \"local site data\"). Make sure to download your game progress first!\n"
"\n"
"## Credits\n"
"\n"
"* **Creator:** Daniel J. Velleman; based on the Natural Numbers Game, by"
" Kevin Buzzard\n"
"* **Game Engine:** Alexander Bentkamp, Jon Eugster, Patrick Massot\n"
"\n"
"## Resources\n"
"\n"
"* The [Lean Zulip chat](https://leanprover.zulipchat.com/) forum\n"
"\n"
"## Problems?\n"
"\n"
"Please ask any questions about this game in the\n"
"[Lean Zulip chat](https://leanprover.zulipchat.com/) forum, for example in\n"
"the stream \"New Members\". The community will happily help. Note that\n"
"the Lean Zulip chat is a professional research forum.\n"
"Please use your full real name there, stay on topic, and be nice. If you're\n"
"looking for somewhere less formal (e.g. you want to post set theory\n"
"game memes) then head on over to the [Lean"
" Discord](https://discord.gg/WZ9bs9UCvx).\n"
"\n"
"Alternatively, if you experience issues / bugs you can also open github"
" issues:\n"
"\n"
"* For issues with the game engine, please open an\n"
"[issue at the lean4game repo](https://github.com/leanprover-community/lean4gam"
"e/issues).\n"
"* For issues about the game's content, please open an\n"
"[issue at the STG repo](https://github.com/djvelleman/STG4/issues)."
msgstr ""
"*VersiÃ³n del juego: 4.4*## Almacenamiento de progreso El juego almacena tu "
"progreso en el almacenamiento local de tu navegador.Si lo eliminas, perderÃ¡s"
" tu progreso!AtenciÃ³n: En la mayorÃ­a de los navegadores, eliminar las "
"cookies tambiÃ©n limpiarÃ¡ el almacenamiento local (o \"datos del sitio "
"local\"). AsegÃºrese de descargar su progreso en el juego primero!## "
"CrÃ©ditos* **Creador:** Daniel J. Velleman; basado en el Juego de nÃºmeros "
"naturales, por Kevin Buzzard* **Motor del juego:** Alexander Bentkamp, Jon "
"Eugster, Patrick Massot## Recursos* El [Lean Zulip "
"chat](https://leanprover.zulipchat.com/) foro## Problemas?Por favor, "
"pregunte cualquier duda sobre este juego en el[Lean Zulip "
"chat](https://leanprover.zulipchat.com/) foro, por ejemplo en el flujo "
"\"Miembros nuevos\". La comunidad estarÃ¡ encantada de ayudar. Note que el "
"Lean Zulip chat es un foro de investigaciÃ³n profesional.Por favor, use su "
"nombre completo y real allÃ­, cÃ©ntrese en el tema y sea amable. Si estÃ¡ "
"buscando un lugar menos formal (por ejemplo, desea publicar memes del juego "
"de la teorÃ­a de conjuntos)entonces dirÃ­jase al [Lean "
"Discord](https://discord.gg/WZ9bs9UCvx).Alternativamente, si experimenta "
"problemas / errores puede abrir issues en github:* Para problemas con el "
"motor del juego, por favor abra un[issue en el repo de "
"lean4game](https://github.com/leanprover-community/lean4game/issues).* Para "
"problemas sobre el contenido del juego, por favor abra un[issue en el repo "
"STG](https://github.com/djvelleman/STG4/issues)."

#: Game
msgid "A game about set theory."
msgstr " Un juego sobre la teorÃ­a de conjuntos."

#: Game
msgid ""
"In this game you will learn the basics of theorem proving in Lean by proving\n"
"theorems about unions, intersections, and complements of sets."
msgstr ""
" En este juego aprenderÃ¡s los conceptos bÃ¡sicos de prueba de teoremas en "
"Lean al probar teoremas sobre uniones, intersecciones y complementos de "
"conjuntos."

